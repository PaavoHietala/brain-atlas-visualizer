(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      module.exports = function equal(a, b) {
        if (a === b) return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor) return false;
          var length4, i, keys;
          if (Array.isArray(a)) {
            length4 = a.length;
            if (length4 != b.length) return false;
            for (i = length4; i-- !== 0; )
              if (!equal(a[i], b[i])) return false;
            return true;
          }
          if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
          keys = Object.keys(a);
          length4 = keys.length;
          if (length4 !== Object.keys(b).length) return false;
          for (i = length4; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
          for (i = length4; i-- !== 0; ) {
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
          }
          return true;
        }
        return a !== a && b !== b;
      };
    }
  });

  // node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/object-keys/isArguments.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str6 = toStr.call(value);
        var isArgs = str6 === "[object Arguments]";
        if (!isArgs) {
          isArgs = str6 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // node_modules/object-keys/implementation.js
  var require_implementation = __commonJS({
    "node_modules/object-keys/implementation.js"(exports, module) {
      "use strict";
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = (function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        })();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object) {
          var isObject = object !== null && typeof object === "object";
          var isFunction = toStr.call(object) === "[object Function]";
          var isArguments = isArgs(object);
          var isString = isObject && toStr.call(object) === "[object String]";
          var theKeys = [];
          if (!isObject && !isFunction && !isArguments) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object.length > 0 && !has.call(object, 0)) {
            for (var i = 0; i < object.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object.length > 0) {
            for (var j = 0; j < object.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object) {
              if (!(skipProto && name === "prototype") && has.call(object, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module.exports = keysShim;
    }
  });

  // node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "node_modules/object-keys/index.js"(exports, module) {
      "use strict";
      var slice = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = (function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          })(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object) {
              if (isArgs(object)) {
                return originalKeys(slice.call(object));
              }
              return originalKeys(object);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    }
  });

  // node_modules/es-define-property/index.js
  var require_es_define_property = __commonJS({
    "node_modules/es-define-property/index.js"(exports, module) {
      "use strict";
      var $defineProperty = Object.defineProperty || false;
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = false;
        }
      }
      module.exports = $defineProperty;
    }
  });

  // node_modules/es-errors/syntax.js
  var require_syntax = __commonJS({
    "node_modules/es-errors/syntax.js"(exports, module) {
      "use strict";
      module.exports = SyntaxError;
    }
  });

  // node_modules/es-errors/type.js
  var require_type = __commonJS({
    "node_modules/es-errors/type.js"(exports, module) {
      "use strict";
      module.exports = TypeError;
    }
  });

  // node_modules/gopd/gOPD.js
  var require_gOPD = __commonJS({
    "node_modules/gopd/gOPD.js"(exports, module) {
      "use strict";
      module.exports = Object.getOwnPropertyDescriptor;
    }
  });

  // node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "node_modules/gopd/index.js"(exports, module) {
      "use strict";
      var $gOPD = require_gOPD();
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    }
  });

  // node_modules/define-data-property/index.js
  var require_define_data_property = __commonJS({
    "node_modules/define-data-property/index.js"(exports, module) {
      "use strict";
      var $defineProperty = require_es_define_property();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var gopd = require_gopd();
      module.exports = function defineDataProperty(obj2, property, value) {
        if (!obj2 || typeof obj2 !== "object" && typeof obj2 !== "function") {
          throw new $TypeError("`obj` must be an object or a function`");
        }
        if (typeof property !== "string" && typeof property !== "symbol") {
          throw new $TypeError("`property` must be a string or a symbol`");
        }
        if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
          throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
          throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
          throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
          throw new $TypeError("`loose`, if provided, must be a boolean");
        }
        var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
        var nonWritable = arguments.length > 4 ? arguments[4] : null;
        var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
        var loose = arguments.length > 6 ? arguments[6] : false;
        var desc = !!gopd && gopd(obj2, property);
        if ($defineProperty) {
          $defineProperty(obj2, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
          });
        } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
          obj2[property] = value;
        } else {
          throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }
      };
    }
  });

  // node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      var $defineProperty = require_es_define_property();
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        return !!$defineProperty;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!$defineProperty) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "node_modules/define-properties/index.js"(exports, module) {
      "use strict";
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var defineDataProperty = require_define_data_property();
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
      };
      var supportsDescriptors = require_has_property_descriptors()();
      var defineProperty = function(object, name, value, predicate) {
        if (name in object) {
          if (predicate === true) {
            if (object[name] === value) {
              return;
            }
          } else if (!isFunction(predicate) || !predicate()) {
            return;
          }
        }
        if (supportsDescriptors) {
          defineDataProperty(object, name, value, true);
        } else {
          defineDataProperty(object, name, value);
        }
      };
      var defineProperties = function(object, map2) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map2);
        if (hasSymbols) {
          props = concat.call(props, Object.getOwnPropertySymbols(map2));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object, props[i], map2[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    }
  });

  // node_modules/globalthis/implementation.browser.js
  var require_implementation_browser = __commonJS({
    "node_modules/globalthis/implementation.browser.js"(exports, module) {
      "use strict";
      if (typeof self !== "undefined") {
        module.exports = self;
      } else if (typeof window !== "undefined") {
        module.exports = window;
      } else {
        module.exports = Function("return this")();
      }
    }
  });

  // node_modules/globalthis/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/globalthis/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation_browser();
      module.exports = function getPolyfill() {
        if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
          return implementation;
        }
        return global;
      };
    }
  });

  // node_modules/globalthis/shim.js
  var require_shim = __commonJS({
    "node_modules/globalthis/shim.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var getPolyfill = require_polyfill();
      module.exports = function shimGlobal() {
        var polyfill = getPolyfill();
        if (define2.supportsDescriptors) {
          var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
          if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
            Object.defineProperty(polyfill, "globalThis", {
              configurable: true,
              enumerable: false,
              value: polyfill,
              writable: true
            });
          }
        } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
          polyfill.globalThis = polyfill;
        }
        return polyfill;
      };
    }
  });

  // node_modules/globalthis/index.js
  var require_globalthis = __commonJS({
    "node_modules/globalthis/index.js"(exports, module) {
      "use strict";
      var defineProperties = require_define_properties();
      var implementation = require_implementation_browser();
      var getPolyfill = require_polyfill();
      var shim = require_shim();
      var polyfill = getPolyfill();
      var getGlobal = function() {
        return polyfill;
      };
      defineProperties(getGlobal, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = getGlobal;
    }
  });

  // node_modules/seedrandom/lib/alea.js
  var require_alea = __commonJS({
    "node_modules/seedrandom/lib/alea.js"(exports, module) {
      (function(global2, module2, define2) {
        function Alea(seed) {
          var me = this, mash = Mash();
          me.next = function() {
            var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
          };
          me.c = 1;
          me.s0 = mash(" ");
          me.s1 = mash(" ");
          me.s2 = mash(" ");
          me.s0 -= mash(seed);
          if (me.s0 < 0) {
            me.s0 += 1;
          }
          me.s1 -= mash(seed);
          if (me.s1 < 0) {
            me.s1 += 1;
          }
          me.s2 -= mash(seed);
          if (me.s2 < 0) {
            me.s2 += 1;
          }
          mash = null;
        }
        function copy7(f, t) {
          t.c = f.c;
          t.s0 = f.s0;
          t.s1 = f.s1;
          t.s2 = f.s2;
          return t;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state2 = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state2) {
            if (typeof state2 == "object") copy7(state2, xg);
            prng.state = function() {
              return copy7(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n = 4022871197;
          var mash = function(data) {
            data = String(data);
            for (var i = 0; i < data.length; i++) {
              n += data.charCodeAt(i);
              var h = 0.02519603282416938 * n;
              n = h >>> 0;
              h -= n;
              h *= n;
              n = h >>> 0;
              h -= n;
              n += h * 4294967296;
            }
            return (n >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xor128.js
  var require_xor128 = __commonJS({
    "node_modules/seedrandom/lib/xor128.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
          };
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy7(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state2) {
            if (typeof state2 == "object") copy7(state2, xg);
            prng.state = function() {
              return copy7(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xorwow.js
  var require_xorwow = __commonJS({
    "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
          };
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.v = 0;
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) {
              me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
          }
        }
        function copy7(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          t.v = f.v;
          t.d = f.d;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state2) {
            if (typeof state2 == "object") copy7(state2, xg);
            prng.state = function() {
              return copy7(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift7 = __commonJS({
    "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var X = me.x, i = me.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me.i = i + 1 & 7;
            return v;
          };
          function init(me2, seed2) {
            var j, w, X = [];
            if (seed2 === (seed2 | 0)) {
              w = X[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j = 0; j < seed2.length; ++j) {
                X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
              }
            }
            while (X.length < 8) X.push(0);
            for (j = 0; j < 8 && X[j] === 0; ++j) ;
            if (j == 8) w = X[7] = -1;
            else w = X[j];
            me2.x = X;
            me2.i = 0;
            for (j = 256; j > 0; --j) {
              me2.next();
            }
          }
          init(me, seed);
        }
        function copy7(f, t) {
          t.x = f.x.slice();
          t.i = f.i;
          return t;
        }
        function impl(seed, opts) {
          if (seed == null) seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state2) {
            if (state2.x) copy7(state2, xg);
            prng.state = function() {
              return copy7(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xor4096.js
  var require_xor4096 = __commonJS({
    "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var w = me.w, X = me.X, i = me.i, t, v;
            me.w = w = w + 1640531527 | 0;
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            v = X[i] = v ^ t;
            me.i = i;
            return v + (w ^ w >>> 16) | 0;
          };
          function init(me2, seed2) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i = 0, j = -32; j < limit; ++j) {
              if (seed2) v ^= seed2.charCodeAt((j + 32) % seed2.length);
              if (j === 0) w = v;
              v ^= v << 10;
              v ^= v >>> 15;
              v ^= v << 4;
              v ^= v >>> 13;
              if (j >= 0) {
                w = w + 1640531527 | 0;
                t = X[j & 127] ^= v + w;
                i = 0 == t ? i + 1 : 0;
              }
            }
            if (i >= 128) {
              X[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i = 127;
            for (j = 4 * 128; j > 0; --j) {
              v = X[i + 34 & 127];
              t = X[i = i + 1 & 127];
              v ^= v << 13;
              t ^= t << 17;
              v ^= v >>> 15;
              t ^= t >>> 12;
              X[i] = v ^ t;
            }
            me2.w = w;
            me2.X = X;
            me2.i = i;
          }
          init(me, seed);
        }
        function copy7(f, t) {
          t.i = f.i;
          t.w = f.w;
          t.X = f.X.slice();
          return t;
        }
        ;
        function impl(seed, opts) {
          if (seed == null) seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state2) {
            if (state2.X) copy7(state2, xg);
            prng.state = function() {
              return copy7(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(
        exports,
        // window object or global
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/tychei.js
  var require_tychei = __commonJS({
    "node_modules/seedrandom/lib/tychei.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
          };
          me.a = 0;
          me.b = 0;
          me.c = 2654435769 | 0;
          me.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me.a = seed / 4294967296 | 0;
            me.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 20; k++) {
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy7(f, t) {
          t.a = f.a;
          t.b = f.b;
          t.c = f.c;
          t.d = f.d;
          return t;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state2) {
            if (typeof state2 == "object") copy7(state2, xg);
            prng.state = function() {
              return copy7(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/seedrandom/seedrandom.js
  var require_seedrandom = __commonJS({
    "node_modules/seedrandom/seedrandom.js"(exports, module) {
      (function(global2, pool, math) {
        var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom2(seed, options, callback) {
          var key = [];
          options = options == true ? { entropy: true } : options || {};
          var shortseed = mixkey(flatten(
            options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
            3
          ), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0;
            while (n < significance) {
              n = (n + x) * width;
              d *= width;
              x = arc4.g(1);
            }
            while (n >= overflow) {
              n /= 2;
              d /= 2;
              x >>>= 1;
            }
            return (n + x) / d;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state2) {
            if (state2) {
              if (state2.S) {
                copy7(state2, arc4);
              }
              prng2.state = function() {
                return copy7(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else return prng2;
          })(
            prng,
            shortseed,
            "global" in options ? options.global : this == math,
            options.state
          );
        }
        function ARC4(key) {
          var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i < width) {
            s[i] = i++;
          }
          for (i = 0; i < width; i++) {
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
          }
          (me.g = function(count) {
            var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
            while (count--) {
              t2 = s2[i2 = mask & i2 + 1];
              r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
            }
            me.i = i2;
            me.j = j2;
            return r;
          })(width);
        }
        function copy7(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        }
        ;
        function flatten(obj2, depth) {
          var result = [], typ = typeof obj2, prop;
          if (depth && typ == "object") {
            for (prop in obj2) {
              try {
                result.push(flatten(obj2[prop], depth - 1));
              } catch (e) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj2 : obj2 + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global2.crypto || global2.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e) {
            var browser = global2.navigator, plugins = browser && browser.plugins;
            return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math.random(), pool);
        if (typeof module == "object" && module.exports) {
          module.exports = seedrandom2;
          try {
            nodecrypto = require_crypto();
          } catch (ex) {
          }
        } else if (typeof define == "function" && define.amd) {
          define(function() {
            return seedrandom2;
          });
        } else {
          math["seed" + rngname] = seedrandom2;
        }
      })(
        // global: `self` in browsers (including strict mode and web workers),
        // otherwise `this` in Node and other environments
        typeof self !== "undefined" ? self : exports,
        [],
        // pool: entropy pool starts empty
        Math
        // math: package containing random, pow, and seedrandom
      );
    }
  });

  // node_modules/seedrandom/index.js
  var require_seedrandom2 = __commonJS({
    "node_modules/seedrandom/index.js"(exports, module) {
      var alea = require_alea();
      var xor128 = require_xor128();
      var xorwow = require_xorwow();
      var xorshift7 = require_xorshift7();
      var xor4096 = require_xor4096();
      var tychei = require_tychei();
      var sr = require_seedrandom();
      sr.alea = alea;
      sr.xor128 = xor128;
      sr.xorwow = xorwow;
      sr.xorshift7 = xorshift7;
      sr.xor4096 = xor4096;
      sr.tychei = tychei;
      module.exports = sr;
    }
  });

  // node_modules/spark-md5/spark-md5.js
  var require_spark_md5 = __commonJS({
    "node_modules/spark-md5/spark-md5.js"(exports, module) {
      (function(factory) {
        if (typeof exports === "object") {
          module.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define(factory);
        } else {
          var glob;
          try {
            glob = window;
          } catch (e) {
            glob = self;
          }
          glob.SparkMD5 = factory();
        }
      })(function(undefined2) {
        "use strict";
        var add32 = function(a, b) {
          return a + b & 4294967295;
        }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        function cmn(q, a, b, x, s, t) {
          a = add32(add32(a, q), add32(x, t));
          return add32(a << s | a >>> 32 - s, b);
        }
        function md5cycle(x, k) {
          var a = x[0], b = x[1], c = x[2], d = x[3];
          a += (b & c | ~b & d) + k[0] - 680876936 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[1] - 389564586 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[2] + 606105819 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & c | ~b & d) + k[4] - 176418897 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[7] - 45705983 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[10] - 42063 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[13] - 40341101 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & d | c & ~d) + k[1] - 165796510 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[11] + 643717713 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[0] - 373897302 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b & d | c & ~d) + k[5] - 701558691 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[10] + 38016083 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[15] - 660478335 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[4] - 405537848 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b & d | c & ~d) + k[9] + 568446438 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[3] - 187363961 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[2] - 51403784 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b ^ c ^ d) + k[5] - 378558 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[14] - 35309556 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[7] - 155497632 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (b ^ c ^ d) + k[13] + 681279174 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[0] - 358537222 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[3] - 722521979 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[6] + 76029189 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (b ^ c ^ d) + k[9] - 640364487 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[12] - 421815835 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[15] + 530742520 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[2] - 995338651 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          x[0] = a + x[0] | 0;
          x[1] = b + x[1] | 0;
          x[2] = c + x[2] | 0;
          x[3] = d + x[3] | 0;
        }
        function md5blk(s) {
          var md5blks = [], i;
          for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
          }
          return md5blks;
        }
        function md5blk_array(a) {
          var md5blks = [], i;
          for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
          }
          return md5blks;
        }
        function md51(s) {
          var n = s.length, state2 = [1732584193, -271733879, -1732584194, 271733878], i, length4, tail, tmp, lo, hi;
          for (i = 64; i <= n; i += 64) {
            md5cycle(state2, md5blk(s.substring(i - 64, i)));
          }
          s = s.substring(i - 64);
          length4 = s.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i = 0; i < length4; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
          }
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(state2, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp = n * 8;
          tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp[2], 16);
          hi = parseInt(tmp[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state2, tail);
          return state2;
        }
        function md51_array(a) {
          var n = a.length, state2 = [1732584193, -271733879, -1732584194, 271733878], i, length4, tail, tmp, lo, hi;
          for (i = 64; i <= n; i += 64) {
            md5cycle(state2, md5blk_array(a.subarray(i - 64, i)));
          }
          a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
          length4 = a.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i = 0; i < length4; i += 1) {
            tail[i >> 2] |= a[i] << (i % 4 << 3);
          }
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(state2, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp = n * 8;
          tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp[2], 16);
          hi = parseInt(tmp[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state2, tail);
          return state2;
        }
        function rhex(n) {
          var s = "", j;
          for (j = 0; j < 4; j += 1) {
            s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
          }
          return s;
        }
        function hex2(x) {
          var i;
          for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
          }
          return x.join("");
        }
        if (hex2(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
          add32 = function(x, y) {
            var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return msw << 16 | lsw & 65535;
          };
        }
        if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
          (function() {
            function clamp(val, length4) {
              val = val | 0 || 0;
              if (val < 0) {
                return Math.max(val + length4, 0);
              }
              return Math.min(val, length4);
            }
            ArrayBuffer.prototype.slice = function(from, to) {
              var length4 = this.byteLength, begin = clamp(from, length4), end = length4, num, target, targetArray, sourceArray;
              if (to !== undefined2) {
                end = clamp(to, length4);
              }
              if (begin > end) {
                return new ArrayBuffer(0);
              }
              num = end - begin;
              target = new ArrayBuffer(num);
              targetArray = new Uint8Array(target);
              sourceArray = new Uint8Array(this, begin, num);
              targetArray.set(sourceArray);
              return target;
            };
          })();
        }
        function toUtf8(str6) {
          if (/[\u0080-\uFFFF]/.test(str6)) {
            str6 = unescape(encodeURIComponent(str6));
          }
          return str6;
        }
        function utf8Str2ArrayBuffer(str6, returnUInt8Array) {
          var length4 = str6.length, buff = new ArrayBuffer(length4), arr = new Uint8Array(buff), i;
          for (i = 0; i < length4; i += 1) {
            arr[i] = str6.charCodeAt(i);
          }
          return returnUInt8Array ? arr : buff;
        }
        function arrayBuffer2Utf8Str(buff) {
          return String.fromCharCode.apply(null, new Uint8Array(buff));
        }
        function concatenateArrayBuffers(first, second, returnUInt8Array) {
          var result = new Uint8Array(first.byteLength + second.byteLength);
          result.set(new Uint8Array(first));
          result.set(new Uint8Array(second), first.byteLength);
          return returnUInt8Array ? result : result.buffer;
        }
        function hexToBinaryString(hex3) {
          var bytes = [], length4 = hex3.length, x;
          for (x = 0; x < length4 - 1; x += 2) {
            bytes.push(parseInt(hex3.substr(x, 2), 16));
          }
          return String.fromCharCode.apply(String, bytes);
        }
        function SparkMD5() {
          this.reset();
        }
        SparkMD5.prototype.append = function(str6) {
          this.appendBinary(toUtf8(str6));
          return this;
        };
        SparkMD5.prototype.appendBinary = function(contents) {
          this._buff += contents;
          this._length += contents.length;
          var length4 = this._buff.length, i;
          for (i = 64; i <= length4; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
          }
          this._buff = this._buff.substring(i - 64);
          return this;
        };
        SparkMD5.prototype.end = function(raw) {
          var buff = this._buff, length4 = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
          for (i = 0; i < length4; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
          }
          this._finish(tail, length4);
          ret = hex2(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD5.prototype.reset = function() {
          this._buff = "";
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD5.prototype.getState = function() {
          return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
          };
        };
        SparkMD5.prototype.setState = function(state2) {
          this._buff = state2.buff;
          this._length = state2.length;
          this._hash = state2.hash;
          return this;
        };
        SparkMD5.prototype.destroy = function() {
          delete this._hash;
          delete this._buff;
          delete this._length;
        };
        SparkMD5.prototype._finish = function(tail, length4) {
          var i = length4, tmp, lo, hi;
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp = this._length * 8;
          tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp[2], 16);
          hi = parseInt(tmp[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(this._hash, tail);
        };
        SparkMD5.hash = function(str6, raw) {
          return SparkMD5.hashBinary(toUtf8(str6), raw);
        };
        SparkMD5.hashBinary = function(content, raw) {
          var hash = md51(content), ret = hex2(hash);
          return raw ? hexToBinaryString(ret) : ret;
        };
        SparkMD5.ArrayBuffer = function() {
          this.reset();
        };
        SparkMD5.ArrayBuffer.prototype.append = function(arr) {
          var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length4 = buff.length, i;
          this._length += arr.byteLength;
          for (i = 64; i <= length4; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
          }
          this._buff = i - 64 < length4 ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
          return this;
        };
        SparkMD5.ArrayBuffer.prototype.end = function(raw) {
          var buff = this._buff, length4 = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
          for (i = 0; i < length4; i += 1) {
            tail[i >> 2] |= buff[i] << (i % 4 << 3);
          }
          this._finish(tail, length4);
          ret = hex2(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD5.ArrayBuffer.prototype.reset = function() {
          this._buff = new Uint8Array(0);
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD5.ArrayBuffer.prototype.getState = function() {
          var state2 = SparkMD5.prototype.getState.call(this);
          state2.buff = arrayBuffer2Utf8Str(state2.buff);
          return state2;
        };
        SparkMD5.ArrayBuffer.prototype.setState = function(state2) {
          state2.buff = utf8Str2ArrayBuffer(state2.buff, true);
          return SparkMD5.prototype.setState.call(this, state2);
        };
        SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
        SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
        SparkMD5.ArrayBuffer.hash = function(arr, raw) {
          var hash = md51_array(new Uint8Array(arr)), ret = hex2(hash);
          return raw ? hexToBinaryString(ret) : ret;
        };
        return SparkMD5;
      });
    }
  });

  // node_modules/@kitware/vtk.js/macros2.js
  var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

  // node_modules/@kitware/vtk.js/vtk.js
  var import_globalthis = __toESM(require_globalthis(), 1);
  var vtkGlobal = (0, import_globalthis.default)();
  var factoryMapping = {
    vtkObject: () => null
  };
  function vtk(obj2) {
    if (obj2 === null || obj2 === void 0) {
      return obj2;
    }
    if (obj2.isA) {
      return obj2;
    }
    if (!obj2.vtkClass) {
      if (vtkGlobal.console && vtkGlobal.console.error) {
        vtkGlobal.console.error("Invalid VTK object");
      }
      return null;
    }
    const constructor = factoryMapping[obj2.vtkClass];
    if (!constructor) {
      if (vtkGlobal.console && vtkGlobal.console.error) {
        vtkGlobal.console.error(`No vtk class found for Object of type ${obj2.vtkClass}`);
      }
      return null;
    }
    const model = {
      ...obj2
    };
    Object.keys(model).forEach((keyName) => {
      if (model[keyName] && typeof model[keyName] === "object" && model[keyName].vtkClass) {
        model[keyName] = vtk(model[keyName]);
      }
    });
    const newInst = constructor(model);
    if (newInst && newInst.modified) {
      newInst.modified();
    }
    return newInst;
  }
  function register(vtkClassName, constructor) {
    factoryMapping[vtkClassName] = constructor;
  }
  vtk.register = register;

  // node_modules/@kitware/vtk.js/Common/Core/ClassHierarchy.js
  var ClassHierarchy = class extends Array {
    push() {
      for (let i = 0; i < arguments.length; i++) {
        if (!this.includes(arguments[i])) {
          super.push(arguments[i]);
        }
      }
      return this.length;
    }
  };

  // node_modules/@kitware/vtk.js/macros2.js
  var globalMTime = 0;
  var requiredParam = (name) => {
    throw new Error(`Named parameter '${name}' is missing`);
  };
  var VOID = Symbol("void");
  function getCurrentGlobalMTime() {
    return globalMTime;
  }
  var fakeConsole = {};
  function noOp() {
  }
  var consoleMethods = ["log", "debug", "info", "warn", "error", "time", "timeEnd", "group", "groupEnd"];
  consoleMethods.forEach((methodName) => {
    fakeConsole[methodName] = noOp;
  });
  vtkGlobal.console = console.hasOwnProperty("log") ? console : fakeConsole;
  var loggerFunctions = {
    debug: noOp,
    // Don't print debug by default
    error: vtkGlobal.console.error || noOp,
    info: vtkGlobal.console.info || noOp,
    log: vtkGlobal.console.log || noOp,
    warn: vtkGlobal.console.warn || noOp
  };
  function setLoggerFunction(name, fn) {
    if (loggerFunctions[name]) {
      loggerFunctions[name] = fn || noOp;
    }
  }
  function vtkLogMacro() {
    loggerFunctions.log(...arguments);
  }
  function vtkInfoMacro() {
    loggerFunctions.info(...arguments);
  }
  function vtkDebugMacro() {
    loggerFunctions.debug(...arguments);
  }
  function vtkErrorMacro2() {
    loggerFunctions.error(...arguments);
  }
  function vtkWarningMacro() {
    loggerFunctions.warn(...arguments);
  }
  var ERROR_ONCE_MAP = {};
  function vtkOnceErrorMacro(str6) {
    if (!ERROR_ONCE_MAP[str6]) {
      loggerFunctions.error(str6);
      ERROR_ONCE_MAP[str6] = true;
    }
  }
  var TYPED_ARRAYS = /* @__PURE__ */ Object.create(null);
  TYPED_ARRAYS.Float32Array = Float32Array;
  TYPED_ARRAYS.Float64Array = Float64Array;
  TYPED_ARRAYS.Uint8Array = Uint8Array;
  TYPED_ARRAYS.Int8Array = Int8Array;
  TYPED_ARRAYS.Uint16Array = Uint16Array;
  TYPED_ARRAYS.Int16Array = Int16Array;
  TYPED_ARRAYS.Uint32Array = Uint32Array;
  TYPED_ARRAYS.Int32Array = Int32Array;
  TYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;
  try {
    TYPED_ARRAYS.BigInt64Array = BigInt64Array;
    TYPED_ARRAYS.BigUint64Array = BigUint64Array;
  } catch {
  }
  function newTypedArray(type) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return new (TYPED_ARRAYS[type] || Float64Array)(...args);
  }
  function newTypedArrayFrom(type) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return (TYPED_ARRAYS[type] || Float64Array).from(...args);
  }
  function capitalize(str6) {
    return str6.charAt(0).toUpperCase() + str6.slice(1);
  }
  function _capitalize(str6) {
    return capitalize(str6[0] === "_" ? str6.slice(1) : str6);
  }
  function uncapitalize(str6) {
    return str6.charAt(0).toLowerCase() + str6.slice(1);
  }
  function formatBytesToProperUnit(size) {
    let precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    let chunkSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3;
    const units = ["TB", "GB", "MB", "KB"];
    let value = Number(size);
    let currentUnit = "B";
    while (value > chunkSize) {
      value /= chunkSize;
      currentUnit = units.pop();
    }
    return `${value.toFixed(precision)} ${currentUnit}`;
  }
  function formatNumbersWithThousandSeparator(n) {
    let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
    const sections = [];
    let size = n;
    while (size > 1e3) {
      sections.push(`000${size % 1e3}`.slice(-3));
      size = Math.floor(size / 1e3);
    }
    if (size > 0) {
      sections.push(size);
    }
    sections.reverse();
    return sections.join(separator);
  }
  function safeArrays(model) {
    Object.keys(model).forEach((key) => {
      if (Array.isArray(model[key])) {
        model[key] = [].concat(model[key]);
      }
    });
  }
  function isTypedArray(value) {
    return Object.values(TYPED_ARRAYS).some((ctor) => value instanceof ctor);
  }
  function shallowEquals(a, b) {
    if (a === b) {
      return true;
    }
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function enumToString(e, value) {
    return Object.keys(e).find((key) => e[key] === value);
  }
  function getStateArrayMapFunc(item) {
    if (item && item.isA) {
      return item.getState();
    }
    return item;
  }
  function setImmediateVTK(fn) {
    setTimeout(fn, 0);
  }
  function measurePromiseExecution(promise, callback) {
    const start = performance.now();
    promise.finally(() => {
      const delta = performance.now() - start;
      callback(delta);
    });
  }
  function obj() {
    let publicAPI = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let model = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    safeArrays(model);
    const callbacks = [];
    if (!Number.isInteger(model.mtime)) {
      model.mtime = ++globalMTime;
    }
    if (!("classHierarchy" in model)) {
      model.classHierarchy = new ClassHierarchy("vtkObject");
    } else if (!(model.classHierarchy instanceof ClassHierarchy)) {
      const hierarchy = new ClassHierarchy();
      for (let i = 0; i < model.classHierarchy.length; i++) {
        hierarchy.push(model.classHierarchy[i]);
      }
      model.classHierarchy = hierarchy;
    }
    function off(index) {
      callbacks[index] = null;
    }
    function on(index) {
      function unsubscribe() {
        off(index);
      }
      return Object.freeze({
        unsubscribe
      });
    }
    publicAPI.isDeleted = () => !!model.deleted;
    publicAPI.modified = (otherMTime) => {
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return;
      }
      if (otherMTime && otherMTime < publicAPI.getMTime()) {
        return;
      }
      model.mtime = ++globalMTime;
      callbacks.forEach((callback) => callback && callback(publicAPI));
    };
    publicAPI.onModified = (callback) => {
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return null;
      }
      const index = callbacks.length;
      callbacks.push(callback);
      return on(index);
    };
    publicAPI.getMTime = () => model.mtime;
    publicAPI.isA = (className) => {
      let count = model.classHierarchy.length;
      while (count--) {
        if (model.classHierarchy[count] === className) {
          return true;
        }
      }
      return false;
    };
    publicAPI.getClassName = function() {
      let depth = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return model.classHierarchy[model.classHierarchy.length - 1 - depth];
    };
    publicAPI.set = function() {
      let map2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let noWarning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      let noFunction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let ret = false;
      Object.keys(map2).forEach((name) => {
        const fn = noFunction ? null : publicAPI[`set${capitalize(name)}`];
        if (fn && Array.isArray(map2[name]) && fn.length > 1) {
          ret = fn(...map2[name]) || ret;
        } else if (fn) {
          ret = fn(map2[name]) || ret;
        } else {
          if (["mtime"].indexOf(name) === -1 && !noWarning) {
            vtkWarningMacro(`Warning: Set value to model directly ${name}, ${map2[name]}`);
          }
          ret = model[name] !== map2[name] || ret;
          model[name] = map2[name];
        }
      });
      return ret;
    };
    publicAPI.get = function() {
      for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        list[_key3] = arguments[_key3];
      }
      if (!list.length) {
        return model;
      }
      const subset = {};
      list.forEach((name) => {
        subset[name] = model[name];
      });
      return subset;
    };
    publicAPI.getReferenceByName = (val) => model[val];
    publicAPI.delete = () => {
      Object.keys(model).forEach((field) => delete model[field]);
      callbacks.forEach((el, index) => off(index));
      model.deleted = true;
    };
    publicAPI.getState = () => {
      if (model.deleted) {
        return null;
      }
      const jsonArchive = {
        ...model,
        vtkClass: publicAPI.getClassName()
      };
      Object.keys(jsonArchive).forEach((keyName) => {
        if (jsonArchive[keyName] === null || jsonArchive[keyName] === void 0 || keyName[0] === "_") {
          delete jsonArchive[keyName];
        } else if (jsonArchive[keyName].isA) {
          jsonArchive[keyName] = jsonArchive[keyName].getState();
        } else if (Array.isArray(jsonArchive[keyName])) {
          jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
        } else if (isTypedArray(jsonArchive[keyName])) {
          jsonArchive[keyName] = Array.from(jsonArchive[keyName]);
        }
      });
      const sortedObj = {};
      Object.keys(jsonArchive).sort().forEach((name) => {
        sortedObj[name] = jsonArchive[name];
      });
      if (sortedObj.mtime) {
        delete sortedObj.mtime;
      }
      return sortedObj;
    };
    publicAPI.shallowCopy = function(other) {
      let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (other.getClassName() !== publicAPI.getClassName()) {
        throw new Error(`Cannot ShallowCopy ${other.getClassName()} into ${publicAPI.getClassName()}`);
      }
      const otherModel = other.get();
      const keyList = Object.keys(model).sort();
      const otherKeyList = Object.keys(otherModel).sort();
      otherKeyList.forEach((key) => {
        const keyIdx = keyList.indexOf(key);
        if (keyIdx === -1) {
          if (debug) {
            vtkDebugMacro(`add ${key} in shallowCopy`);
          }
        } else {
          keyList.splice(keyIdx, 1);
        }
        model[key] = otherModel[key];
      });
      if (keyList.length && debug) {
        vtkDebugMacro(`Untouched keys: ${keyList.join(", ")}`);
      }
      publicAPI.modified();
    };
    publicAPI.toJSON = function vtkObjToJSON() {
      return publicAPI.getState();
    };
    return publicAPI;
  }
  var objectGetterMap = {
    object(publicAPI, model, field) {
      return function getter() {
        return {
          ...model[field.name]
        };
      };
    }
  };
  function get(publicAPI, model, fieldNames) {
    fieldNames.forEach((field) => {
      if (typeof field === "object") {
        const getter = objectGetterMap[field.type];
        if (getter) {
          publicAPI[`get${_capitalize(field.name)}`] = getter(publicAPI, model, field);
        } else {
          publicAPI[`get${_capitalize(field.name)}`] = () => model[field.name];
        }
      } else {
        publicAPI[`get${_capitalize(field)}`] = () => model[field];
      }
    });
  }
  var objectSetterMap = {
    enum(publicAPI, model, field) {
      const onChanged = `_on${_capitalize(field.name)}Changed`;
      return (value) => {
        if (typeof value === "string") {
          if (field.enum[value] !== void 0) {
            if (model[field.name] !== field.enum[value]) {
              model[field.name] = field.enum[value];
              publicAPI.modified();
              return true;
            }
            return false;
          }
          vtkErrorMacro2(`Set Enum with invalid argument ${field}, ${value}`);
          throw new RangeError("Set Enum with invalid string argument");
        }
        if (typeof value === "number") {
          if (model[field.name] !== value) {
            if (Object.keys(field.enum).map((key) => field.enum[key]).indexOf(value) !== -1) {
              const previousValue = model[field.name];
              model[field.name] = value;
              model[onChanged]?.(publicAPI, model, value, previousValue);
              publicAPI.modified();
              return true;
            }
            vtkErrorMacro2(`Set Enum outside numeric range ${field}, ${value}`);
            throw new RangeError("Set Enum outside numeric range");
          }
          return false;
        }
        vtkErrorMacro2(`Set Enum with invalid argument (String/Number) ${field}, ${value}`);
        throw new TypeError("Set Enum with invalid argument (String/Number)");
      };
    },
    object(publicAPI, model, field) {
      if (field.params?.length === 1) {
        vtkWarningMacro('Setter of type "object" with a single "param" field is not supported');
      }
      const onChanged = `_on${_capitalize(field.name)}Changed`;
      return function() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        let value;
        if (args.length > 1 && field.params?.length) {
          value = field.params.reduce((acc, prop, idx) => Object.assign(acc, {
            [prop]: args[idx]
          }), {});
        } else {
          value = args[0];
        }
        if (!(0, import_fast_deep_equal.default)(model[field.name], value)) {
          const previousValue = model[field.name];
          model[field.name] = value;
          model[onChanged]?.(publicAPI, model, value, previousValue);
          publicAPI.modified();
          return true;
        }
        return false;
      };
    }
  };
  function findSetter(field) {
    if (typeof field === "object") {
      const fn = objectSetterMap[field.type];
      if (fn) {
        return (publicAPI, model) => fn(publicAPI, model, field);
      }
      vtkErrorMacro2(`No setter for field ${field}`);
      throw new TypeError("No setter for field");
    }
    return function getSetter(publicAPI, model) {
      const onChanged = `_on${_capitalize(field)}Changed`;
      return function setter(value) {
        if (model.deleted) {
          vtkErrorMacro2("instance deleted - cannot call any method");
          return false;
        }
        if (model[field] !== value) {
          const previousValue = model[field.name];
          model[field] = value;
          model[onChanged]?.(publicAPI, model, value, previousValue);
          publicAPI.modified();
          return true;
        }
        return false;
      };
    };
  }
  function set(publicAPI, model, fields) {
    fields.forEach((field) => {
      if (typeof field === "object") {
        publicAPI[`set${_capitalize(field.name)}`] = findSetter(field)(publicAPI, model);
      } else {
        publicAPI[`set${_capitalize(field)}`] = findSetter(field)(publicAPI, model);
      }
    });
  }
  function setGet(publicAPI, model, fieldNames) {
    get(publicAPI, model, fieldNames);
    set(publicAPI, model, fieldNames);
  }
  function getArray(publicAPI, model, fieldNames) {
    fieldNames.forEach((field) => {
      publicAPI[`get${_capitalize(field)}`] = () => model[field] ? Array.from(model[field]) : model[field];
      publicAPI[`get${_capitalize(field)}ByReference`] = () => model[field];
    });
  }
  function setArray(publicAPI, model, fieldNames, size) {
    let defaultVal = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
    fieldNames.forEach((field) => {
      if (model[field] && size && model[field].length !== size) {
        throw new RangeError(`Invalid initial number of values for array (${field})`);
      }
      const onChanged = `_on${_capitalize(field)}Changed`;
      publicAPI[`set${_capitalize(field)}`] = function() {
        if (model.deleted) {
          vtkErrorMacro2("instance deleted - cannot call any method");
          return false;
        }
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        let array = args;
        let changeDetected;
        let needCopy = false;
        if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {
          array = array[0];
          needCopy = true;
        }
        if (array == null) {
          changeDetected = model[field] !== array;
        } else {
          if (size && array.length !== size) {
            if (array.length < size && defaultVal !== void 0) {
              array = Array.from(array);
              needCopy = false;
              while (array.length < size) array.push(defaultVal);
            } else {
              throw new RangeError(`Invalid number of values for array setter (${field})`);
            }
          }
          changeDetected = model[field] == null || model[field].length !== array.length;
          for (let i = 0; !changeDetected && i < array.length; ++i) {
            changeDetected = model[field][i] !== array[i];
          }
          if (changeDetected && needCopy) {
            array = Array.from(array);
          }
        }
        if (changeDetected) {
          const previousValue = model[field.name];
          model[field] = array;
          model[onChanged]?.(publicAPI, model, array, previousValue);
          publicAPI.modified();
        }
        return changeDetected;
      };
      publicAPI[`set${_capitalize(field)}From`] = (otherArray) => {
        const target = model[field];
        otherArray.forEach((v, i) => {
          target[i] = v;
        });
      };
    });
  }
  function setGetArray(publicAPI, model, fieldNames, size) {
    let defaultVal = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
    getArray(publicAPI, model, fieldNames);
    setArray(publicAPI, model, fieldNames, size, defaultVal);
  }
  function moveToProtected(publicAPI, model, fieldNames) {
    for (let i = 0; i < fieldNames.length; i++) {
      const fieldName = fieldNames[i];
      if (model[fieldName] !== void 0) {
        model[`_${fieldName}`] = model[fieldName];
        delete model[fieldName];
      }
    }
  }
  function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
    if (model.inputData) {
      model.inputData = model.inputData.map(vtk);
    } else {
      model.inputData = [];
    }
    if (model.inputConnection) {
      model.inputConnection = model.inputConnection.map(vtk);
    } else {
      model.inputConnection = [];
    }
    if (model.output) {
      model.output = model.output.map(vtk);
    } else {
      model.output = [];
    }
    if (model.inputArrayToProcess) {
      model.inputArrayToProcess = model.inputArrayToProcess.map(vtk);
    } else {
      model.inputArrayToProcess = [];
    }
    model.numberOfInputs = numberOfInputs;
    function setInputData(dataset) {
      let port = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return;
      }
      if (port >= model.numberOfInputs) {
        vtkErrorMacro2(`algorithm ${publicAPI.getClassName()} only has ${model.numberOfInputs} input ports. To add more input ports, use addInputData()`);
        return;
      }
      if (model.inputData[port] !== dataset || model.inputConnection[port]) {
        model.inputData[port] = dataset;
        model.inputConnection[port] = null;
        if (publicAPI.modified) {
          publicAPI.modified();
        }
      }
    }
    function getInputData() {
      let port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      if (model.inputConnection[port]) {
        model.inputData[port] = model.inputConnection[port]();
      }
      return model.inputData[port];
    }
    function setInputConnection(outputPort) {
      let port = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return;
      }
      if (port >= model.numberOfInputs) {
        let msg = `algorithm ${publicAPI.getClassName()} only has `;
        msg += `${model.numberOfInputs}`;
        msg += " input ports. To add more input ports, use addInputConnection()";
        vtkErrorMacro2(msg);
        return;
      }
      model.inputData[port] = null;
      model.inputConnection[port] = outputPort;
    }
    function getInputConnection() {
      let port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return model.inputConnection[port];
    }
    function getPortToFill() {
      let portToFill = model.numberOfInputs;
      while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {
        portToFill--;
      }
      if (portToFill === model.numberOfInputs) {
        model.numberOfInputs++;
      }
      return portToFill;
    }
    function addInputConnection(outputPort) {
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return;
      }
      setInputConnection(outputPort, getPortToFill());
    }
    function addInputData(dataset) {
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return;
      }
      setInputData(dataset, getPortToFill());
    }
    function getOutputData() {
      let port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return null;
      }
      if (publicAPI.shouldUpdate()) {
        publicAPI.update();
      }
      return model.output[port];
    }
    publicAPI.shouldUpdate = () => {
      const localMTime = publicAPI.getMTime();
      let minOutputMTime = Infinity;
      let count = numberOfOutputs;
      while (count--) {
        if (!model.output[count] || model.output[count].isDeleted()) {
          return true;
        }
        const mt = model.output[count].getMTime();
        if (mt < localMTime) {
          return true;
        }
        if (mt < minOutputMTime) {
          minOutputMTime = mt;
        }
      }
      count = model.numberOfInputs;
      while (count--) {
        if (model.inputConnection[count]?.filter.shouldUpdate() || publicAPI.getInputData(count)?.getMTime() > minOutputMTime) {
          return true;
        }
      }
      return false;
    };
    function getOutputPort() {
      let port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      const outputPortAccess = () => getOutputData(port);
      outputPortAccess.filter = publicAPI;
      return outputPortAccess;
    }
    if (model.numberOfInputs) {
      let count = model.numberOfInputs;
      while (count--) {
        model.inputData.push(null);
        model.inputConnection.push(null);
      }
      publicAPI.setInputData = setInputData;
      publicAPI.setInputConnection = setInputConnection;
      publicAPI.addInputData = addInputData;
      publicAPI.addInputConnection = addInputConnection;
      publicAPI.getInputData = getInputData;
      publicAPI.getInputConnection = getInputConnection;
    }
    if (numberOfOutputs) {
      publicAPI.getOutputData = getOutputData;
      publicAPI.getOutputPort = getOutputPort;
    }
    publicAPI.update = () => {
      const ins = [];
      if (model.numberOfInputs) {
        let count = 0;
        while (count < model.numberOfInputs) {
          ins[count] = publicAPI.getInputData(count);
          count++;
        }
      }
      if (publicAPI.requestData && !publicAPI.isDeleted() && publicAPI.shouldUpdate()) {
        publicAPI.requestData(ins, model.output);
      }
    };
    publicAPI.getNumberOfInputPorts = () => model.numberOfInputs;
    publicAPI.getNumberOfOutputPorts = () => numberOfOutputs || model.output.length;
    publicAPI.getInputArrayToProcess = (inputPort) => {
      const arrayDesc = model.inputArrayToProcess[inputPort];
      const ds = model.inputData[inputPort];
      if (arrayDesc && ds) {
        return ds[`get${arrayDesc.fieldAssociation}`]().getArray(arrayDesc.arrayName);
      }
      return null;
    };
    publicAPI.setInputArrayToProcess = function(inputPort, arrayName, fieldAssociation) {
      let attributeType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "Scalars";
      while (model.inputArrayToProcess.length < inputPort) {
        model.inputArrayToProcess.push(null);
      }
      model.inputArrayToProcess[inputPort] = {
        arrayName,
        fieldAssociation,
        attributeType
      };
    };
  }
  var EVENT_ABORT = Symbol("Event abort");
  function event(publicAPI, model, eventName) {
    const callbacks = [];
    const previousDelete = publicAPI.delete;
    let curCallbackID = 1;
    function off(callbackID) {
      for (let i = 0; i < callbacks.length; ++i) {
        const [cbID] = callbacks[i];
        if (cbID === callbackID) {
          callbacks.splice(i, 1);
          return;
        }
      }
    }
    function on(callbackID) {
      function unsubscribe() {
        off(callbackID);
      }
      return Object.freeze({
        unsubscribe
      });
    }
    function invoke() {
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return;
      }
      const currentCallbacks = callbacks.slice();
      for (let index = 0; index < currentCallbacks.length; ++index) {
        const [, cb, priority] = currentCallbacks[index];
        if (!cb) {
          continue;
        }
        if (priority < 0) {
          setTimeout(() => cb.apply(publicAPI, arguments), 1 - priority);
        } else {
          const continueNext = cb.apply(publicAPI, arguments);
          if (continueNext === EVENT_ABORT) {
            break;
          }
        }
      }
    }
    publicAPI[`invoke${_capitalize(eventName)}`] = invoke;
    publicAPI[`on${_capitalize(eventName)}`] = function(callback) {
      let priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (!callback.apply) {
        console.error(`Invalid callback for event ${eventName}`);
        return null;
      }
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return null;
      }
      const callbackID = curCallbackID++;
      callbacks.push([callbackID, callback, priority]);
      callbacks.sort((cb1, cb2) => cb2[2] - cb1[2]);
      return on(callbackID);
    };
    publicAPI.delete = () => {
      previousDelete();
      callbacks.forEach((_ref) => {
        let [cbID] = _ref;
        return off(cbID);
      });
    };
  }
  function newInstance(extend122, className) {
    const constructor = function() {
      let initialValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const model = {};
      const publicAPI = {};
      extend122(publicAPI, model, initialValues);
      return Object.freeze(publicAPI);
    };
    if (className) {
      vtk.register(className, constructor);
    }
    return constructor;
  }
  function chain() {
    for (var _len6 = arguments.length, fn = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      fn[_key6] = arguments[_key6];
    }
    return function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return fn.filter((i) => !!i).map((i) => i(...args));
    };
  }
  function isVtkObject(instance) {
    return instance && instance.isA && instance.isA("vtkObject");
  }
  function traverseInstanceTree(instance, extractFunction) {
    let accumulator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    let visitedInstances = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
    if (isVtkObject(instance)) {
      if (visitedInstances.indexOf(instance) >= 0) {
        return accumulator;
      }
      visitedInstances.push(instance);
      const result = extractFunction(instance);
      if (result !== void 0) {
        accumulator.push(result);
      }
      const model = instance.get();
      Object.keys(model).forEach((key) => {
        const modelObj = model[key];
        if (Array.isArray(modelObj)) {
          modelObj.forEach((subObj) => {
            traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);
          });
        } else {
          traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);
        }
      });
    }
    return accumulator;
  }
  function debounce(func, wait, immediate) {
    var _this = this;
    let timeout;
    const debounced = function() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      const context = _this;
      const later = () => {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
    debounced.cancel = () => clearTimeout(timeout);
    return debounced;
  }
  function throttle(callback, delay) {
    let isThrottled = false;
    let argsToUse = null;
    function next() {
      isThrottled = false;
      if (argsToUse !== null) {
        wrapper(...argsToUse);
        argsToUse = null;
      }
    }
    function wrapper() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      if (isThrottled) {
        argsToUse = args;
        return;
      }
      isThrottled = true;
      callback(...args);
      setTimeout(next, delay);
    }
    return wrapper;
  }
  function keystore(publicAPI, model) {
    let initialKeystore = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    model.keystore = Object.assign(model.keystore || {}, initialKeystore);
    publicAPI.setKey = (key, value) => {
      model.keystore[key] = value;
    };
    publicAPI.getKey = (key) => model.keystore[key];
    publicAPI.getAllKeys = () => Object.keys(model.keystore);
    publicAPI.deleteKey = (key) => delete model.keystore[key];
    publicAPI.clearKeystore = () => publicAPI.getAllKeys().forEach((key) => delete model.keystore[key]);
  }
  var nextProxyId = 1;
  var ROOT_GROUP_NAME = "__root__";
  function proxy(publicAPI, model) {
    keystore(publicAPI, model);
    const parentDelete = publicAPI.delete;
    model.proxyId = `${nextProxyId++}`;
    model.ui = JSON.parse(JSON.stringify(model.ui || []));
    get(publicAPI, model, ["proxyId", "proxyGroup", "proxyName"]);
    setGet(publicAPI, model, ["proxyManager"]);
    const propertyMap = {};
    const groupChildrenNames = {};
    function registerProperties(descriptionList, currentGroupName) {
      if (!groupChildrenNames[currentGroupName]) {
        groupChildrenNames[currentGroupName] = [];
      }
      const childrenNames = groupChildrenNames[currentGroupName];
      for (let i = 0; i < descriptionList.length; i++) {
        childrenNames.push(descriptionList[i].name);
        propertyMap[descriptionList[i].name] = descriptionList[i];
        if (descriptionList[i].children && descriptionList[i].children.length) {
          registerProperties(descriptionList[i].children, descriptionList[i].name);
        }
      }
    }
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.updateUI = (ui) => {
      model.ui = JSON.parse(JSON.stringify(ui || []));
      Object.keys(propertyMap).forEach((k) => delete propertyMap[k]);
      Object.keys(groupChildrenNames).forEach((k) => delete groupChildrenNames[k]);
      registerProperties(model.ui, ROOT_GROUP_NAME);
      publicAPI.modified();
    };
    function listProxyProperties() {
      let gName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ROOT_GROUP_NAME;
      return groupChildrenNames[gName];
    }
    publicAPI.updateProxyProperty = (propertyName, propUI) => {
      const prop = propertyMap[propertyName];
      if (prop) {
        Object.assign(prop, propUI);
      } else {
        propertyMap[propertyName] = {
          ...propUI
        };
      }
    };
    publicAPI.activate = () => {
      if (model.proxyManager) {
        const setActiveMethod = `setActive${_capitalize(publicAPI.getProxyGroup().slice(0, -1))}`;
        if (model.proxyManager[setActiveMethod]) {
          model.proxyManager[setActiveMethod](publicAPI);
        }
      }
    };
    model.propertyLinkSubscribers = {};
    publicAPI.registerPropertyLinkForGC = (otherLink, type) => {
      if (!(type in model.propertyLinkSubscribers)) {
        model.propertyLinkSubscribers[type] = [];
      }
      model.propertyLinkSubscribers[type].push(otherLink);
    };
    publicAPI.gcPropertyLinks = (type) => {
      const subscribers = model.propertyLinkSubscribers[type] || [];
      while (subscribers.length) {
        subscribers.pop().unbind(publicAPI);
      }
    };
    model.propertyLinkMap = {};
    publicAPI.getPropertyLink = function(id) {
      let persistent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (model.propertyLinkMap[id]) {
        return model.propertyLinkMap[id];
      }
      let value = null;
      const links = [];
      let count = 0;
      let updateInProgress = false;
      function update(source) {
        let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (updateInProgress) {
          return null;
        }
        const needUpdate = [];
        let sourceLink = null;
        count = links.length;
        while (count--) {
          const link = links[count];
          if (link.instance === source) {
            sourceLink = link;
          } else {
            needUpdate.push(link);
          }
        }
        if (!sourceLink) {
          return null;
        }
        const newValue = sourceLink.instance[`get${_capitalize(sourceLink.propertyName)}`]();
        if (!shallowEquals(newValue, value) || force) {
          value = newValue;
          updateInProgress = true;
          while (needUpdate.length) {
            const linkToUpdate = needUpdate.pop();
            linkToUpdate.instance.set({
              [linkToUpdate.propertyName]: value
            });
          }
          updateInProgress = false;
        }
        if (model.propertyLinkMap[id].persistent) {
          model.propertyLinkMap[id].value = newValue;
        }
        return newValue;
      }
      function unbind(instance, propertyName) {
        const indexToDelete = [];
        count = links.length;
        while (count--) {
          const link = links[count];
          if (link.instance === instance && (link.propertyName === propertyName || propertyName === void 0)) {
            link.subscription.unsubscribe();
            indexToDelete.push(count);
          }
        }
        while (indexToDelete.length) {
          links.splice(indexToDelete.pop(), 1);
        }
      }
      function bind(instance, propertyName) {
        let updateMe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const subscription = instance.onModified(update);
        const other = links[0];
        links.push({
          instance,
          propertyName,
          subscription
        });
        if (updateMe) {
          if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== void 0) {
            instance.set({
              [propertyName]: model.propertyLinkMap[id].value
            });
          } else if (other) {
            update(other.instance, true);
          }
        }
        return {
          unsubscribe: () => unbind(instance, propertyName)
        };
      }
      function unsubscribe() {
        while (links.length) {
          links.pop().subscription.unsubscribe();
        }
      }
      const linkHandler = {
        bind,
        unbind,
        unsubscribe,
        persistent
      };
      model.propertyLinkMap[id] = linkHandler;
      return linkHandler;
    };
    function getProperties() {
      let groupName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ROOT_GROUP_NAME;
      const values = [];
      const id = model.proxyId;
      const propertyNames = listProxyProperties(groupName) || [];
      for (let i = 0; i < propertyNames.length; i++) {
        const name = propertyNames[i];
        const method = publicAPI[`get${_capitalize(name)}`];
        const value = method ? method() : void 0;
        const prop = {
          id,
          name,
          value
        };
        const children = getProperties(name);
        if (children.length) {
          prop.children = children;
        }
        values.push(prop);
      }
      return values;
    }
    publicAPI.listPropertyNames = () => getProperties().map((p) => p.name);
    publicAPI.getPropertyByName = (name) => getProperties().find((p) => p.name === name);
    publicAPI.getPropertyDomainByName = (name) => (propertyMap[name] || {}).domain;
    publicAPI.getProxySection = () => ({
      id: model.proxyId,
      name: model.proxyGroup,
      ui: model.ui,
      properties: getProperties()
    });
    publicAPI.delete = () => {
      const list = Object.keys(model.propertyLinkMap);
      let count = list.length;
      while (count--) {
        model.propertyLinkMap[list[count]].unsubscribe();
      }
      Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);
      parentDelete();
    };
    publicAPI.getState = () => null;
    function registerLinks() {
      if (model.links) {
        for (let i = 0; i < model.links.length; i++) {
          const {
            link,
            property,
            persistent,
            updateOnBind,
            type
          } = model.links[i];
          if (type === "application") {
            const sLink = model.proxyManager.getPropertyLink(link, persistent);
            publicAPI.registerPropertyLinkForGC(sLink, "application");
            sLink.bind(publicAPI, property, updateOnBind);
          }
        }
      }
    }
    setImmediateVTK(registerLinks);
  }
  function proxyPropertyMapping(publicAPI, model, map2) {
    const parentDelete = publicAPI.delete;
    const subscriptions = [];
    const propertyNames = Object.keys(map2);
    let count = propertyNames.length;
    while (count--) {
      const propertyName = propertyNames[count];
      const {
        modelKey,
        property,
        modified = true
      } = map2[propertyName];
      const methodSrc = _capitalize(property);
      const methodDst = _capitalize(propertyName);
      publicAPI[`get${methodDst}`] = model[modelKey][`get${methodSrc}`];
      publicAPI[`set${methodDst}`] = model[modelKey][`set${methodSrc}`];
      if (modified) {
        subscriptions.push(model[modelKey].onModified(publicAPI.modified));
      }
    }
    publicAPI.delete = () => {
      while (subscriptions.length) {
        subscriptions.pop().unsubscribe();
      }
      parentDelete();
    };
  }
  function proxyPropertyState(publicAPI, model) {
    let state2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let defaults = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    model.this = publicAPI;
    function applyState(map2) {
      const modelKeys2 = Object.keys(map2);
      let count2 = modelKeys2.length;
      while (count2--) {
        const modelKey = modelKeys2[count2];
        model[modelKey].set(map2[modelKey]);
      }
    }
    const modelKeys = Object.keys(defaults);
    let count = modelKeys.length;
    while (count--) {
      const key = modelKeys[count];
      model[key] = defaults[key];
      const mapping = state2[key];
      publicAPI[`set${_capitalize(key)}`] = (value) => {
        if (value !== model[key]) {
          model[key] = value;
          const propValues = mapping[value];
          applyState(propValues);
          publicAPI.modified();
        }
      };
    }
    if (modelKeys.length) {
      get(publicAPI, model, modelKeys);
    }
  }
  var PIXEL_STEP = 10;
  var LINE_HEIGHT = 40;
  var PAGE_HEIGHT = 800;
  function normalizeWheel(wheelEvent) {
    let sX = 0;
    let sY = 0;
    let pX = 0;
    let pY = 0;
    if ("detail" in wheelEvent) {
      sY = wheelEvent.detail;
    }
    if ("wheelDelta" in wheelEvent) {
      sY = -wheelEvent.wheelDelta / 120;
    }
    if ("wheelDeltaY" in wheelEvent) {
      sY = -wheelEvent.wheelDeltaY / 120;
    }
    if ("wheelDeltaX" in wheelEvent) {
      sX = -wheelEvent.wheelDeltaX / 120;
    }
    if ("axis" in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ("deltaY" in wheelEvent) {
      pY = wheelEvent.deltaY;
    }
    if ("deltaX" in wheelEvent) {
      pX = wheelEvent.deltaX;
    }
    if ((pX || pY) && wheelEvent.deltaMode) {
      if (wheelEvent.deltaMode === 1) {
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY || sX,
      pixelX: pX,
      pixelY: pY || pX
    };
  }
  var macro = {
    algo,
    capitalize,
    chain,
    debounce,
    enumToString,
    event,
    EVENT_ABORT,
    formatBytesToProperUnit,
    formatNumbersWithThousandSeparator,
    get,
    getArray,
    getCurrentGlobalMTime,
    getStateArrayMapFunc,
    isVtkObject,
    keystore,
    measurePromiseExecution,
    moveToProtected,
    newInstance,
    newTypedArray,
    newTypedArrayFrom,
    normalizeWheel,
    obj,
    proxy,
    proxyPropertyMapping,
    proxyPropertyState,
    safeArrays,
    set,
    setArray,
    setGet,
    setGetArray,
    setImmediate: setImmediateVTK,
    setLoggerFunction,
    throttle,
    traverseInstanceTree,
    TYPED_ARRAYS,
    // deprecated todo remove on breaking API revision
    uncapitalize,
    VOID,
    vtkDebugMacro,
    vtkErrorMacro: vtkErrorMacro2,
    vtkInfoMacro,
    vtkLogMacro,
    vtkOnceErrorMacro,
    vtkWarningMacro,
    // vtk.js internal use
    objectSetterMap,
    requiredParam
  };
  var macro$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    requiredParam,
    VOID,
    setLoggerFunction,
    vtkLogMacro,
    vtkInfoMacro,
    vtkDebugMacro,
    vtkErrorMacro: vtkErrorMacro2,
    vtkWarningMacro,
    vtkOnceErrorMacro,
    TYPED_ARRAYS,
    newTypedArray,
    newTypedArrayFrom,
    capitalize,
    _capitalize,
    uncapitalize,
    formatBytesToProperUnit,
    formatNumbersWithThousandSeparator,
    setImmediateVTK,
    measurePromiseExecution,
    obj,
    get,
    set,
    setGet,
    getArray,
    setArray,
    setGetArray,
    moveToProtected,
    algo,
    EVENT_ABORT,
    event,
    newInstance,
    chain,
    isVtkObject,
    traverseInstanceTree,
    debounce,
    throttle,
    keystore,
    proxy,
    proxyPropertyMapping,
    proxyPropertyState,
    normalizeWheel,
    "default": macro
  });

  // node_modules/gl-matrix/esm/common.js
  var common_exports = {};
  __export(common_exports, {
    ARRAY_TYPE: () => ARRAY_TYPE,
    EPSILON: () => EPSILON,
    RANDOM: () => RANDOM,
    equals: () => equals,
    setMatrixArrayType: () => setMatrixArrayType,
    toRadian: () => toRadian
  });
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var RANDOM = Math.random;
  function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
  }
  var degree = Math.PI / 180;
  function toRadian(a) {
    return a * degree;
  }
  function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
  }
  if (!Math.hypot) Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

  // node_modules/gl-matrix/esm/mat3.js
  var mat3_exports = {};
  __export(mat3_exports, {
    add: () => add,
    adjoint: () => adjoint,
    clone: () => clone,
    copy: () => copy,
    create: () => create,
    determinant: () => determinant,
    equals: () => equals2,
    exactEquals: () => exactEquals,
    frob: () => frob,
    fromMat2d: () => fromMat2d,
    fromMat4: () => fromMat4,
    fromQuat: () => fromQuat,
    fromRotation: () => fromRotation,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues,
    identity: () => identity,
    invert: () => invert,
    mul: () => mul,
    multiply: () => multiply,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    normalFromMat4: () => normalFromMat4,
    projection: () => projection,
    rotate: () => rotate,
    scale: () => scale,
    set: () => set2,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    translate: () => translate,
    transpose: () => transpose
  });
  function create() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  function clone(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function set2(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }
    return out;
  }
  function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  function normalFromMat4(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  function str(a) {
    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
  }
  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  function multiplyScalarAndAdd(out, a, b, scale7) {
    out[0] = a[0] + b[0] * scale7;
    out[1] = a[1] + b[1] * scale7;
    out[2] = a[2] + b[2] * scale7;
    out[3] = a[3] + b[3] * scale7;
    out[4] = a[4] + b[4] * scale7;
    out[5] = a[5] + b[5] * scale7;
    out[6] = a[6] + b[6] * scale7;
    out[7] = a[7] + b[7] * scale7;
    out[8] = a[8] + b[8] * scale7;
    return out;
  }
  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  function equals2(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
  }
  var mul = multiply;
  var sub = subtract;

  // node_modules/gl-matrix/esm/mat4.js
  var mat4_exports = {};
  __export(mat4_exports, {
    add: () => add2,
    adjoint: () => adjoint2,
    clone: () => clone2,
    copy: () => copy2,
    create: () => create2,
    determinant: () => determinant2,
    equals: () => equals3,
    exactEquals: () => exactEquals2,
    frob: () => frob2,
    fromQuat: () => fromQuat3,
    fromQuat2: () => fromQuat2,
    fromRotation: () => fromRotation2,
    fromRotationTranslation: () => fromRotationTranslation,
    fromRotationTranslationScale: () => fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
    fromScaling: () => fromScaling2,
    fromTranslation: () => fromTranslation2,
    fromValues: () => fromValues2,
    fromXRotation: () => fromXRotation,
    fromYRotation: () => fromYRotation,
    fromZRotation: () => fromZRotation,
    frustum: () => frustum,
    getRotation: () => getRotation,
    getScaling: () => getScaling,
    getTranslation: () => getTranslation,
    identity: () => identity2,
    invert: () => invert2,
    lookAt: () => lookAt,
    mul: () => mul2,
    multiply: () => multiply2,
    multiplyScalar: () => multiplyScalar2,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
    ortho: () => ortho,
    orthoNO: () => orthoNO,
    orthoZO: () => orthoZO,
    perspective: () => perspective,
    perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
    perspectiveNO: () => perspectiveNO,
    perspectiveZO: () => perspectiveZO,
    rotate: () => rotate2,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    scale: () => scale2,
    set: () => set3,
    str: () => str2,
    sub: () => sub2,
    subtract: () => subtract2,
    targetTo: () => targetTo,
    translate: () => translate2,
    transpose: () => transpose2
  });
  function create2() {
    var out = new ARRAY_TYPE(16);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function clone2(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function copy2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function set3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a03 = a[3];
      var a12 = a[6], a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  function invert2(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function adjoint2(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  function determinant2(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply2(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function scale2(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function rotate2(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len4 = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len4 < EPSILON) {
      return null;
    }
    len4 = 1 / len4;
    x *= len4;
    y *= len4;
    z *= len4;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function fromTranslation2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromScaling2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation2(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len4 = Math.hypot(x, y, z);
    var s, c, t;
    if (len4 < EPSILON) {
      return null;
    }
    len4 = 1 / len4;
    x *= len4;
    y *= len4;
    z *= len4;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotationTranslation(out, q, v) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a, translation);
    return out;
  }
  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;
    if (trace > 0) {
      S = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }
    return out;
  }
  function fromRotationTranslationScale(out, q, v, s) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  function fromQuat3(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function perspectiveZO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function orthoZO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len4;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity2(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len4 = 1 / Math.hypot(z0, z1, z2);
    z0 *= len4;
    z1 *= len4;
    z2 *= len4;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len4 = Math.hypot(x0, x1, x2);
    if (!len4) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len4 = 1 / len4;
      x0 *= len4;
      x1 *= len4;
      x2 *= len4;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len4 = Math.hypot(y0, y1, y2);
    if (!len4) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len4 = 1 / len4;
      y0 *= len4;
      y1 *= len4;
      y2 *= len4;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function targetTo(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len4 = z0 * z0 + z1 * z1 + z2 * z2;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
      z0 *= len4;
      z1 *= len4;
      z2 *= len4;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len4 = x0 * x0 + x1 * x1 + x2 * x2;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
      x0 *= len4;
      x1 *= len4;
      x2 *= len4;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  function str2(a) {
    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
  }
  function frob2(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
  }
  function add2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  function subtract2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  function multiplyScalar2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  function multiplyScalarAndAdd2(out, a, b, scale7) {
    out[0] = a[0] + b[0] * scale7;
    out[1] = a[1] + b[1] * scale7;
    out[2] = a[2] + b[2] * scale7;
    out[3] = a[3] + b[3] * scale7;
    out[4] = a[4] + b[4] * scale7;
    out[5] = a[5] + b[5] * scale7;
    out[6] = a[6] + b[6] * scale7;
    out[7] = a[7] + b[7] * scale7;
    out[8] = a[8] + b[8] * scale7;
    out[9] = a[9] + b[9] * scale7;
    out[10] = a[10] + b[10] * scale7;
    out[11] = a[11] + b[11] * scale7;
    out[12] = a[12] + b[12] * scale7;
    out[13] = a[13] + b[13] * scale7;
    out[14] = a[14] + b[14] * scale7;
    out[15] = a[15] + b[15] * scale7;
    return out;
  }
  function exactEquals2(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  function equals3(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  var mul2 = multiply2;
  var sub2 = subtract2;

  // node_modules/gl-matrix/esm/quat.js
  var quat_exports = {};
  __export(quat_exports, {
    add: () => add5,
    calculateW: () => calculateW,
    clone: () => clone5,
    conjugate: () => conjugate,
    copy: () => copy5,
    create: () => create5,
    dot: () => dot3,
    equals: () => equals6,
    exactEquals: () => exactEquals5,
    exp: () => exp,
    fromEuler: () => fromEuler,
    fromMat3: () => fromMat3,
    fromValues: () => fromValues5,
    getAngle: () => getAngle,
    getAxisAngle: () => getAxisAngle,
    identity: () => identity3,
    invert: () => invert3,
    len: () => len3,
    length: () => length3,
    lerp: () => lerp3,
    ln: () => ln,
    mul: () => mul5,
    multiply: () => multiply5,
    normalize: () => normalize3,
    pow: () => pow,
    random: () => random3,
    rotateX: () => rotateX3,
    rotateY: () => rotateY3,
    rotateZ: () => rotateZ3,
    rotationTo: () => rotationTo,
    scale: () => scale5,
    set: () => set6,
    setAxes: () => setAxes,
    setAxisAngle: () => setAxisAngle,
    slerp: () => slerp,
    sqlerp: () => sqlerp,
    sqrLen: () => sqrLen3,
    squaredLength: () => squaredLength3,
    str: () => str5
  });

  // node_modules/gl-matrix/esm/vec3.js
  var vec3_exports = {};
  __export(vec3_exports, {
    add: () => add3,
    angle: () => angle,
    bezier: () => bezier,
    ceil: () => ceil,
    clone: () => clone3,
    copy: () => copy3,
    create: () => create3,
    cross: () => cross,
    dist: () => dist,
    distance: () => distance,
    div: () => div,
    divide: () => divide,
    dot: () => dot,
    equals: () => equals4,
    exactEquals: () => exactEquals3,
    floor: () => floor,
    forEach: () => forEach,
    fromValues: () => fromValues3,
    hermite: () => hermite,
    inverse: () => inverse,
    len: () => len,
    length: () => length,
    lerp: () => lerp,
    max: () => max,
    min: () => min,
    mul: () => mul3,
    multiply: () => multiply3,
    negate: () => negate,
    normalize: () => normalize,
    random: () => random,
    rotateX: () => rotateX2,
    rotateY: () => rotateY2,
    rotateZ: () => rotateZ2,
    round: () => round,
    scale: () => scale3,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set4,
    sqrDist: () => sqrDist,
    sqrLen: () => sqrLen,
    squaredDistance: () => squaredDistance,
    squaredLength: () => squaredLength,
    str: () => str3,
    sub: () => sub3,
    subtract: () => subtract3,
    transformMat3: () => transformMat3,
    transformMat4: () => transformMat4,
    transformQuat: () => transformQuat,
    zero: () => zero
  });
  function create3() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone3(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  function fromValues3(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function copy3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function set4(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function add3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiply3(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  function scale3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  function scaleAndAdd(out, a, b, scale7) {
    out[0] = a[0] + b[0] * scale7;
    out[1] = a[1] + b[1] * scale7;
    out[2] = a[2] + b[2] * scale7;
    return out;
  }
  function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
  }
  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len4 = x * x + y * y + z * z;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
    }
    out[0] = a[0] * len4;
    out[1] = a[1] * len4;
    out[2] = a[2] * len4;
    return out;
  }
  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function random(out, scale7) {
    scale7 = scale7 || 1;
    var r = RANDOM() * 2 * Math.PI;
    var z = RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale7;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale7;
    return out;
  }
  function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX2(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0];
    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY2(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ2(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
    r[2] = p[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str3(a) {
    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
  }
  function exactEquals3(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  function equals4(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
  }
  var sub3 = subtract3;
  var mul3 = multiply3;
  var div = divide;
  var dist = distance;
  var sqrDist = squaredDistance;
  var len = length;
  var sqrLen = squaredLength;
  var forEach = (function() {
    var vec = create3();
    return function(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  })();

  // node_modules/gl-matrix/esm/vec4.js
  var vec4_exports = {};
  __export(vec4_exports, {
    add: () => add4,
    ceil: () => ceil2,
    clone: () => clone4,
    copy: () => copy4,
    create: () => create4,
    cross: () => cross2,
    dist: () => dist2,
    distance: () => distance2,
    div: () => div2,
    divide: () => divide2,
    dot: () => dot2,
    equals: () => equals5,
    exactEquals: () => exactEquals4,
    floor: () => floor2,
    forEach: () => forEach2,
    fromValues: () => fromValues4,
    inverse: () => inverse2,
    len: () => len2,
    length: () => length2,
    lerp: () => lerp2,
    max: () => max2,
    min: () => min2,
    mul: () => mul4,
    multiply: () => multiply4,
    negate: () => negate2,
    normalize: () => normalize2,
    random: () => random2,
    round: () => round2,
    scale: () => scale4,
    scaleAndAdd: () => scaleAndAdd2,
    set: () => set5,
    sqrDist: () => sqrDist2,
    sqrLen: () => sqrLen2,
    squaredDistance: () => squaredDistance2,
    squaredLength: () => squaredLength2,
    str: () => str4,
    sub: () => sub4,
    subtract: () => subtract4,
    transformMat4: () => transformMat42,
    transformQuat: () => transformQuat2,
    zero: () => zero2
  });
  function create4() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function clone4(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  function fromValues4(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function copy4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  function set5(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function add4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  function subtract4(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  function multiply4(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
  }
  function divide2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
  }
  function ceil2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
  }
  function floor2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
  }
  function min2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
  }
  function max2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
  }
  function round2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
  }
  function scale4(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  function scaleAndAdd2(out, a, b, scale7) {
    out[0] = a[0] + b[0] * scale7;
    out[1] = a[1] + b[1] * scale7;
    out[2] = a[2] + b[2] * scale7;
    out[3] = a[3] + b[3] * scale7;
    return out;
  }
  function distance2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
  }
  function squaredDistance2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
  }
  function length2(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
  }
  function squaredLength2(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
  }
  function negate2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
  }
  function inverse2(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    out[3] = 1 / a[3];
    return out;
  }
  function normalize2(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len4 = x * x + y * y + z * z + w * w;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
    }
    out[0] = x * len4;
    out[1] = y * len4;
    out[2] = z * len4;
    out[3] = w * len4;
    return out;
  }
  function dot2(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  function cross2(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
  }
  function lerp2(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  function random2(out, scale7) {
    scale7 = scale7 || 1;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);
    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s2 = v3 * v3 + v4 * v4;
    } while (s2 >= 1);
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale7 * v1;
    out[1] = scale7 * v2;
    out[2] = scale7 * v3 * d;
    out[3] = scale7 * v4 * d;
    return out;
  }
  function transformMat42(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  function transformQuat2(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  function zero2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
  }
  function str4(a) {
    return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
  }
  function exactEquals4(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  function equals5(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
  }
  var sub4 = subtract4;
  var mul4 = multiply4;
  var div2 = divide2;
  var dist2 = distance2;
  var sqrDist2 = squaredDistance2;
  var len2 = length2;
  var sqrLen2 = squaredLength2;
  var forEach2 = (function() {
    var vec = create4();
    return function(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }
      return a;
    };
  })();

  // node_modules/gl-matrix/esm/quat.js
  function create5() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity3(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2;
    var s = Math.sin(rad / 2);
    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }
    return rad;
  }
  function getAngle(a, b) {
    var dotproduct = dot3(a, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
  }
  function multiply5(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
    return out;
  }
  function exp(out, a) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var et = Math.exp(w);
    var s = r > 0 ? et * Math.sin(r) / r : 0;
    out[0] = x * s;
    out[1] = y * s;
    out[2] = z * s;
    out[3] = et * Math.cos(r);
    return out;
  }
  function ln(out, a) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var t = r > 0 ? Math.atan2(r, w) / r : 0;
    out[0] = x * t;
    out[1] = y * t;
    out[2] = z * t;
    out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
    return out;
  }
  function pow(out, a, b) {
    ln(out, a);
    scale5(out, out, b);
    exp(out, out);
    return out;
  }
  function slerp(out, a, b, t) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function random3(out) {
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
    return out;
  }
  function invert3(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var dot5 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot5 ? 1 / dot5 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  function fromMat3(out, m) {
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
  }
  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  function str5(a) {
    return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
  }
  var clone5 = clone4;
  var fromValues5 = fromValues4;
  var copy5 = copy4;
  var set6 = set5;
  var add5 = add4;
  var mul5 = multiply5;
  var scale5 = scale4;
  var dot3 = dot2;
  var lerp3 = lerp2;
  var length3 = length2;
  var len3 = length3;
  var squaredLength3 = squaredLength2;
  var sqrLen3 = squaredLength3;
  var normalize3 = normalize2;
  var exactEquals5 = exactEquals4;
  var equals6 = equals5;
  var rotationTo = (function() {
    var tmpvec3 = create3();
    var xUnitVec3 = fromValues3(1, 0, 0);
    var yUnitVec3 = fromValues3(0, 1, 0);
    return function(out, a, b) {
      var dot5 = dot(a, b);
      if (dot5 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot5 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot5;
        return normalize3(out, out);
      }
    };
  })();
  var sqlerp = (function() {
    var temp1 = create5();
    var temp2 = create5();
    return function(out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  })();
  var setAxes = (function() {
    var matr = create();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize3(out, fromMat3(out, matr));
    };
  })();

  // node_modules/@kitware/vtk.js/Common/Core/Math/index.js
  var import_seedrandom = __toESM(require_seedrandom2(), 1);

  // node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js
  var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  var IDENTITY_3X3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  var EPSILON2 = 1e-6;
  var VTK_SMALL_NUMBER = 1e-12;

  // node_modules/@kitware/vtk.js/Common/Core/Math/index.js
  var {
    vtkErrorMacro: vtkErrorMacro3,
    vtkWarningMacro: vtkWarningMacro2
  } = macro;
  var randomSeedValue = 0;
  var VTK_MAX_ROTATIONS = 20;
  function notImplemented(method) {
    return () => vtkErrorMacro3(`vtkMath::${method} - NOT IMPLEMENTED`);
  }
  function swapRowsMatrix_nxn(matrix, n, row1, row2) {
    let tmp;
    for (let i = 0; i < n; i++) {
      tmp = matrix[row1 * n + i];
      matrix[row1 * n + i] = matrix[row2 * n + i];
      matrix[row2 * n + i] = tmp;
    }
  }
  function swapColumnsMatrix_nxn(matrix, n, column1, column2) {
    let tmp;
    for (let i = 0; i < n; i++) {
      tmp = matrix[i * n + column1];
      matrix[i * n + column1] = matrix[i * n + column2];
      matrix[i * n + column2] = tmp;
    }
  }
  function createArray() {
    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
    const res = Array(size);
    for (let i = 0; i < size; ++i) {
      res[i] = 0;
    }
    return res;
  }
  var Pi = () => Math.PI;
  function ldexp(x, exponent) {
    if (exponent > 1023) {
      return x * 2 ** 1023 * 2 ** (exponent - 1023);
    }
    if (exponent < -1074) {
      return x * 2 ** -1074 * 2 ** (exponent + 1074);
    }
    return x * 2 ** exponent;
  }
  function radiansFromDegrees(deg) {
    return deg / 180 * Math.PI;
  }
  function degreesFromRadians(rad) {
    return rad * 180 / Math.PI;
  }
  var {
    round: round3,
    floor: floor3,
    ceil: ceil3,
    min: min3,
    max: max3
  } = Math;
  function arrayMin(arr) {
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    let minValue = Infinity;
    for (let i = offset, len4 = arr.length; i < len4; i += stride) {
      if (arr[i] < minValue) {
        minValue = arr[i];
      }
    }
    return minValue;
  }
  function arrayMax(arr) {
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    let maxValue = -Infinity;
    for (let i = offset, len4 = arr.length; i < len4; i += stride) {
      if (maxValue < arr[i]) {
        maxValue = arr[i];
      }
    }
    return maxValue;
  }
  function arrayRange(arr) {
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    let minValue = Infinity;
    let maxValue = -Infinity;
    for (let i = offset, len4 = arr.length; i < len4; i += stride) {
      if (arr[i] < minValue) {
        minValue = arr[i];
      }
      if (maxValue < arr[i]) {
        maxValue = arr[i];
      }
    }
    return [minValue, maxValue];
  }
  var ceilLog2 = notImplemented("ceilLog2");
  var factorial = notImplemented("factorial");
  function nearestPowerOfTwo(xi) {
    let v = 1;
    while (v < xi) {
      v *= 2;
    }
    return v;
  }
  function isPowerOfTwo(x) {
    return x === nearestPowerOfTwo(x);
  }
  function binomial(m, n) {
    let r = 1;
    for (let i = 1; i <= n; ++i) {
      r *= (m - i + 1) / i;
    }
    return Math.floor(r);
  }
  function beginCombination(m, n) {
    if (m < n) {
      return 0;
    }
    const r = createArray(n);
    for (let i = 0; i < n; ++i) {
      r[i] = i;
    }
    return r;
  }
  function nextCombination(m, n, r) {
    let status = 0;
    for (let i = n - 1; i >= 0; --i) {
      if (r[i] < m - n + i) {
        let j = r[i] + 1;
        while (i < n) {
          r[i++] = j++;
        }
        status = 1;
        break;
      }
    }
    return status;
  }
  function randomSeed(seed) {
    (0, import_seedrandom.default)(`${seed}`, {
      global: true
    });
    randomSeedValue = seed;
  }
  function getSeed() {
    return randomSeedValue;
  }
  function random4() {
    let minValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let maxValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const delta = maxValue - minValue;
    return minValue + delta * Math.random();
  }
  var gaussian = notImplemented("gaussian");
  function add6(a, b, out) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract5(a, b, out) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiplyScalar3(vec, scalar) {
    vec[0] *= scalar;
    vec[1] *= scalar;
    vec[2] *= scalar;
    return vec;
  }
  function multiplyScalar2D(vec, scalar) {
    vec[0] *= scalar;
    vec[1] *= scalar;
    return vec;
  }
  function multiplyAccumulate(a, b, scalar, out) {
    out[0] = a[0] + b[0] * scalar;
    out[1] = a[1] + b[1] * scalar;
    out[2] = a[2] + b[2] * scalar;
    return out;
  }
  function multiplyAccumulate2D(a, b, scalar, out) {
    out[0] = a[0] + b[0] * scalar;
    out[1] = a[1] + b[1] * scalar;
    return out;
  }
  function dot4(x, y) {
    return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
  }
  function outer(x, y, out_3x3) {
    out_3x3[0] = x[0] * y[0];
    out_3x3[1] = x[0] * y[1];
    out_3x3[2] = x[0] * y[2];
    out_3x3[3] = x[1] * y[0];
    out_3x3[4] = x[1] * y[1];
    out_3x3[5] = x[1] * y[2];
    out_3x3[6] = x[2] * y[0];
    out_3x3[7] = x[2] * y[1];
    out_3x3[8] = x[2] * y[2];
  }
  function cross3(x, y, out) {
    const Zx = x[1] * y[2] - x[2] * y[1];
    const Zy = x[2] * y[0] - x[0] * y[2];
    const Zz = x[0] * y[1] - x[1] * y[0];
    out[0] = Zx;
    out[1] = Zy;
    out[2] = Zz;
    return out;
  }
  function norm(x) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    switch (n) {
      case 1:
        return Math.abs(x);
      case 2:
        return Math.sqrt(x[0] * x[0] + x[1] * x[1]);
      case 3:
        return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
      default: {
        let sum = 0;
        for (let i = 0; i < n; i++) {
          sum += x[i] * x[i];
        }
        return Math.sqrt(sum);
      }
    }
  }
  function normalize4(x) {
    const den = norm(x);
    if (den !== 0) {
      x[0] /= den;
      x[1] /= den;
      x[2] /= den;
    }
    return den;
  }
  function normalize4D(x) {
    const den = norm(x, 3);
    if (den !== 0) {
      x[0] /= den;
      x[1] /= den;
      x[2] /= den;
      x[3] /= den;
    }
    return den;
  }
  function perpendiculars(x, y, z, theta) {
    const x2 = x[0] * x[0];
    const y2 = x[1] * x[1];
    const z2 = x[2] * x[2];
    const r = Math.sqrt(x2 + y2 + z2);
    let dx;
    let dy;
    let dz;
    if (x2 > y2 && x2 > z2) {
      dx = 0;
      dy = 1;
      dz = 2;
    } else if (y2 > z2) {
      dx = 1;
      dy = 2;
      dz = 0;
    } else {
      dx = 2;
      dy = 0;
      dz = 1;
    }
    const a = x[dx] / r;
    const b = x[dy] / r;
    const c = x[dz] / r;
    const tmp = Math.sqrt(a * a + c * c);
    if (theta !== 0) {
      const sintheta = Math.sin(theta);
      const costheta = Math.cos(theta);
      if (y) {
        y[dx] = (c * costheta - a * b * sintheta) / tmp;
        y[dy] = sintheta * tmp;
        y[dz] = (-(a * costheta) - b * c * sintheta) / tmp;
      }
      if (z) {
        z[dx] = (-(c * sintheta) - a * b * costheta) / tmp;
        z[dy] = costheta * tmp;
        z[dz] = (a * sintheta - b * c * costheta) / tmp;
      }
    } else {
      if (y) {
        y[dx] = c / tmp;
        y[dy] = 0;
        y[dz] = -a / tmp;
      }
      if (z) {
        z[dx] = -a * b / tmp;
        z[dy] = tmp;
        z[dz] = -b * c / tmp;
      }
    }
  }
  function projectVector(a, b, projection2) {
    const bSquared = dot4(b, b);
    if (bSquared === 0) {
      projection2[0] = 0;
      projection2[1] = 0;
      projection2[2] = 0;
      return false;
    }
    const scale7 = dot4(a, b) / bSquared;
    for (let i = 0; i < 3; i++) {
      projection2[i] = b[i];
    }
    multiplyScalar3(projection2, scale7);
    return true;
  }
  function dot2D(x, y) {
    return x[0] * y[0] + x[1] * y[1];
  }
  function projectVector2D(a, b, projection2) {
    const bSquared = dot2D(b, b);
    if (bSquared === 0) {
      projection2[0] = 0;
      projection2[1] = 0;
      return false;
    }
    const scale7 = dot2D(a, b) / bSquared;
    for (let i = 0; i < 2; i++) {
      projection2[i] = b[i];
    }
    multiplyScalar2D(projection2, scale7);
    return true;
  }
  function distance2BetweenPoints(x, y) {
    return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]);
  }
  function angleBetweenVectors(v1, v2) {
    const crossVect = [0, 0, 0];
    cross3(v1, v2, crossVect);
    return Math.atan2(norm(crossVect), dot4(v1, v2));
  }
  function gaussianAmplitude(mean, variance, position) {
    const distanceFromMean = Math.abs(mean - position);
    return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-(distanceFromMean ** 2) / (2 * variance));
  }
  function gaussianWeight(mean, variance, position) {
    const distanceFromMean = Math.abs(mean - position);
    return Math.exp(-(distanceFromMean ** 2) / (2 * variance));
  }
  function outer2D(x, y, out_2x2) {
    out_2x2[0] = x[0] * y[0];
    out_2x2[1] = x[0] * y[1];
    out_2x2[2] = x[1] * y[0];
    out_2x2[3] = x[1] * y[1];
  }
  function norm2D(x2D) {
    return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
  }
  function normalize2D(x) {
    const den = norm2D(x);
    if (den !== 0) {
      x[0] /= den;
      x[1] /= den;
    }
    return den;
  }
  function determinant2x2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 2) {
      return args[0][0] * args[1][1] - args[1][0] * args[0][1];
    }
    if (args.length === 4) {
      return args[0] * args[3] - args[1] * args[2];
    }
    return Number.NaN;
  }
  function LUFactor3x3(mat_3x3, index_3) {
    let maxI;
    let tmp;
    let largest;
    const scale7 = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      largest = Math.abs(mat_3x3[i * 3]);
      if ((tmp = Math.abs(mat_3x3[i * 3 + 1])) > largest) {
        largest = tmp;
      }
      if ((tmp = Math.abs(mat_3x3[i * 3 + 2])) > largest) {
        largest = tmp;
      }
      scale7[i] = 1 / largest;
    }
    largest = scale7[0] * Math.abs(mat_3x3[0]);
    maxI = 0;
    if ((tmp = scale7[1] * Math.abs(mat_3x3[3])) >= largest) {
      largest = tmp;
      maxI = 1;
    }
    if ((tmp = scale7[2] * Math.abs(mat_3x3[6])) >= largest) {
      maxI = 2;
    }
    if (maxI !== 0) {
      swapRowsMatrix_nxn(mat_3x3, 3, maxI, 0);
      scale7[maxI] = scale7[0];
    }
    index_3[0] = maxI;
    mat_3x3[3] /= mat_3x3[0];
    mat_3x3[6] /= mat_3x3[0];
    mat_3x3[4] -= mat_3x3[3] * mat_3x3[1];
    mat_3x3[7] -= mat_3x3[6] * mat_3x3[1];
    largest = scale7[1] * Math.abs(mat_3x3[4]);
    maxI = 1;
    if ((tmp = scale7[2] * Math.abs(mat_3x3[7])) >= largest) {
      maxI = 2;
      swapRowsMatrix_nxn(mat_3x3, 3, 1, 2);
      scale7[2] = scale7[1];
    }
    index_3[1] = maxI;
    mat_3x3[7] /= mat_3x3[4];
    mat_3x3[5] -= mat_3x3[3] * mat_3x3[2];
    mat_3x3[8] -= mat_3x3[6] * mat_3x3[2] + mat_3x3[7] * mat_3x3[5];
    index_3[2] = 2;
  }
  function LUSolve3x3(mat_3x3, index_3, x_3) {
    let sum = x_3[index_3[0]];
    x_3[index_3[0]] = x_3[0];
    x_3[0] = sum;
    sum = x_3[index_3[1]];
    x_3[index_3[1]] = x_3[1];
    x_3[1] = sum - mat_3x3[3] * x_3[0];
    sum = x_3[index_3[2]];
    x_3[index_3[2]] = x_3[2];
    x_3[2] = sum - mat_3x3[6] * x_3[0] - mat_3x3[7] * x_3[1];
    x_3[2] /= mat_3x3[8];
    x_3[1] = (x_3[1] - mat_3x3[5] * x_3[2]) / mat_3x3[4];
    x_3[0] = (x_3[0] - mat_3x3[1] * x_3[1] - mat_3x3[2] * x_3[2]) / mat_3x3[0];
  }
  function linearSolve3x3(mat_3x3, x_3, y_3) {
    const a1 = mat_3x3[0];
    const b1 = mat_3x3[1];
    const c1 = mat_3x3[2];
    const a2 = mat_3x3[3];
    const b2 = mat_3x3[4];
    const c2 = mat_3x3[5];
    const a3 = mat_3x3[6];
    const b3 = mat_3x3[7];
    const c3 = mat_3x3[8];
    const d1 = +determinant2x2(b2, b3, c2, c3);
    const d2 = -determinant2x2(a2, a3, c2, c3);
    const d3 = +determinant2x2(a2, a3, b2, b3);
    const e1 = -determinant2x2(b1, b3, c1, c3);
    const e22 = +determinant2x2(a1, a3, c1, c3);
    const e3 = -determinant2x2(a1, a3, b1, b3);
    const f1 = +determinant2x2(b1, b2, c1, c2);
    const f2 = -determinant2x2(a1, a2, c1, c2);
    const f3 = +determinant2x2(a1, a2, b1, b2);
    const det = a1 * d1 + b1 * d2 + c1 * d3;
    const v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];
    const v2 = d2 * x_3[0] + e22 * x_3[1] + f2 * x_3[2];
    const v3 = d3 * x_3[0] + e3 * x_3[1] + f3 * x_3[2];
    y_3[0] = v1 / det;
    y_3[1] = v2 / det;
    y_3[2] = v3 / det;
  }
  function multiply3x3_vect3(mat_3x3, in_3, out_3) {
    const x = mat_3x3[0] * in_3[0] + mat_3x3[1] * in_3[1] + mat_3x3[2] * in_3[2];
    const y = mat_3x3[3] * in_3[0] + mat_3x3[4] * in_3[1] + mat_3x3[5] * in_3[2];
    const z = mat_3x3[6] * in_3[0] + mat_3x3[7] * in_3[1] + mat_3x3[8] * in_3[2];
    out_3[0] = x;
    out_3[1] = y;
    out_3[2] = z;
  }
  function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {
    const copyA = [...a_3x3];
    const copyB = [...b_3x3];
    for (let i = 0; i < 3; i++) {
      out_3x3[i] = copyA[0] * copyB[i] + copyA[1] * copyB[i + 3] + copyA[2] * copyB[i + 6];
      out_3x3[i + 3] = copyA[3] * copyB[i] + copyA[4] * copyB[i + 3] + copyA[5] * copyB[i + 6];
      out_3x3[i + 6] = copyA[6] * copyB[i] + copyA[7] * copyB[i + 3] + copyA[8] * copyB[i + 6];
    }
  }
  function multiplyMatrix(a, b, rowA, colA, rowB, colB, outRowAColB) {
    if (colA !== rowB) {
      vtkErrorMacro3("Number of columns of A must match number of rows of B.");
    }
    const copyA = [...a];
    const copyB = [...b];
    for (let i = 0; i < rowA; i++) {
      for (let j = 0; j < colB; j++) {
        outRowAColB[i * colB + j] = 0;
        for (let k = 0; k < colA; k++) {
          outRowAColB[i * colB + j] += copyA[i * colA + k] * copyB[j + colB * k];
        }
      }
    }
  }
  function transpose3x3(in_3x3, outT_3x3) {
    let tmp;
    tmp = in_3x3[3];
    outT_3x3[3] = in_3x3[1];
    outT_3x3[1] = tmp;
    tmp = in_3x3[6];
    outT_3x3[6] = in_3x3[2];
    outT_3x3[2] = tmp;
    tmp = in_3x3[7];
    outT_3x3[7] = in_3x3[5];
    outT_3x3[5] = tmp;
    outT_3x3[0] = in_3x3[0];
    outT_3x3[4] = in_3x3[4];
    outT_3x3[8] = in_3x3[8];
  }
  function invert3x3(in_3x3, outI_3x3) {
    const a1 = in_3x3[0];
    const b1 = in_3x3[1];
    const c1 = in_3x3[2];
    const a2 = in_3x3[3];
    const b2 = in_3x3[4];
    const c2 = in_3x3[5];
    const a3 = in_3x3[6];
    const b3 = in_3x3[7];
    const c3 = in_3x3[8];
    const d1 = +determinant2x2(b2, b3, c2, c3);
    const d2 = -determinant2x2(a2, a3, c2, c3);
    const d3 = +determinant2x2(a2, a3, b2, b3);
    const e1 = -determinant2x2(b1, b3, c1, c3);
    const e22 = +determinant2x2(a1, a3, c1, c3);
    const e3 = -determinant2x2(a1, a3, b1, b3);
    const f1 = +determinant2x2(b1, b2, c1, c2);
    const f2 = -determinant2x2(a1, a2, c1, c2);
    const f3 = +determinant2x2(a1, a2, b1, b2);
    const det = a1 * d1 + b1 * d2 + c1 * d3;
    if (det === 0) {
      vtkWarningMacro2("Matrix has 0 determinant");
    }
    outI_3x3[0] = d1 / det;
    outI_3x3[3] = d2 / det;
    outI_3x3[6] = d3 / det;
    outI_3x3[1] = e1 / det;
    outI_3x3[4] = e22 / det;
    outI_3x3[7] = e3 / det;
    outI_3x3[2] = f1 / det;
    outI_3x3[5] = f2 / det;
    outI_3x3[8] = f3 / det;
  }
  function determinant3x3(mat_3x3) {
    return mat_3x3[0] * mat_3x3[4] * mat_3x3[8] + mat_3x3[3] * mat_3x3[7] * mat_3x3[2] + mat_3x3[6] * mat_3x3[1] * mat_3x3[5] - mat_3x3[0] * mat_3x3[7] * mat_3x3[5] - mat_3x3[3] * mat_3x3[1] * mat_3x3[8] - mat_3x3[6] * mat_3x3[4] * mat_3x3[2];
  }
  function areEquals(a, b) {
    let eps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EPSILON2;
    if (a.length !== b.length) {
      return false;
    }
    function isEqual(element, index) {
      return Math.abs(element - b[index]) <= eps;
    }
    return a.every(isEqual);
  }
  var areMatricesEqual = areEquals;
  function identity3x3(mat_3x3) {
    for (let i = 0; i < 3; i++) {
      mat_3x3[i * 3] = mat_3x3[i * 3 + 1] = mat_3x3[i * 3 + 2] = 0;
      mat_3x3[i * 3 + i] = 1;
    }
  }
  function identity4(n, mat) {
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        mat[i * n + j] = 0;
      }
      mat[i * n + i] = 1;
    }
    return mat;
  }
  function isIdentity(mat) {
    let eps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : EPSILON2;
    return areMatricesEqual(mat, IDENTITY, eps);
  }
  function isIdentity3x3(mat) {
    let eps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : EPSILON2;
    return areMatricesEqual(mat, IDENTITY_3X3, eps);
  }
  function quaternionToMatrix3x3(quat_4, mat_3x3) {
    const ww = quat_4[0] * quat_4[0];
    const wx = quat_4[0] * quat_4[1];
    const wy = quat_4[0] * quat_4[2];
    const wz = quat_4[0] * quat_4[3];
    const xx = quat_4[1] * quat_4[1];
    const yy = quat_4[2] * quat_4[2];
    const zz = quat_4[3] * quat_4[3];
    const xy = quat_4[1] * quat_4[2];
    const xz = quat_4[1] * quat_4[3];
    const yz = quat_4[2] * quat_4[3];
    const rr = xx + yy + zz;
    let f = 1 / (ww + rr);
    const s = (ww - rr) * f;
    f *= 2;
    mat_3x3[0] = xx * f + s;
    mat_3x3[3] = (xy + wz) * f;
    mat_3x3[6] = (xz - wy) * f;
    mat_3x3[1] = (xy - wz) * f;
    mat_3x3[4] = yy * f + s;
    mat_3x3[7] = (yz + wx) * f;
    mat_3x3[2] = (xz + wy) * f;
    mat_3x3[5] = (yz - wx) * f;
    mat_3x3[8] = zz * f + s;
  }
  function roundNumber(num) {
    let digits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!`${num}`.includes("e")) {
      return +`${Math.round(`${num}e+${digits}`)}e-${digits}`;
    }
    const arr = `${num}`.split("e");
    let sig = "";
    if (+arr[1] + digits > 0) {
      sig = "+";
    }
    return +`${Math.round(`${+arr[0]}e${sig}${+arr[1] + digits}`)}e-${digits}`;
  }
  function roundVector(vector) {
    let out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    let digits = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    out[0] = roundNumber(vector[0], digits);
    out[1] = roundNumber(vector[1], digits);
    out[2] = roundNumber(vector[2], digits);
    return out;
  }
  function jacobiN(a, n, w, v) {
    let i;
    let j;
    let k;
    let iq;
    let ip;
    let numPos;
    let tresh;
    let theta;
    let t;
    let tau;
    let sm;
    let s;
    let h;
    let g;
    let c;
    let tmp;
    const b = createArray(n);
    const z = createArray(n);
    const vtkROTATE = (aa, ii, jj) => {
      g = aa[ii];
      h = aa[jj];
      aa[ii] = g - s * (h + g * tau);
      aa[jj] = h + s * (g - h * tau);
    };
    identity4(n, v);
    for (ip = 0; ip < n; ip++) {
      b[ip] = w[ip] = a[ip + ip * n];
      z[ip] = 0;
    }
    for (i = 0; i < VTK_MAX_ROTATIONS; i++) {
      sm = 0;
      for (ip = 0; ip < n - 1; ip++) {
        for (iq = ip + 1; iq < n; iq++) {
          sm += Math.abs(a[ip * n + iq]);
        }
      }
      if (sm === 0) {
        break;
      }
      if (i < 3) {
        tresh = 0.2 * sm / (n * n);
      } else {
        tresh = 0;
      }
      for (ip = 0; ip < n - 1; ip++) {
        for (iq = ip + 1; iq < n; iq++) {
          g = 100 * Math.abs(a[ip * n + iq]);
          if (i > 3 && Math.abs(w[ip]) + g === Math.abs(w[ip]) && Math.abs(w[iq]) + g === Math.abs(w[iq])) {
            a[ip * n + iq] = 0;
          } else if (Math.abs(a[ip * n + iq]) > tresh) {
            h = w[iq] - w[ip];
            if (Math.abs(h) + g === Math.abs(h)) {
              t = a[ip * n + iq] / h;
            } else {
              theta = 0.5 * h / a[ip * n + iq];
              t = 1 / (Math.abs(theta) + Math.sqrt(1 + theta * theta));
              if (theta < 0) {
                t = -t;
              }
            }
            c = 1 / Math.sqrt(1 + t * t);
            s = t * c;
            tau = s / (1 + c);
            h = t * a[ip * n + iq];
            z[ip] -= h;
            z[iq] += h;
            w[ip] -= h;
            w[iq] += h;
            a[ip * n + iq] = 0;
            for (j = 0; j <= ip - 1; j++) {
              vtkROTATE(a, j * n + ip, j * n + iq);
            }
            for (j = ip + 1; j <= iq - 1; j++) {
              vtkROTATE(a, ip * n + j, j * n + iq);
            }
            for (j = iq + 1; j < n; j++) {
              vtkROTATE(a, ip * n + j, iq * n + j);
            }
            for (j = 0; j < n; j++) {
              vtkROTATE(v, j * n + ip, j * n + iq);
            }
          }
        }
      }
      for (ip = 0; ip < n; ip++) {
        b[ip] += z[ip];
        w[ip] = b[ip];
        z[ip] = 0;
      }
    }
    if (i >= VTK_MAX_ROTATIONS) {
      vtkWarningMacro2("vtkMath::Jacobi: Error extracting eigenfunctions");
      return 0;
    }
    for (j = 0; j < n - 1; j++) {
      k = j;
      tmp = w[k];
      for (i = j + 1; i < n; i++) {
        if (w[i] >= tmp || Math.abs(w[i] - tmp) < VTK_SMALL_NUMBER) {
          k = i;
          tmp = w[k];
        }
      }
      if (k !== j) {
        w[k] = w[j];
        w[j] = tmp;
        swapColumnsMatrix_nxn(v, n, j, k);
      }
    }
    const ceil_half_n = (n >> 1) + (n & 1);
    for (numPos = 0, i = 0; i < n * n; i++) {
      if (v[i] >= 0) {
        numPos++;
      }
    }
    if (numPos < ceil_half_n) {
      for (i = 0; i < n; i++) {
        v[i * n + j] *= -1;
      }
    }
    return 1;
  }
  function matrix3x3ToQuaternion(mat_3x3, quat_4) {
    const tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    tmp[0] = mat_3x3[0] + mat_3x3[4] + mat_3x3[8];
    tmp[5] = mat_3x3[0] - mat_3x3[4] - mat_3x3[8];
    tmp[10] = -mat_3x3[0] + mat_3x3[4] - mat_3x3[8];
    tmp[15] = -mat_3x3[0] - mat_3x3[4] + mat_3x3[8];
    tmp[1] = tmp[4] = mat_3x3[7] - mat_3x3[5];
    tmp[2] = tmp[8] = mat_3x3[2] - mat_3x3[6];
    tmp[3] = tmp[12] = mat_3x3[3] - mat_3x3[1];
    tmp[6] = tmp[9] = mat_3x3[3] + mat_3x3[1];
    tmp[7] = tmp[13] = mat_3x3[2] + mat_3x3[6];
    tmp[11] = tmp[14] = mat_3x3[7] + mat_3x3[5];
    const eigenvectors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    const eigenvalues = [0, 0, 0, 0];
    const NTemp = [...tmp];
    jacobiN(NTemp, 4, eigenvalues, eigenvectors);
    quat_4[0] = eigenvectors[0];
    quat_4[1] = eigenvectors[4];
    quat_4[2] = eigenvectors[8];
    quat_4[3] = eigenvectors[12];
  }
  function multiplyQuaternion(quat_1, quat_2, quat_out) {
    const ww = quat_1[0] * quat_2[0];
    const wx = quat_1[0] * quat_2[1];
    const wy = quat_1[0] * quat_2[2];
    const wz = quat_1[0] * quat_2[3];
    const xw = quat_1[1] * quat_2[0];
    const xx = quat_1[1] * quat_2[1];
    const xy = quat_1[1] * quat_2[2];
    const xz = quat_1[1] * quat_2[3];
    const yw = quat_1[2] * quat_2[0];
    const yx = quat_1[2] * quat_2[1];
    const yy = quat_1[2] * quat_2[2];
    const yz = quat_1[2] * quat_2[3];
    const zw = quat_1[3] * quat_2[0];
    const zx = quat_1[3] * quat_2[1];
    const zy = quat_1[3] * quat_2[2];
    const zz = quat_1[3] * quat_2[3];
    quat_out[0] = ww - xx - yy - zz;
    quat_out[1] = wx + xw + yz - zy;
    quat_out[2] = wy - xz + yw + zx;
    quat_out[3] = wz + xy - yx + zw;
  }
  function orthogonalize3x3(a_3x3, out_3x3) {
    for (let i = 0; i < 9; i++) {
      out_3x3[i] = a_3x3[i];
    }
    const scale7 = createArray(3);
    const index = createArray(3);
    let largest;
    for (let i = 0; i < 3; i++) {
      const x12 = Math.abs(out_3x3[i * 3]);
      const x22 = Math.abs(out_3x3[i * 3 + 1]);
      const x32 = Math.abs(out_3x3[i * 3 + 2]);
      largest = x22 > x12 ? x22 : x12;
      largest = x32 > largest ? x32 : largest;
      scale7[i] = 1;
      if (largest !== 0) {
        scale7[i] /= largest;
      }
    }
    const x1 = Math.abs(out_3x3[0]) * scale7[0];
    const x2 = Math.abs(out_3x3[3]) * scale7[1];
    const x3 = Math.abs(out_3x3[6]) * scale7[2];
    index[0] = 0;
    largest = x1;
    if (x2 >= largest) {
      largest = x2;
      index[0] = 1;
    }
    if (x3 >= largest) {
      index[0] = 2;
    }
    if (index[0] !== 0) {
      swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
      scale7[index[0]] = scale7[0];
    }
    const y2 = Math.abs(out_3x3[4]) * scale7[1];
    const y3 = Math.abs(out_3x3[7]) * scale7[2];
    index[1] = 1;
    largest = y2;
    if (y3 >= largest) {
      index[1] = 2;
      swapColumnsMatrix_nxn(out_3x3, 3, 1, 2);
    }
    index[2] = 2;
    let flip = 0;
    if (determinant3x3(out_3x3) < 0) {
      flip = 1;
      for (let i = 0; i < 9; i++) {
        out_3x3[i] = -out_3x3[i];
      }
    }
    const quat = createArray(4);
    matrix3x3ToQuaternion(out_3x3, quat);
    quaternionToMatrix3x3(quat, out_3x3);
    if (flip) {
      for (let i = 0; i < 9; i++) {
        out_3x3[i] = -out_3x3[i];
      }
    }
    if (index[1] !== 1) {
      swapColumnsMatrix_nxn(out_3x3, 3, index[1], 1);
    }
    if (index[0] !== 0) {
      swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
    }
  }
  function diagonalize3x3(a_3x3, w_3, v_3x3) {
    let i;
    let j;
    let k;
    let maxI;
    let tmp;
    let maxVal;
    const copyA = [...a_3x3];
    jacobiN(copyA, 3, w_3, v_3x3);
    if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {
      identity3x3(v_3x3);
      return;
    }
    transpose3x3(v_3x3, v_3x3);
    for (i = 0; i < 3; i++) {
      if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {
        maxVal = Math.abs(v_3x3[i * 3]);
        maxI = 0;
        for (j = 1; j < 3; j++) {
          if (maxVal < (tmp = Math.abs(v_3x3[i * 3 + j]))) {
            maxVal = tmp;
            maxI = j;
          }
        }
        if (maxI !== i) {
          tmp = w_3[maxI];
          w_3[maxI] = w_3[i];
          w_3[i] = tmp;
          swapRowsMatrix_nxn(v_3x3, 3, i, maxI);
        }
        if (v_3x3[maxI * 3 + maxI] < 0) {
          v_3x3[maxI * 3] = -v_3x3[maxI * 3];
          v_3x3[maxI * 3 + 1] = -v_3x3[maxI * 3 + 1];
          v_3x3[maxI * 3 + 2] = -v_3x3[maxI * 3 + 2];
        }
        j = (maxI + 1) % 3;
        k = (maxI + 2) % 3;
        v_3x3[j * 3] = 0;
        v_3x3[j * 3 + 1] = 0;
        v_3x3[j * 3 + 2] = 0;
        v_3x3[j * 3 + j] = 1;
        const vectTmp1 = cross3([v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], [v_3x3[j * 3], v_3x3[j * 3 + 1], v_3x3[j * 3 + 2]], []);
        normalize4(vectTmp1);
        const vectTmp2 = cross3(vectTmp1, [v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], []);
        for (let t = 0; t < 3; t++) {
          v_3x3[k * 3 + t] = vectTmp1[t];
          v_3x3[j * 3 + t] = vectTmp2[t];
        }
        transpose3x3(v_3x3, v_3x3);
        return;
      }
    }
    maxVal = Math.abs(v_3x3[0]);
    maxI = 0;
    for (i = 1; i < 3; i++) {
      if (maxVal < (tmp = Math.abs(v_3x3[i * 3]))) {
        maxVal = tmp;
        maxI = i;
      }
    }
    if (maxI !== 0) {
      const eigenValTmp = w_3[maxI];
      w_3[maxI] = w_3[0];
      w_3[0] = eigenValTmp;
      swapRowsMatrix_nxn(v_3x3, 3, maxI, 0);
    }
    if (Math.abs(v_3x3[4]) < Math.abs(v_3x3[7])) {
      const eigenValTmp = w_3[2];
      w_3[2] = w_3[1];
      w_3[1] = eigenValTmp;
      swapRowsMatrix_nxn(v_3x3, 3, 1, 2);
    }
    for (i = 0; i < 2; i++) {
      if (v_3x3[i * 3 + i] < 0) {
        v_3x3[i * 3] = -v_3x3[i * 3];
        v_3x3[i * 3 + 1] = -v_3x3[i * 3 + 1];
        v_3x3[i * 3 + 2] = -v_3x3[i * 3 + 2];
      }
    }
    if (determinant3x3(v_3x3) < 0) {
      v_3x3[6] = -v_3x3[6];
      v_3x3[7] = -v_3x3[7];
      v_3x3[8] = -v_3x3[8];
    }
    transpose3x3(v_3x3, v_3x3);
  }
  function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {
    let i;
    const B = [...a_3x3];
    const d = determinant3x3(B);
    if (d < 0) {
      for (i = 0; i < 9; i++) {
        B[i] = -B[i];
      }
    }
    orthogonalize3x3(B, u_3x3);
    transpose3x3(B, B);
    multiply3x3_mat3(B, u_3x3, vT_3x3);
    diagonalize3x3(vT_3x3, w_3, vT_3x3);
    multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);
    transpose3x3(vT_3x3, vT_3x3);
    if (d < 0) {
      w_3[0] = -w_3[0];
      w_3[1] = -w_3[1];
      w_3[2] = -w_3[2];
    }
  }
  function luFactorLinearSystem(A, index, size) {
    let i;
    let j;
    let k;
    let largest;
    let maxI = 0;
    let sum;
    let temp1;
    let temp2;
    const scale7 = createArray(size);
    for (i = 0; i < size; i++) {
      for (largest = 0, j = 0; j < size; j++) {
        if ((temp2 = Math.abs(A[i * size + j])) > largest) {
          largest = temp2;
        }
      }
      if (largest === 0) {
        vtkWarningMacro2("Unable to factor linear system");
        return 0;
      }
      scale7[i] = 1 / largest;
    }
    for (j = 0; j < size; j++) {
      for (i = 0; i < j; i++) {
        sum = A[i * size + j];
        for (k = 0; k < i; k++) {
          sum -= A[i * size + k] * A[k * size + j];
        }
        A[i * size + j] = sum;
      }
      for (largest = 0, i = j; i < size; i++) {
        sum = A[i * size + j];
        for (k = 0; k < j; k++) {
          sum -= A[i * size + k] * A[k * size + j];
        }
        A[i * size + j] = sum;
        if ((temp1 = scale7[i] * Math.abs(sum)) >= largest) {
          largest = temp1;
          maxI = i;
        }
      }
      if (j !== maxI) {
        for (k = 0; k < size; k++) {
          temp1 = A[maxI * size + k];
          A[maxI * size + k] = A[j * size + k];
          A[j * size + k] = temp1;
        }
        scale7[maxI] = scale7[j];
      }
      index[j] = maxI;
      if (Math.abs(A[j * size + j]) <= VTK_SMALL_NUMBER) {
        vtkWarningMacro2("Unable to factor linear system");
        return 0;
      }
      if (j !== size - 1) {
        temp1 = 1 / A[j * size + j];
        for (i = j + 1; i < size; i++) {
          A[i * size + j] *= temp1;
        }
      }
    }
    return 1;
  }
  function luSolveLinearSystem(A, index, x, size) {
    let i;
    let j;
    let ii;
    let idx;
    let sum;
    for (ii = -1, i = 0; i < size; i++) {
      idx = index[i];
      sum = x[idx];
      x[idx] = x[i];
      if (ii >= 0) {
        for (j = ii; j <= i - 1; j++) {
          sum -= A[i * size + j] * x[j];
        }
      } else if (sum !== 0) {
        ii = i;
      }
      x[i] = sum;
    }
    for (i = size - 1; i >= 0; i--) {
      sum = x[i];
      for (j = i + 1; j < size; j++) {
        sum -= A[i * size + j] * x[j];
      }
      x[i] = sum / A[i * size + i];
    }
  }
  function solveLinearSystem(A, x, size) {
    if (size === 2) {
      const y = createArray(2);
      const det = determinant2x2(A[0], A[1], A[2], A[3]);
      if (det === 0) {
        return 0;
      }
      y[0] = (A[3] * x[0] - A[1] * x[1]) / det;
      y[1] = (-(A[2] * x[0]) + A[0] * x[1]) / det;
      x[0] = y[0];
      x[1] = y[1];
      return 1;
    }
    if (size === 1) {
      if (A[0] === 0) {
        return 0;
      }
      x[0] /= A[0];
      return 1;
    }
    const index = createArray(size);
    if (luFactorLinearSystem(A, index, size) === 0) {
      return 0;
    }
    luSolveLinearSystem(A, index, x, size);
    return 1;
  }
  function invertMatrix(A, AI, size) {
    let index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    let column = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
    const tmp1Size = index || createArray(size);
    const tmp2Size = column || createArray(size);
    if (luFactorLinearSystem(A, tmp1Size, size) === 0) {
      return null;
    }
    for (let j = 0; j < size; j++) {
      for (let i = 0; i < size; i++) {
        tmp2Size[i] = 0;
      }
      tmp2Size[j] = 1;
      luSolveLinearSystem(A, tmp1Size, tmp2Size, size);
      for (let i = 0; i < size; i++) {
        AI[i * size + j] = tmp2Size[i];
      }
    }
    return AI;
  }
  function estimateMatrixCondition(A, size) {
    let minValue = +Number.MAX_VALUE;
    let maxValue = -Number.MAX_VALUE;
    for (let i = 0; i < size; i++) {
      for (let j = i; j < size; j++) {
        if (Math.abs(A[i * size + j]) > maxValue) {
          maxValue = Math.abs(A[i * size + j]);
        }
      }
    }
    for (let i = 0; i < size; i++) {
      if (Math.abs(A[i * size + i]) < minValue) {
        minValue = Math.abs(A[i * size + i]);
      }
    }
    if (minValue === 0) {
      return Number.MAX_VALUE;
    }
    return maxValue / minValue;
  }
  function jacobi(a_3x3, w, v) {
    return jacobiN(a_3x3, 3, w, v);
  }
  function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {
    if (numberOfSamples < xOrder) {
      vtkWarningMacro2("Insufficient number of samples. Underdetermined.");
      return 0;
    }
    let i;
    let j;
    let k;
    const XXt = createArray(xOrder * xOrder);
    const eigenvals = createArray(xOrder);
    const eigenvecs = createArray(xOrder * xOrder);
    for (k = 0; k < numberOfSamples; k++) {
      for (i = 0; i < xOrder; i++) {
        for (j = i; j < xOrder; j++) {
          XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
        }
      }
    }
    for (i = 0; i < xOrder; i++) {
      for (j = 0; j < i; j++) {
        XXt[i * xOrder + j] = XXt[j * xOrder + i];
      }
    }
    jacobiN(XXt, xOrder, eigenvals, eigenvecs);
    for (i = 0; i < xOrder; i++) {
      mt[i] = eigenvecs[i * xOrder + xOrder - 1];
    }
    return 1;
  }
  function solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt) {
    let checkHomogeneous = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true;
    if (numberOfSamples < xOrder || numberOfSamples < yOrder) {
      vtkWarningMacro2("Insufficient number of samples. Underdetermined.");
      return 0;
    }
    const homogenFlags = createArray(yOrder);
    let allHomogeneous = 1;
    let hmt;
    let homogRC = 0;
    let i;
    let j;
    let k;
    let someHomogeneous = 0;
    if (checkHomogeneous) {
      for (j = 0; j < yOrder; j++) {
        homogenFlags[j] = 1;
      }
      for (i = 0; i < numberOfSamples; i++) {
        for (j = 0; j < yOrder; j++) {
          if (Math.abs(yt[i * yOrder + j]) > VTK_SMALL_NUMBER) {
            allHomogeneous = 0;
            homogenFlags[j] = 0;
          }
        }
      }
      if (allHomogeneous && yOrder === 1) {
        vtkWarningMacro2("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()");
        return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
      }
      if (allHomogeneous) {
        someHomogeneous = 1;
      } else {
        for (j = 0; j < yOrder; j++) {
          if (homogenFlags[j]) {
            someHomogeneous = 1;
          }
        }
      }
    }
    if (someHomogeneous) {
      hmt = createArray(xOrder);
      homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
    }
    const XXt = createArray(xOrder * xOrder);
    const XXtI = createArray(xOrder * xOrder);
    const XYt = createArray(xOrder * yOrder);
    for (k = 0; k < numberOfSamples; k++) {
      for (i = 0; i < xOrder; i++) {
        for (j = i; j < xOrder; j++) {
          XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
        }
        for (j = 0; j < yOrder; j++) {
          XYt[i * yOrder + j] += xt[k * xOrder + i] * yt[k * yOrder + j];
        }
      }
    }
    for (i = 0; i < xOrder; i++) {
      for (j = 0; j < i; j++) {
        XXt[i * xOrder + j] = XXt[j * xOrder + i];
      }
    }
    const successFlag = invertMatrix(XXt, XXtI, xOrder);
    if (successFlag) {
      for (i = 0; i < xOrder; i++) {
        for (j = 0; j < yOrder; j++) {
          mt[i * yOrder + j] = 0;
          for (k = 0; k < xOrder; k++) {
            mt[i * yOrder + j] += XXtI[i * xOrder + k] * XYt[k * yOrder + j];
          }
        }
      }
    }
    if (someHomogeneous) {
      for (j = 0; j < yOrder; j++) {
        if (homogenFlags[j]) {
          for (i = 0; i < xOrder; i++) {
            mt[i * yOrder + j] = hmt[i * yOrder];
          }
        }
      }
    }
    if (someHomogeneous) {
      return homogRC && successFlag;
    }
    return successFlag;
  }
  function hex2float(hexStr) {
    let outFloatArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0.5, 1];
    switch (hexStr.length) {
      case 3:
        outFloatArray[0] = parseInt(hexStr[0], 16) * 17 / 255;
        outFloatArray[1] = parseInt(hexStr[1], 16) * 17 / 255;
        outFloatArray[2] = parseInt(hexStr[2], 16) * 17 / 255;
        return outFloatArray;
      case 4:
        outFloatArray[0] = parseInt(hexStr[1], 16) * 17 / 255;
        outFloatArray[1] = parseInt(hexStr[2], 16) * 17 / 255;
        outFloatArray[2] = parseInt(hexStr[3], 16) * 17 / 255;
        return outFloatArray;
      case 6:
        outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;
        outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;
        outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;
        return outFloatArray;
      case 7:
        outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
        outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
        outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
        return outFloatArray;
      case 9:
        outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
        outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
        outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
        outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;
        return outFloatArray;
      default:
        return outFloatArray;
    }
  }
  function rgb2hsv(rgb2, hsv) {
    let h;
    let s;
    const [r, g, b] = rgb2;
    const onethird = 1 / 3;
    const onesixth = 1 / 6;
    const twothird = 2 / 3;
    let cmax = r;
    let cmin = r;
    if (g > cmax) {
      cmax = g;
    } else if (g < cmin) {
      cmin = g;
    }
    if (b > cmax) {
      cmax = b;
    } else if (b < cmin) {
      cmin = b;
    }
    const v = cmax;
    if (v > 0) {
      s = (cmax - cmin) / cmax;
    } else {
      s = 0;
    }
    if (s > 0) {
      if (r === cmax) {
        h = onesixth * (g - b) / (cmax - cmin);
      } else if (g === cmax) {
        h = onethird + onesixth * (b - r) / (cmax - cmin);
      } else {
        h = twothird + onesixth * (r - g) / (cmax - cmin);
      }
      if (h < 0) {
        h += 1;
      }
    } else {
      h = 0;
    }
    hsv[0] = h;
    hsv[1] = s;
    hsv[2] = v;
  }
  function hsv2rgb(hsv, rgb2) {
    const [h, s, v] = hsv;
    const onethird = 1 / 3;
    const onesixth = 1 / 6;
    const twothird = 2 / 3;
    const fivesixth = 5 / 6;
    let r;
    let g;
    let b;
    if (h > onesixth && h <= onethird) {
      g = 1;
      r = (onethird - h) / onesixth;
      b = 0;
    } else if (h > onethird && h <= 0.5) {
      g = 1;
      b = (h - onethird) / onesixth;
      r = 0;
    } else if (h > 0.5 && h <= twothird) {
      b = 1;
      g = (twothird - h) / onesixth;
      r = 0;
    } else if (h > twothird && h <= fivesixth) {
      b = 1;
      r = (h - twothird) / onesixth;
      g = 0;
    } else if (h > fivesixth && h <= 1) {
      r = 1;
      b = (1 - h) / onesixth;
      g = 0;
    } else {
      r = 1;
      g = h / onesixth;
      b = 0;
    }
    r = s * r + (1 - s);
    g = s * g + (1 - s);
    b = s * b + (1 - s);
    r *= v;
    g *= v;
    b *= v;
    rgb2[0] = r;
    rgb2[1] = g;
    rgb2[2] = b;
  }
  function lab2xyz(lab, xyz) {
    const [L, a, b] = lab;
    let var_Y = (L + 16) / 116;
    let var_X = a / 500 + var_Y;
    let var_Z = var_Y - b / 200;
    if (var_Y ** 3 > 8856e-6) {
      var_Y **= 3;
    } else {
      var_Y = (var_Y - 16 / 116) / 7.787;
    }
    if (var_X ** 3 > 8856e-6) {
      var_X **= 3;
    } else {
      var_X = (var_X - 16 / 116) / 7.787;
    }
    if (var_Z ** 3 > 8856e-6) {
      var_Z **= 3;
    } else {
      var_Z = (var_Z - 16 / 116) / 7.787;
    }
    const ref_X = 0.9505;
    const ref_Y = 1;
    const ref_Z = 1.089;
    xyz[0] = ref_X * var_X;
    xyz[1] = ref_Y * var_Y;
    xyz[2] = ref_Z * var_Z;
  }
  function xyz2lab(xyz, lab) {
    const [x, y, z] = xyz;
    const ref_X = 0.9505;
    const ref_Y = 1;
    const ref_Z = 1.089;
    let var_X = x / ref_X;
    let var_Y = y / ref_Y;
    let var_Z = z / ref_Z;
    if (var_X > 8856e-6) var_X **= 1 / 3;
    else var_X = 7.787 * var_X + 16 / 116;
    if (var_Y > 8856e-6) var_Y **= 1 / 3;
    else var_Y = 7.787 * var_Y + 16 / 116;
    if (var_Z > 8856e-6) var_Z **= 1 / 3;
    else var_Z = 7.787 * var_Z + 16 / 116;
    lab[0] = 116 * var_Y - 16;
    lab[1] = 500 * (var_X - var_Y);
    lab[2] = 200 * (var_Y - var_Z);
  }
  function xyz2rgb(xyz, rgb2) {
    const [x, y, z] = xyz;
    let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    let b = x * 0.0557 + y * -0.204 + z * 1.057;
    if (r > 31308e-7) r = 1.055 * r ** (1 / 2.4) - 0.055;
    else r *= 12.92;
    if (g > 31308e-7) g = 1.055 * g ** (1 / 2.4) - 0.055;
    else g *= 12.92;
    if (b > 31308e-7) b = 1.055 * b ** (1 / 2.4) - 0.055;
    else b *= 12.92;
    let maxVal = r;
    if (maxVal < g) maxVal = g;
    if (maxVal < b) maxVal = b;
    if (maxVal > 1) {
      r /= maxVal;
      g /= maxVal;
      b /= maxVal;
    }
    if (r < 0) r = 0;
    if (g < 0) g = 0;
    if (b < 0) b = 0;
    rgb2[0] = r;
    rgb2[1] = g;
    rgb2[2] = b;
  }
  function rgb2xyz(rgb2, xyz) {
    let [r, g, b] = rgb2;
    if (r > 0.04045) r = ((r + 0.055) / 1.055) ** 2.4;
    else r /= 12.92;
    if (g > 0.04045) g = ((g + 0.055) / 1.055) ** 2.4;
    else g /= 12.92;
    if (b > 0.04045) b = ((b + 0.055) / 1.055) ** 2.4;
    else b /= 12.92;
    xyz[0] = r * 0.4124 + g * 0.3576 + b * 0.1805;
    xyz[1] = r * 0.2126 + g * 0.7152 + b * 0.0722;
    xyz[2] = r * 0.0193 + g * 0.1192 + b * 0.9505;
  }
  function rgb2lab(rgb2, lab) {
    const xyz = [0, 0, 0];
    rgb2xyz(rgb2, xyz);
    xyz2lab(xyz, lab);
  }
  function lab2rgb(lab, rgb2) {
    const xyz = [0, 0, 0];
    lab2xyz(lab, xyz);
    xyz2rgb(xyz, rgb2);
  }
  function uninitializeBounds(bounds) {
    bounds[0] = 1;
    bounds[1] = -1;
    bounds[2] = 1;
    bounds[3] = -1;
    bounds[4] = 1;
    bounds[5] = -1;
    return bounds;
  }
  function areBoundsInitialized(bounds) {
    return !(bounds[1] - bounds[0] < 0);
  }
  function computeBoundsFromPoints(point1, point2, bounds) {
    bounds[0] = Math.min(point1[0], point2[0]);
    bounds[1] = Math.max(point1[0], point2[0]);
    bounds[2] = Math.min(point1[1], point2[1]);
    bounds[3] = Math.max(point1[1], point2[1]);
    bounds[4] = Math.min(point1[2], point2[2]);
    bounds[5] = Math.max(point1[2], point2[2]);
    return bounds;
  }
  function clampValue(value, minValue, maxValue) {
    if (value < minValue) {
      return minValue;
    }
    if (value > maxValue) {
      return maxValue;
    }
    return value;
  }
  function clampVector(vector, minVector, maxVector) {
    let out = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0, 0, 0];
    out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
    out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
    out[2] = clampValue(vector[2], minVector[2], maxVector[2]);
    return out;
  }
  function clampAndNormalizeValue(value, range) {
    let result = 0;
    if (range[0] !== range[1]) {
      if (value < range[0]) {
        result = range[0];
      } else if (value > range[1]) {
        result = range[1];
      } else {
        result = value;
      }
      result = (result - range[0]) / (range[1] - range[0]);
    }
    return result;
  }
  var getScalarTypeFittingRange = notImplemented("GetScalarTypeFittingRange");
  var getAdjustedScalarRange = notImplemented("GetAdjustedScalarRange");
  function extentIsWithinOtherExtent(extent1, extent2) {
    if (!extent1 || !extent2) {
      return 0;
    }
    for (let i = 0; i < 6; i += 2) {
      if (extent1[i] < extent2[i] || extent1[i] > extent2[i + 1] || extent1[i + 1] < extent2[i] || extent1[i + 1] > extent2[i + 1]) {
        return 0;
      }
    }
    return 1;
  }
  function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {
    if (!bounds1_6 || !bounds2_6) {
      return 0;
    }
    for (let i = 0; i < 6; i += 2) {
      if (bounds1_6[i] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i] - delta_3[i / 2] > bounds2_6[i + 1] || bounds1_6[i + 1] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i + 1] - delta_3[i / 2] > bounds2_6[i + 1]) {
        return 0;
      }
    }
    return 1;
  }
  function pointIsWithinBounds(point_3, bounds_6, delta_3) {
    if (!point_3 || !bounds_6 || !delta_3) {
      return 0;
    }
    for (let i = 0; i < 3; i++) {
      if (point_3[i] + delta_3[i] < bounds_6[2 * i] || point_3[i] - delta_3[i] > bounds_6[2 * i + 1]) {
        return 0;
      }
    }
    return 1;
  }
  function solve3PointCircle(p1, p2, p3, center) {
    const v21 = createArray(3);
    const v32 = createArray(3);
    const v13 = createArray(3);
    const v12 = createArray(3);
    const v23 = createArray(3);
    const v31 = createArray(3);
    for (let i = 0; i < 3; ++i) {
      v21[i] = p1[i] - p2[i];
      v32[i] = p2[i] - p3[i];
      v13[i] = p3[i] - p1[i];
      v12[i] = -v21[i];
      v23[i] = -v32[i];
      v31[i] = -v13[i];
    }
    const norm12 = norm(v12);
    const norm23 = norm(v23);
    const norm13 = norm(v13);
    const crossv21v32 = createArray(3);
    cross3(v21, v32, crossv21v32);
    const normCross = norm(crossv21v32);
    const radius = norm12 * norm23 * norm13 / (2 * normCross);
    const normCross22 = 2 * normCross * normCross;
    const alpha = norm23 * norm23 * dot4(v21, v31) / normCross22;
    const beta = norm13 * norm13 * dot4(v12, v32) / normCross22;
    const gamma2 = norm12 * norm12 * dot4(v13, v23) / normCross22;
    for (let i = 0; i < 3; ++i) {
      center[i] = alpha * p1[i] + beta * p2[i] + gamma2 * p3[i];
    }
    return radius;
  }
  var inf = Infinity;
  var negInf = -Infinity;
  var isInf = (value) => !Number.isFinite(value);
  var {
    isFinite,
    isNaN: isNaN2
  } = Number;
  var isNan = isNaN2;
  function createUninitializedBounds() {
    return [].concat([
      Number.MAX_VALUE,
      -Number.MAX_VALUE,
      // X
      Number.MAX_VALUE,
      -Number.MAX_VALUE,
      // Y
      Number.MAX_VALUE,
      -Number.MAX_VALUE
      // Z
    ]);
  }
  function getMajorAxisIndex(vector) {
    let maxValue = -1;
    let axisIndex = -1;
    for (let i = 0; i < vector.length; i++) {
      const value = Math.abs(vector[i]);
      if (value > maxValue) {
        axisIndex = i;
        maxValue = value;
      }
    }
    return axisIndex;
  }
  function getSparseOrthogonalMatrix(matrix) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    const rows = new Array(n);
    const cols = new Array(n);
    for (let i = 0; i < n; ++i) {
      rows[i] = i;
      cols[i] = i;
    }
    for (let i = n - 1; i > 0; i--) {
      let bestValue = -Infinity;
      let bestRowI = 0;
      let bestColI = 0;
      for (let rowI = 0; rowI <= i; ++rowI) {
        const row = rows[rowI];
        for (let colI = 0; colI <= i; ++colI) {
          const col = cols[colI];
          const absVal = Math.abs(matrix[row + n * col]);
          if (absVal > bestValue) {
            bestValue = absVal;
            bestRowI = rowI;
            bestColI = colI;
          }
        }
      }
      [rows[i], rows[bestRowI]] = [rows[bestRowI], rows[i]];
      [cols[i], cols[bestColI]] = [cols[bestColI], cols[i]];
    }
    const output = new Array(n * n).fill(0);
    for (let i = 0; i < n; ++i) {
      const matIdx = rows[i] + n * cols[i];
      output[matIdx] = matrix[matIdx] < 0 ? -1 : 1;
    }
    return output;
  }
  function floatToHex2(value) {
    const integer = Math.floor(value * 255);
    if (integer > 15) {
      return integer.toString(16);
    }
    return `0${integer.toString(16)}`;
  }
  function floatRGB2HexCode(rgbArray) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#";
    return `${prefix}${rgbArray.map(floatToHex2).join("")}`;
  }
  function floatToChar(f) {
    return Math.round(f * 255);
  }
  function float2CssRGBA(rgbArray) {
    if (rgbArray.length === 3) {
      return `rgb(${rgbArray.map(floatToChar).join(", ")})`;
    }
    return `rgba(${floatToChar(rgbArray[0] || 0)}, ${floatToChar(rgbArray[1] || 0)}, ${floatToChar(rgbArray[2] || 0)}, ${rgbArray[3] || 0})`;
  }
  var vtkMath = {
    Pi,
    ldexp,
    radiansFromDegrees,
    degreesFromRadians,
    round: round3,
    floor: floor3,
    ceil: ceil3,
    ceilLog2,
    min: min3,
    max: max3,
    arrayMin,
    arrayMax,
    arrayRange,
    isPowerOfTwo,
    nearestPowerOfTwo,
    factorial,
    binomial,
    beginCombination,
    nextCombination,
    randomSeed,
    getSeed,
    random: random4,
    gaussian,
    add: add6,
    subtract: subtract5,
    multiplyScalar: multiplyScalar3,
    multiplyScalar2D,
    multiplyAccumulate,
    multiplyAccumulate2D,
    dot: dot4,
    outer,
    cross: cross3,
    norm,
    normalize: normalize4,
    perpendiculars,
    projectVector,
    projectVector2D,
    distance2BetweenPoints,
    angleBetweenVectors,
    gaussianAmplitude,
    gaussianWeight,
    dot2D,
    outer2D,
    norm2D,
    normalize2D,
    determinant2x2,
    LUFactor3x3,
    LUSolve3x3,
    linearSolve3x3,
    multiply3x3_vect3,
    multiply3x3_mat3,
    multiplyMatrix,
    transpose3x3,
    invert3x3,
    identity3x3,
    identity: identity4,
    isIdentity,
    isIdentity3x3,
    determinant3x3,
    quaternionToMatrix3x3,
    areEquals,
    areMatricesEqual,
    roundNumber,
    roundVector,
    matrix3x3ToQuaternion,
    multiplyQuaternion,
    orthogonalize3x3,
    diagonalize3x3,
    singularValueDecomposition3x3,
    solveLinearSystem,
    invertMatrix,
    luFactorLinearSystem,
    luSolveLinearSystem,
    estimateMatrixCondition,
    jacobi,
    jacobiN,
    solveHomogeneousLeastSquares,
    solveLeastSquares,
    hex2float,
    rgb2hsv,
    hsv2rgb,
    lab2xyz,
    xyz2lab,
    xyz2rgb,
    rgb2xyz,
    rgb2lab,
    lab2rgb,
    uninitializeBounds,
    areBoundsInitialized,
    computeBoundsFromPoints,
    clampValue,
    clampVector,
    clampAndNormalizeValue,
    getScalarTypeFittingRange,
    getAdjustedScalarRange,
    extentIsWithinOtherExtent,
    boundsIsWithinOtherBounds,
    pointIsWithinBounds,
    solve3PointCircle,
    inf,
    negInf,
    isInf,
    isNan: isNaN2,
    isNaN: isNaN2,
    isFinite,
    // JS add-on
    createUninitializedBounds,
    getMajorAxisIndex,
    getSparseOrthogonalMatrix,
    floatToHex2,
    floatRGB2HexCode,
    float2CssRGBA
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
  var {
    vtkDebugMacro: vtkDebugMacro2
  } = macro;
  function vtkCamera(publicAPI, model) {
    model.classHierarchy.push("vtkCamera");
    const origin = new Float64Array(3);
    const dopbasis = new Float64Array([0, 0, -1]);
    const upbasis = new Float64Array([0, 1, 0]);
    const tmpMatrix = mat4_exports.identity(new Float64Array(16));
    const tmpMatrix2 = mat4_exports.identity(new Float64Array(16));
    const tmpvec1 = new Float64Array(3);
    const tmpvec2 = new Float64Array(3);
    const tmpvec3 = new Float64Array(3);
    const rotateMatrix = mat4_exports.identity(new Float64Array(16));
    const trans = mat4_exports.identity(new Float64Array(16));
    const newPosition = new Float64Array(3);
    const newFocalPoint = new Float64Array(3);
    function computeViewPlaneNormal() {
      model.viewPlaneNormal[0] = -model.directionOfProjection[0];
      model.viewPlaneNormal[1] = -model.directionOfProjection[1];
      model.viewPlaneNormal[2] = -model.directionOfProjection[2];
    }
    publicAPI.orthogonalizeViewUp = () => {
      const vt = publicAPI.getViewMatrix();
      model.viewUp[0] = vt[4];
      model.viewUp[1] = vt[5];
      model.viewUp[2] = vt[6];
      publicAPI.modified();
    };
    publicAPI.setPosition = (x, y, z) => {
      if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {
        return;
      }
      model.position[0] = x;
      model.position[1] = y;
      model.position[2] = z;
      publicAPI.computeDistance();
      publicAPI.modified();
    };
    publicAPI.setFocalPoint = (x, y, z) => {
      if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {
        return;
      }
      model.focalPoint[0] = x;
      model.focalPoint[1] = y;
      model.focalPoint[2] = z;
      publicAPI.computeDistance();
      publicAPI.modified();
    };
    publicAPI.setDistance = (d) => {
      if (model.distance === d) {
        return;
      }
      model.distance = d;
      if (model.distance < 1e-20) {
        model.distance = 1e-20;
        vtkDebugMacro2("Distance is set to minimum.");
      }
      const vec = model.directionOfProjection;
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
      publicAPI.modified();
    };
    publicAPI.computeDistance = () => {
      const dx = model.focalPoint[0] - model.position[0];
      const dy = model.focalPoint[1] - model.position[1];
      const dz = model.focalPoint[2] - model.position[2];
      model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
      if (model.distance < 1e-20) {
        model.distance = 1e-20;
        vtkDebugMacro2("Distance is set to minimum.");
        const vec = model.directionOfProjection;
        model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
        model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
        model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
      }
      model.directionOfProjection[0] = dx / model.distance;
      model.directionOfProjection[1] = dy / model.distance;
      model.directionOfProjection[2] = dz / model.distance;
      computeViewPlaneNormal();
    };
    publicAPI.dolly = (amount) => {
      if (amount <= 0) {
        return;
      }
      const d = model.distance / amount;
      publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);
    };
    publicAPI.roll = (angle2) => {
      const eye = model.position;
      const at = model.focalPoint;
      const up = model.viewUp;
      const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0]);
      mat4_exports.identity(rotateMatrix);
      const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
      mat4_exports.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle2), viewDir);
      vec4_exports.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
      model.viewUp[0] = viewUpVec4[0];
      model.viewUp[1] = viewUpVec4[1];
      model.viewUp[2] = viewUpVec4[2];
      publicAPI.modified();
    };
    publicAPI.azimuth = (angle2) => {
      const fp = model.focalPoint;
      mat4_exports.identity(trans);
      mat4_exports.translate(trans, trans, fp);
      mat4_exports.rotate(trans, trans, radiansFromDegrees(angle2), model.viewUp);
      mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
      vec3_exports.transformMat4(newPosition, model.position, trans);
      publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
    };
    publicAPI.yaw = (angle2) => {
      const position = model.position;
      mat4_exports.identity(trans);
      mat4_exports.translate(trans, trans, position);
      mat4_exports.rotate(trans, trans, radiansFromDegrees(angle2), model.viewUp);
      mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
      vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
      publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
    };
    publicAPI.elevation = (angle2) => {
      const fp = model.focalPoint;
      const vt = publicAPI.getViewMatrix();
      const axis = [-vt[0], -vt[1], -vt[2]];
      mat4_exports.identity(trans);
      mat4_exports.translate(trans, trans, fp);
      mat4_exports.rotate(trans, trans, radiansFromDegrees(angle2), axis);
      mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
      vec3_exports.transformMat4(newPosition, model.position, trans);
      publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
    };
    publicAPI.pitch = (angle2) => {
      const position = model.position;
      const vt = publicAPI.getViewMatrix();
      const axis = [vt[0], vt[1], vt[2]];
      mat4_exports.identity(trans);
      mat4_exports.translate(trans, trans, position);
      mat4_exports.rotate(trans, trans, radiansFromDegrees(angle2), axis);
      mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
      vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
      publicAPI.setFocalPoint(...newFocalPoint);
    };
    publicAPI.zoom = (factor) => {
      if (factor <= 0) {
        return;
      }
      if (model.parallelProjection) {
        model.parallelScale /= factor;
      } else {
        model.viewAngle /= factor;
      }
      publicAPI.modified();
    };
    publicAPI.translate = (x, y, z) => {
      const offset = [x, y, z];
      add6(model.position, offset, model.position);
      add6(model.focalPoint, offset, model.focalPoint);
      publicAPI.computeDistance();
      publicAPI.modified();
    };
    publicAPI.applyTransform = (transformMat43) => {
      const vuOld = [...model.viewUp, 1];
      const posNew = [];
      const fpNew = [];
      const vuNew = [];
      vuOld[0] += model.position[0];
      vuOld[1] += model.position[1];
      vuOld[2] += model.position[2];
      vec4_exports.transformMat4(posNew, [...model.position, 1], transformMat43);
      vec4_exports.transformMat4(fpNew, [...model.focalPoint, 1], transformMat43);
      vec4_exports.transformMat4(vuNew, vuOld, transformMat43);
      vuNew[0] -= posNew[0];
      vuNew[1] -= posNew[1];
      vuNew[2] -= posNew[2];
      publicAPI.setPosition(...posNew.slice(0, 3));
      publicAPI.setFocalPoint(...fpNew.slice(0, 3));
      publicAPI.setViewUp(...vuNew.slice(0, 3));
    };
    publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];
    publicAPI.setThickness = (thickness) => {
      let t = thickness;
      if (t < 1e-20) {
        t = 1e-20;
        vtkDebugMacro2("Thickness is set to minimum.");
      }
      publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);
    };
    publicAPI.setThicknessFromFocalPoint = (thickness) => {
      let t = thickness;
      if (t < 1e-20) {
        t = 1e-20;
        vtkDebugMacro2("Thickness is set to minimum.");
      }
      publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
    };
    publicAPI.setRoll = (angle2) => {
    };
    publicAPI.getRoll = () => {
    };
    publicAPI.setObliqueAngles = (alpha, beta) => {
    };
    publicAPI.getOrientation = () => {
    };
    publicAPI.getOrientationWXYZ = () => {
    };
    publicAPI.getFrustumPlanes = function() {
      let aspect = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      let planes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Float64Array(24);
      const normals = [
        // Left
        [1, 0, 0, 1],
        // Right
        [-1, 0, 0, 1],
        // Bottom
        [0, 1, 0, 1],
        // Top
        [0, -1, 0, 1],
        // Near
        [0, 0, 1, 1],
        // Far
        [0, 0, -1, 1]
      ];
      const matrix = publicAPI.getCompositeProjectionMatrix(aspect, -1, 1);
      for (let i = 0; i < 6; i++) {
        vec4_exports.transformMat4(normals[i], normals[i], matrix);
        normalize4D(normals[i]);
        planes[4 * i + 0] = normals[i][0];
        planes[4 * i + 1] = normals[i][1];
        planes[4 * i + 2] = normals[i][2];
        planes[4 * i + 3] = normals[i][3];
      }
      return planes;
    };
    publicAPI.getCameraLightTransformMatrix = (matrix) => {
      mat4_exports.copy(matrix, model.cameraLightTransform);
      return matrix;
    };
    publicAPI.computeCameraLightTransform = () => {
      mat4_exports.copy(tmpMatrix, publicAPI.getViewMatrix());
      mat4_exports.invert(tmpMatrix, tmpMatrix);
      mat4_exports.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);
      mat4_exports.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);
      mat4_exports.identity(model.cameraLightTransform);
      mat4_exports.translate(model.cameraLightTransform, tmpMatrix, [0, 0, -1]);
    };
    publicAPI.deepCopy = (sourceCamera) => {
    };
    publicAPI.physicalOrientationToWorldDirection = (ori) => {
      const oriq = quat_exports.fromValues(ori[0], ori[1], ori[2], ori[3]);
      const coriq = quat_exports.create();
      const qdir = quat_exports.fromValues(0, 0, 1, 0);
      quat_exports.conjugate(coriq, oriq);
      quat_exports.multiply(qdir, oriq, qdir);
      quat_exports.multiply(qdir, qdir, coriq);
      return [qdir[0], qdir[1], qdir[2]];
    };
    publicAPI.getPhysicalToWorldMatrix = (result) => {
      publicAPI.getWorldToPhysicalMatrix(result);
      mat4_exports.invert(result, result);
    };
    publicAPI.getWorldToPhysicalMatrix = (result) => {
      mat4_exports.identity(result);
      const physVRight = [3];
      cross3(model.physicalViewNorth, model.physicalViewUp, physVRight);
      result[0] = physVRight[0];
      result[1] = physVRight[1];
      result[2] = physVRight[2];
      result[4] = model.physicalViewUp[0];
      result[5] = model.physicalViewUp[1];
      result[6] = model.physicalViewUp[2];
      result[8] = -model.physicalViewNorth[0];
      result[9] = -model.physicalViewNorth[1];
      result[10] = -model.physicalViewNorth[2];
      mat4_exports.transpose(result, result);
      vec3_exports.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
      mat4_exports.scale(result, result, tmpvec1);
      mat4_exports.translate(result, result, model.physicalTranslation);
    };
    publicAPI.computeViewParametersFromViewMatrix = (vmat) => {
      mat4_exports.invert(tmpMatrix, vmat);
      vec3_exports.transformMat4(tmpvec1, origin, tmpMatrix);
      publicAPI.computeDistance();
      const oldDist = model.distance;
      publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);
      vec3_exports.transformMat4(tmpvec2, dopbasis, tmpMatrix);
      vec3_exports.subtract(tmpvec2, tmpvec2, tmpvec1);
      vec3_exports.normalize(tmpvec2, tmpvec2);
      publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
      vec3_exports.transformMat4(tmpvec3, upbasis, tmpMatrix);
      vec3_exports.subtract(tmpvec3, tmpvec3, tmpvec1);
      vec3_exports.normalize(tmpvec3, tmpvec3);
      publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
      publicAPI.setDistance(oldDist);
    };
    publicAPI.computeViewParametersFromPhysicalMatrix = (mat) => {
      publicAPI.getWorldToPhysicalMatrix(tmpMatrix);
      mat4_exports.multiply(tmpMatrix, mat, tmpMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
    };
    publicAPI.setModelTransformMatrix = (mat) => {
      model.modelTransformMatrix = mat;
    };
    publicAPI.getModelTransformMatrix = () => model.modelTransformMatrix;
    publicAPI.setViewMatrix = (mat) => {
      model.viewMatrix = mat;
      if (model.viewMatrix) {
        mat4_exports.copy(tmpMatrix, model.viewMatrix);
        publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
        mat4_exports.transpose(model.viewMatrix, model.viewMatrix);
      }
    };
    publicAPI.getViewMatrix = () => {
      if (model.viewMatrix) {
        if (model.modelTransformMatrix) {
          mat4_exports.multiply(tmpMatrix, model.viewMatrix, model.modelTransformMatrix);
          return tmpMatrix;
        }
        return model.viewMatrix;
      }
      mat4_exports.lookAt(
        tmpMatrix,
        model.position,
        // eye
        model.focalPoint,
        // at
        model.viewUp
        // up
      );
      mat4_exports.transpose(tmpMatrix, tmpMatrix);
      const result = new Float64Array(16);
      if (model.modelTransformMatrix) {
        mat4_exports.multiply(result, tmpMatrix, model.modelTransformMatrix);
      } else {
        mat4_exports.copy(result, tmpMatrix);
      }
      return result;
    };
    publicAPI.setProjectionMatrix = (mat) => {
      model.projectionMatrix = mat;
    };
    publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
      const result = new Float64Array(16);
      mat4_exports.identity(result);
      if (model.projectionMatrix) {
        const scale7 = 1 / model.physicalScale;
        vec3_exports.set(tmpvec1, scale7, scale7, scale7);
        mat4_exports.copy(result, model.projectionMatrix);
        mat4_exports.scale(result, result, tmpvec1);
        mat4_exports.transpose(result, result);
        return result;
      }
      mat4_exports.identity(tmpMatrix);
      const cWidth = model.clippingRange[1] - model.clippingRange[0];
      const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2, model.clippingRange[0] + (farz + 1) * cWidth / 2];
      if (model.parallelProjection) {
        const width = model.parallelScale * aspect;
        const height = model.parallelScale;
        const xmin = (model.windowCenter[0] - 1) * width;
        const xmax = (model.windowCenter[0] + 1) * width;
        const ymin = (model.windowCenter[1] - 1) * height;
        const ymax = (model.windowCenter[1] + 1) * height;
        mat4_exports.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
        mat4_exports.transpose(tmpMatrix, tmpMatrix);
      } else if (model.useOffAxisProjection) {
        throw new Error("Off-Axis projection is not supported at this time");
      } else {
        const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2);
        let width;
        let height;
        if (model.useHorizontalViewAngle === true) {
          width = model.clippingRange[0] * tmp;
          height = model.clippingRange[0] * tmp / aspect;
        } else {
          width = model.clippingRange[0] * tmp * aspect;
          height = model.clippingRange[0] * tmp;
        }
        const xmin = (model.windowCenter[0] - 1) * width;
        const xmax = (model.windowCenter[0] + 1) * width;
        const ymin = (model.windowCenter[1] - 1) * height;
        const ymax = (model.windowCenter[1] + 1) * height;
        const znear = cRange[0];
        const zfar = cRange[1];
        tmpMatrix[0] = 2 * znear / (xmax - xmin);
        tmpMatrix[5] = 2 * znear / (ymax - ymin);
        tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
        tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
        tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
        tmpMatrix[14] = -1;
        tmpMatrix[11] = -2 * znear * zfar / (zfar - znear);
        tmpMatrix[15] = 0;
      }
      mat4_exports.copy(result, tmpMatrix);
      return result;
    };
    publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {
      const vMat = publicAPI.getViewMatrix();
      const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
      mat4_exports.multiply(pMat, vMat, pMat);
      return pMat;
    };
    publicAPI.setDirectionOfProjection = (x, y, z) => {
      if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {
        return;
      }
      model.directionOfProjection[0] = x;
      model.directionOfProjection[1] = y;
      model.directionOfProjection[2] = z;
      const vec = model.directionOfProjection;
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
      computeViewPlaneNormal();
    };
    publicAPI.setDeviceAngles = (alpha, beta, gamma2, screen) => {
      const physVRight = [3];
      cross3(model.physicalViewNorth, model.physicalViewUp, physVRight);
      const rotmat = mat4_exports.identity(new Float64Array(16));
      mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);
      mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);
      mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(gamma2), model.physicalViewNorth);
      mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);
      const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
      const vup = new Float64Array(model.physicalViewNorth);
      vec3_exports.transformMat4(dop, dop, rotmat);
      vec3_exports.transformMat4(vup, vup, rotmat);
      publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
      publicAPI.setViewUp(vup[0], vup[1], vup[2]);
      publicAPI.modified();
    };
    publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {
      const quatMat = mat4_exports.identity(new Float64Array(16));
      if (degrees !== 0 && (x !== 0 || y !== 0 || z !== 0)) {
        const angle2 = radiansFromDegrees(degrees);
        const q = quat_exports.create();
        quat_exports.setAxisAngle(q, [x, y, z], angle2);
        mat4_exports.fromQuat(quatMat, q);
      }
      const newdop = new Float64Array(3);
      vec3_exports.transformMat4(newdop, [0, 0, -1], quatMat);
      const newvup = new Float64Array(3);
      vec3_exports.transformMat4(newvup, [0, 1, 0], quatMat);
      publicAPI.setDirectionOfProjection(...newdop);
      publicAPI.setViewUp(...newvup);
      publicAPI.modified();
    };
    publicAPI.computeClippingRange = (bounds) => {
      let vn = null;
      let position = null;
      vn = model.viewPlaneNormal;
      position = model.position;
      const a = -vn[0];
      const b = -vn[1];
      const c = -vn[2];
      const d = -(a * position[0] + b * position[1] + c * position[2]);
      const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];
      for (let k = 0; k < 2; k++) {
        for (let j = 0; j < 2; j++) {
          for (let i = 0; i < 2; i++) {
            const dist3 = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
            range[0] = dist3 < range[0] ? dist3 : range[0];
            range[1] = dist3 > range[1] ? dist3 : range[1];
          }
        }
      }
      return range;
    };
  }
  var DEFAULT_VALUES = {
    position: [0, 0, 1],
    focalPoint: [0, 0, 0],
    viewUp: [0, 1, 0],
    directionOfProjection: [0, 0, -1],
    parallelProjection: false,
    useHorizontalViewAngle: false,
    viewAngle: 30,
    parallelScale: 1,
    clippingRange: [0.01, 1000.01],
    windowCenter: [0, 0],
    viewPlaneNormal: [0, 0, 1],
    useOffAxisProjection: false,
    screenBottomLeft: [-0.5, -0.5, -0.5],
    screenBottomRight: [0.5, -0.5, -0.5],
    screenTopRight: [0.5, 0.5, -0.5],
    freezeFocalPoint: false,
    projectionMatrix: null,
    viewMatrix: null,
    modelTransformMatrix: null,
    cameraLightTransform: mat4_exports.create(),
    // used for world to physical transformations
    physicalTranslation: [0, 0, 0],
    physicalScale: 1,
    physicalViewUp: [0, 1, 0],
    physicalViewNorth: [0, 0, -1]
  };
  function extend(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["distance"]);
    macro.setGet(publicAPI, model, ["parallelProjection", "useHorizontalViewAngle", "viewAngle", "parallelScale", "useOffAxisProjection", "freezeFocalPoint", "physicalScale"]);
    macro.getArray(publicAPI, model, ["directionOfProjection", "viewPlaneNormal", "position", "focalPoint"]);
    macro.setGetArray(publicAPI, model, ["clippingRange", "windowCenter"], 2);
    macro.setGetArray(publicAPI, model, ["viewUp", "screenBottomLeft", "screenBottomRight", "screenTopRight", "physicalTranslation", "physicalViewUp", "physicalViewNorth"], 3);
    vtkCamera(publicAPI, model);
  }
  var newInstance2 = macro.newInstance(extend, "vtkCamera");
  var vtkCamera$1 = {
    newInstance: newInstance2,
    extend
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Light.js
  var LIGHT_TYPES = ["HeadLight", "CameraLight", "SceneLight"];
  function vtkLight(publicAPI, model) {
    model.classHierarchy.push("vtkLight");
    const tmpVec = new Float64Array(3);
    publicAPI.getTransformedPosition = () => {
      if (model.transformMatrix) {
        vec3_exports.transformMat4(tmpVec, model.position, model.transformMatrix);
      } else {
        vec3_exports.set(tmpVec, model.position[0], model.position[1], model.position[2]);
      }
      return tmpVec;
    };
    publicAPI.getTransformedFocalPoint = () => {
      if (model.transformMatrix) {
        vec3_exports.transformMat4(tmpVec, model.focalPoint, model.transformMatrix);
      } else {
        vec3_exports.set(tmpVec, model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);
      }
      return tmpVec;
    };
    publicAPI.getDirection = () => {
      if (model.directionMTime < model.mtime) {
        vec3_exports.sub(model.direction, model.focalPoint, model.position);
        normalize4(model.direction);
        model.directionMTime = model.mtime;
      }
      return model.direction;
    };
    publicAPI.setDirection = (directionVector) => {
      const newFocalPoint = new Float64Array(3);
      vec3_exports.sub(newFocalPoint, model.position, directionVector);
      model.focalPoint = newFocalPoint;
    };
    publicAPI.setDirectionAngle = (elevation, azimuth) => {
      const elevationRadians = radiansFromDegrees(elevation);
      const azimuthRadians = radiansFromDegrees(azimuth);
      publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));
      publicAPI.setFocalPoint(0, 0, 0);
      publicAPI.setPositional(0);
    };
    publicAPI.setLightTypeToHeadLight = () => {
      publicAPI.setLightType("HeadLight");
    };
    publicAPI.setLightTypeToCameraLight = () => {
      publicAPI.setLightType("CameraLight");
    };
    publicAPI.setLightTypeToSceneLight = () => {
      publicAPI.setTransformMatrix(null);
      publicAPI.setLightType("SceneLight");
    };
    publicAPI.lightTypeIsHeadLight = () => model.lightType === "HeadLight";
    publicAPI.lightTypeIsSceneLight = () => model.lightType === "SceneLight";
    publicAPI.lightTypeIsCameraLight = () => model.lightType === "CameraLight";
  }
  var DEFAULT_VALUES2 = {
    switch: true,
    intensity: 1,
    color: [1, 1, 1],
    position: [0, 0, 1],
    focalPoint: [0, 0, 0],
    positional: false,
    exponent: 1,
    coneAngle: 30,
    coneFalloff: 5,
    attenuationValues: [1, 0, 0],
    transformMatrix: null,
    lightType: "SceneLight",
    shadowAttenuation: 1,
    direction: [0, 0, 0],
    directionMTime: 0
  };
  function extend2(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES2, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["intensity", "switch", "positional", "exponent", "coneAngle", "coneFalloff", "transformMatrix", "lightType", "shadowAttenuation", "attenuationValues"]);
    macro.setGetArray(publicAPI, model, ["color", "position", "focalPoint", "attenuationValues"], 3);
    vtkLight(publicAPI, model);
  }
  var newInstance3 = macro.newInstance(extend2, "vtkLight");
  var vtkLight$1 = {
    newInstance: newInstance3,
    extend: extend2,
    LIGHT_TYPES
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Viewport.js
  var {
    vtkErrorMacro: vtkErrorMacro4
  } = macro;
  function notImplemented2(method) {
    return () => vtkErrorMacro4(`vtkViewport::${method} - NOT IMPLEMENTED`);
  }
  function vtkViewport(publicAPI, model) {
    model.classHierarchy.push("vtkViewport");
    publicAPI.getViewProps = () => model.props;
    publicAPI.hasViewProp = (prop) => model.props.includes(prop);
    publicAPI.addViewProp = (prop) => {
      if (prop && !publicAPI.hasViewProp(prop)) {
        model.props.push(prop);
      }
    };
    publicAPI.removeViewProp = (prop) => {
      const newPropList = model.props.filter((item) => item !== prop);
      if (model.props.length !== newPropList.length) {
        model.props = newPropList;
      }
    };
    publicAPI.removeAllViewProps = () => {
      model.props = [];
    };
    function gatherProps(prop) {
      let allProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      allProps.push(prop);
      const children = prop.getNestedProps();
      if (children && children.length) {
        for (let i = 0; i < children.length; i++) {
          gatherProps(children[i], allProps);
        }
      }
      return allProps;
    }
    publicAPI.getViewPropsWithNestedProps = () => {
      let allPropsArray = [];
      const actors2D = publicAPI.getActors2D();
      actors2D.sort((a, b) => a.getLayerNumber() - b.getLayerNumber());
      const newPropList = model.props.filter((item) => !actors2D.includes(item));
      for (let i = 0; i < newPropList.length; i++) {
        gatherProps(newPropList[i], allPropsArray);
      }
      allPropsArray = allPropsArray.concat(actors2D);
      return allPropsArray;
    };
    publicAPI.addActor2D = publicAPI.addViewProp;
    publicAPI.removeActor2D = (prop) => {
      publicAPI.removeViewProp(prop);
    };
    publicAPI.getActors2D = () => {
      model.actors2D = [];
      model.props.forEach((prop) => {
        model.actors2D = model.actors2D.concat(prop.getActors2D());
      });
      return model.actors2D;
    };
    publicAPI.displayToView = () => vtkErrorMacro4("call displayToView on your view instead");
    publicAPI.viewToDisplay = () => vtkErrorMacro4("callviewtodisplay on your view instead");
    publicAPI.getSize = () => vtkErrorMacro4("call getSize on your View instead");
    publicAPI.normalizedDisplayToProjection = (x, y, z) => {
      const nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);
      return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
    };
    publicAPI.normalizedDisplayToNormalizedViewport = (x, y, z) => {
      const scale7 = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
      return [(x - model.viewport[0]) / scale7[0], (y - model.viewport[1]) / scale7[1], z];
    };
    publicAPI.normalizedViewportToProjection = (x, y, z) => [x * 2 - 1, y * 2 - 1, z * 2 - 1];
    publicAPI.projectionToNormalizedDisplay = (x, y, z) => {
      const nvp = publicAPI.projectionToNormalizedViewport(x, y, z);
      return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);
    };
    publicAPI.normalizedViewportToNormalizedDisplay = (x, y, z) => {
      const scale7 = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
      return [x * scale7[0] + model.viewport[0], y * scale7[1] + model.viewport[1], z];
    };
    publicAPI.projectionToNormalizedViewport = (x, y, z) => [(x + 1) * 0.5, (y + 1) * 0.5, (z + 1) * 0.5];
    publicAPI.PickPropFrom = notImplemented2("PickPropFrom");
  }
  var DEFAULT_VALUES3 = {
    // _vtkWindow: null,
    background: [0, 0, 0],
    background2: [0.2, 0.2, 0.2],
    gradientBackground: false,
    viewport: [0, 0, 1, 1],
    aspect: [1, 1],
    pixelAspect: [1, 1],
    props: [],
    actors2D: []
  };
  function extend3(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES3, initialValues);
    macro.obj(publicAPI, model);
    macro.event(publicAPI, model, "event");
    macro.setGetArray(publicAPI, model, ["viewport"], 4);
    macro.setGetArray(publicAPI, model, ["background", "background2"], 3);
    vtkViewport(publicAPI, model);
  }
  var newInstance4 = macro.newInstance(extend3, "vtkViewport");
  var vtkViewport$1 = {
    newInstance: newInstance4,
    extend: extend3
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/ImplicitFunction.js
  function vtkImplicitFunction(publicAPI, model) {
    model.classHierarchy.push("vtkImplicitFunction");
    publicAPI.functionValue = (xyz) => {
      if (!model.transform) {
        return publicAPI.evaluateFunction(xyz);
      }
      const transformedXYZ = [];
      model.transform.transformPoint(xyz, transformedXYZ);
      return publicAPI.evaluateFunction(transformedXYZ);
    };
    publicAPI.evaluateFunction = (_xyz) => {
      macro.vtkErrorMacro("not implemented");
    };
  }
  var DEFAULT_VALUES4 = {
    // transform : null
  };
  function extend4(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES4, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["transform"]);
    vtkImplicitFunction(publicAPI, model);
  }
  var newInstance5 = macro.newInstance(extend4, "vtkImplicitFunction");
  var vtkImplicitFunction$1 = {
    newInstance: newInstance5,
    extend: extend4
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/Plane.js
  var PLANE_TOLERANCE = 1e-6;
  var COINCIDE = "coincide";
  var DISJOINT = "disjoint";
  function evaluate(normal, origin, x) {
    return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
  }
  function distanceToPlane(x, origin, normal) {
    const distance3 = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
    return Math.abs(distance3);
  }
  function projectPoint(x, origin, normal, xproj) {
    const xo = [];
    subtract5(x, origin, xo);
    const t = dot4(normal, xo);
    xproj[0] = x[0] - t * normal[0];
    xproj[1] = x[1] - t * normal[1];
    xproj[2] = x[2] - t * normal[2];
  }
  function projectVector2(v, normal, vproj) {
    const t = dot4(v, normal);
    let n2 = dot4(normal, normal);
    if (n2 === 0) {
      n2 = 1;
    }
    vproj[0] = v[0] - t * normal[0] / n2;
    vproj[1] = v[1] - t * normal[1] / n2;
    vproj[2] = v[2] - t * normal[2] / n2;
    return vproj;
  }
  function generalizedProjectPoint(x, origin, normal, xproj) {
    const xo = [];
    subtract5(x, origin, xo);
    const t = dot4(normal, xo);
    const n2 = dot4(normal, normal);
    if (n2 !== 0) {
      xproj[0] = x[0] - t * normal[0] / n2;
      xproj[1] = x[1] - t * normal[1] / n2;
      xproj[2] = x[2] - t * normal[2] / n2;
    } else {
      xproj[0] = x[0];
      xproj[1] = x[1];
      xproj[2] = x[2];
    }
  }
  function intersectWithLine(p1, p2, origin, normal) {
    const outObj = {
      intersection: false,
      betweenPoints: false,
      t: Number.MAX_VALUE,
      x: []
    };
    const p21 = [];
    const p1Origin = [];
    subtract5(p2, p1, p21);
    subtract5(origin, p1, p1Origin);
    const num = dot4(normal, p1Origin);
    const den = dot4(normal, p21);
    let fabsden;
    let fabstolerance;
    if (den < 0) {
      fabsden = -den;
    } else {
      fabsden = den;
    }
    if (num < 0) {
      fabstolerance = -num * PLANE_TOLERANCE;
    } else {
      fabstolerance = num * PLANE_TOLERANCE;
    }
    if (fabsden <= fabstolerance) {
      return outObj;
    }
    outObj.t = num / den;
    outObj.x[0] = p1[0] + outObj.t * p21[0];
    outObj.x[1] = p1[1] + outObj.t * p21[1];
    outObj.x[2] = p1[2] + outObj.t * p21[2];
    outObj.intersection = true;
    outObj.betweenPoints = outObj.t >= 0 && outObj.t <= 1;
    return outObj;
  }
  function intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {
    const outObj = {
      intersection: false,
      l0: [],
      l1: [],
      error: null
    };
    const cross$1 = [];
    cross3(plane1Normal, plane2Normal, cross$1);
    const absCross = cross$1.map((n) => Math.abs(n));
    if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {
      const v = [];
      subtract5(plane1Origin, plane2Origin, v);
      if (dot4(plane1Normal, v) === 0) {
        outObj.error = COINCIDE;
      } else {
        outObj.error = DISJOINT;
      }
      return outObj;
    }
    let maxc;
    if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {
      maxc = "x";
    } else if (absCross[1] > absCross[2]) {
      maxc = "y";
    } else {
      maxc = "z";
    }
    const iP = [];
    const d1 = -dot4(plane1Normal, plane1Origin);
    const d2 = -dot4(plane2Normal, plane2Origin);
    switch (maxc) {
      case "x":
        iP[0] = 0;
        iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];
        iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];
        break;
      case "y":
        iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];
        iP[1] = 0;
        iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];
        break;
      case "z":
        iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];
        iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];
        iP[2] = 0;
        break;
    }
    outObj.l0 = iP;
    add6(iP, cross$1, outObj.l1);
    outObj.intersection = true;
    return outObj;
  }
  var STATIC = {
    evaluate,
    distanceToPlane,
    projectPoint,
    projectVector: projectVector2,
    generalizedProjectPoint,
    intersectWithLine,
    intersectWithPlane,
    DISJOINT,
    COINCIDE
  };
  function vtkPlane(publicAPI, model) {
    model.classHierarchy.push("vtkPlane");
    publicAPI.distanceToPlane = (x) => distanceToPlane(x, model.origin, model.normal);
    publicAPI.projectPoint = (x, xproj) => {
      projectPoint(x, model.origin, model.normal, xproj);
    };
    publicAPI.projectVector = (v, vproj) => projectVector2(v, model.normal, vproj);
    publicAPI.push = (distance3) => {
      if (distance3 === 0) {
        return;
      }
      for (let i = 0; i < 3; i++) {
        model.origin[i] += distance3 * model.normal[i];
      }
    };
    publicAPI.generalizedProjectPoint = (x, xproj) => {
      generalizedProjectPoint(x, model.origin, model.normal, xproj);
    };
    publicAPI.evaluateFunction = (x, y, z) => {
      if (!Array.isArray(x)) {
        return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);
      }
      return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);
    };
    publicAPI.evaluateGradient = (xyz) => {
      const retVal = [model.normal[0], model.normal[1], model.normal[2]];
      return retVal;
    };
    publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(p1, p2, model.origin, model.normal);
    publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);
  }
  var DEFAULT_VALUES5 = {
    normal: [0, 0, 1],
    origin: [0, 0, 0]
  };
  function extend5(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES5, initialValues);
    vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
    macro.setGetArray(publicAPI, model, ["normal", "origin"], 3);
    vtkPlane(publicAPI, model);
  }
  var newInstance6 = macro.newInstance(extend5, "vtkPlane");
  var vtkPlane$1 = {
    newInstance: newInstance6,
    extend: extend5,
    ...STATIC
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
  var INIT_BOUNDS = [
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    // X
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    // Y
    Number.MAX_VALUE,
    -Number.MAX_VALUE
    // Z
  ];
  function equals7(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
  }
  function isValid(bounds) {
    return bounds?.length >= 6 && bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];
  }
  function setBounds(bounds, otherBounds) {
    bounds[0] = otherBounds[0];
    bounds[1] = otherBounds[1];
    bounds[2] = otherBounds[2];
    bounds[3] = otherBounds[3];
    bounds[4] = otherBounds[4];
    bounds[5] = otherBounds[5];
    return bounds;
  }
  function reset(bounds) {
    return setBounds(bounds, INIT_BOUNDS);
  }
  function addPoint(bounds, x, y, z) {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
    bounds[0] = xMin < x ? xMin : x;
    bounds[1] = xMax > x ? xMax : x;
    bounds[2] = yMin < y ? yMin : y;
    bounds[3] = yMax > y ? yMax : y;
    bounds[4] = zMin < z ? zMin : z;
    bounds[5] = zMax > z ? zMax : z;
    return bounds;
  }
  function addPoints(bounds, points) {
    if (points.length === 0) {
      return bounds;
    }
    if (Array.isArray(points[0])) {
      for (let i = 0; i < points.length; ++i) {
        addPoint(bounds, ...points[i]);
      }
    } else {
      for (let i = 0; i < points.length; i += 3) {
        addPoint(bounds, ...points.slice(i, i + 3));
      }
    }
    return bounds;
  }
  function addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {
    const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;
    if (zMax === void 0) {
      bounds[0] = Math.min(xMin[0], _xMin);
      bounds[1] = Math.max(xMin[1], _xMax);
      bounds[2] = Math.min(xMin[2], _yMin);
      bounds[3] = Math.max(xMin[3], _yMax);
      bounds[4] = Math.min(xMin[4], _zMin);
      bounds[5] = Math.max(xMin[5], _zMax);
    } else {
      bounds[0] = Math.min(xMin, _xMin);
      bounds[1] = Math.max(xMax, _xMax);
      bounds[2] = Math.min(yMin, _yMin);
      bounds[3] = Math.max(yMax, _yMax);
      bounds[4] = Math.min(zMin, _zMin);
      bounds[5] = Math.max(zMax, _zMax);
    }
    return bounds;
  }
  function setMinPoint(bounds, x, y, z) {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
    bounds[0] = x;
    bounds[1] = x > xMax ? x : xMax;
    bounds[2] = y;
    bounds[3] = y > yMax ? y : yMax;
    bounds[4] = z;
    bounds[5] = z > zMax ? z : zMax;
    return xMin !== x || yMin !== y || zMin !== z;
  }
  function setMaxPoint(bounds, x, y, z) {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
    bounds[0] = x < xMin ? x : xMin;
    bounds[1] = x;
    bounds[2] = y < yMin ? y : yMin;
    bounds[3] = y;
    bounds[4] = z < zMin ? z : zMin;
    bounds[5] = z;
    return xMax !== x || yMax !== y || zMax !== z;
  }
  function inflate(bounds, delta) {
    if (delta == null) {
      return minInflate(bounds);
    }
    bounds[0] -= delta;
    bounds[1] += delta;
    bounds[2] -= delta;
    bounds[3] += delta;
    bounds[4] -= delta;
    bounds[5] += delta;
    return bounds;
  }
  function minInflate(bounds) {
    const nonZero = [0, 0, 0];
    let maxIdx = -1;
    let max4 = 0;
    let w = 0;
    for (let i = 0; i < 3; ++i) {
      w = bounds[i * 2 + 1] - bounds[i * 2];
      if (w > max4) {
        max4 = w;
        maxIdx = i;
      }
      nonZero[i] = w > 0 ? 1 : 0;
    }
    if (maxIdx < 0) {
      return inflate(bounds, 0.5);
    }
    for (let i = 0; i < 3; ++i) {
      if (!nonZero[i]) {
        const d = 5e-3 * max4;
        bounds[i * 2] -= d;
        bounds[i * 2 + 1] += d;
      }
    }
    return bounds;
  }
  function scale6(bounds, sx, sy, sz) {
    if (!isValid(bounds)) {
      return false;
    }
    if (sx >= 0) {
      bounds[0] *= sx;
      bounds[1] *= sx;
    } else {
      bounds[0] = sx * bounds[1];
      bounds[1] = sx * bounds[0];
    }
    if (sy >= 0) {
      bounds[2] *= sy;
      bounds[3] *= sy;
    } else {
      bounds[2] = sy * bounds[3];
      bounds[3] = sy * bounds[2];
    }
    if (sz >= 0) {
      bounds[4] *= sz;
      bounds[5] *= sz;
    } else {
      bounds[4] = sz * bounds[5];
      bounds[5] = sz * bounds[4];
    }
    return true;
  }
  function getCenter(bounds) {
    return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];
  }
  function scaleAboutCenter(bounds, sx, sy, sz) {
    if (!isValid(bounds)) {
      return false;
    }
    const center = getCenter(bounds);
    bounds[0] -= center[0];
    bounds[1] -= center[0];
    bounds[2] -= center[1];
    bounds[3] -= center[1];
    bounds[4] -= center[2];
    bounds[5] -= center[2];
    scale6(bounds, sx, sy, sz);
    bounds[0] += center[0];
    bounds[1] += center[0];
    bounds[2] += center[1];
    bounds[3] += center[1];
    bounds[4] += center[2];
    bounds[5] += center[2];
    return true;
  }
  function getLength(bounds, index) {
    return bounds[index * 2 + 1] - bounds[index * 2];
  }
  function getLengths(bounds) {
    return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];
  }
  function getXRange(bounds) {
    return bounds.slice(0, 2);
  }
  function getYRange(bounds) {
    return bounds.slice(2, 4);
  }
  function getZRange(bounds) {
    return bounds.slice(4, 6);
  }
  function getMaxLength(bounds) {
    const l = getLengths(bounds);
    if (l[0] > l[1]) {
      if (l[0] > l[2]) {
        return l[0];
      }
      return l[2];
    }
    if (l[1] > l[2]) {
      return l[1];
    }
    return l[2];
  }
  function getDiagonalLength2(bounds) {
    if (isValid(bounds)) {
      const l = getLengths(bounds);
      return l[0] * l[0] + l[1] * l[1] + l[2] * l[2];
    }
    return null;
  }
  function getDiagonalLength(bounds) {
    const lenght2 = getDiagonalLength2(bounds);
    return lenght2 !== null ? Math.sqrt(lenght2) : null;
  }
  function getMinPoint(bounds) {
    return [bounds[0], bounds[2], bounds[4]];
  }
  function getMaxPoint(bounds) {
    return [bounds[1], bounds[3], bounds[5]];
  }
  function oppositeSign(a, b) {
    return a <= 0 && b >= 0 || a >= 0 && b <= 0;
  }
  function getCorners(bounds, corners) {
    corners[0] = [bounds[0], bounds[2], bounds[4]];
    corners[1] = [bounds[0], bounds[2], bounds[5]];
    corners[2] = [bounds[0], bounds[3], bounds[4]];
    corners[3] = [bounds[0], bounds[3], bounds[5]];
    corners[4] = [bounds[1], bounds[2], bounds[4]];
    corners[5] = [bounds[1], bounds[2], bounds[5]];
    corners[6] = [bounds[1], bounds[3], bounds[4]];
    corners[7] = [bounds[1], bounds[3], bounds[5]];
    return corners;
  }
  function computeCornerPoints(bounds, point1, point2) {
    point1[0] = bounds[0];
    point1[1] = bounds[2];
    point1[2] = bounds[4];
    point2[0] = bounds[1];
    point2[1] = bounds[3];
    point2[2] = bounds[5];
    return point1;
  }
  function transformBounds(bounds, transform) {
    let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    const corners = getCorners(bounds, []);
    for (let i = 0; i < corners.length; ++i) {
      vec3_exports.transformMat4(corners[i], corners[i], transform);
    }
    reset(out);
    return addPoints(out, corners);
  }
  function computeScale3(bounds) {
    let scale32 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    scale32[0] = 0.5 * (bounds[1] - bounds[0]);
    scale32[1] = 0.5 * (bounds[3] - bounds[2]);
    scale32[2] = 0.5 * (bounds[5] - bounds[4]);
    return scale32;
  }
  function computeLocalBounds(points, u, v, w) {
    const bounds = [].concat(INIT_BOUNDS);
    const pointsData = points.getData();
    for (let i = 0; i < pointsData.length; i += 3) {
      const point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];
      const du = dot4(point, u);
      bounds[0] = Math.min(du, bounds[0]);
      bounds[1] = Math.max(du, bounds[1]);
      const dv = dot4(point, v);
      bounds[2] = Math.min(dv, bounds[2]);
      bounds[3] = Math.max(dv, bounds[3]);
      const dw = dot4(point, w);
      bounds[4] = Math.min(dw, bounds[4]);
      bounds[5] = Math.max(dw, bounds[5]);
    }
    return bounds;
  }
  function intersectBox(bounds, origin, dir, coord, tolerance) {
    let inside = true;
    const quadrant = [];
    let whichPlane = 0;
    const maxT = [];
    const candidatePlane = [0, 0, 0];
    const RIGHT = 0;
    const LEFT = 1;
    const MIDDLE = 2;
    for (let i = 0; i < 3; i++) {
      if (origin[i] < bounds[2 * i]) {
        quadrant[i] = LEFT;
        candidatePlane[i] = bounds[2 * i];
        inside = false;
      } else if (origin[i] > bounds[2 * i + 1]) {
        quadrant[i] = RIGHT;
        candidatePlane[i] = bounds[2 * i + 1];
        inside = false;
      } else {
        quadrant[i] = MIDDLE;
      }
    }
    if (inside) {
      coord[0] = origin[0];
      coord[1] = origin[1];
      coord[2] = origin[2];
      tolerance[0] = 0;
      return 1;
    }
    for (let i = 0; i < 3; i++) {
      if (quadrant[i] !== MIDDLE && dir[i] !== 0) {
        maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];
      } else {
        maxT[i] = -1;
      }
    }
    for (let i = 0; i < 3; i++) {
      if (maxT[whichPlane] < maxT[i]) {
        whichPlane = i;
      }
    }
    if (maxT[whichPlane] > 1 || maxT[whichPlane] < 0) {
      return 0;
    }
    tolerance[0] = maxT[whichPlane];
    for (let i = 0; i < 3; i++) {
      if (whichPlane !== i) {
        coord[i] = origin[i] + maxT[whichPlane] * dir[i];
        if (coord[i] < bounds[2 * i] || coord[i] > bounds[2 * i + 1]) {
          return 0;
        }
      } else {
        coord[i] = candidatePlane[i];
      }
    }
    return 1;
  }
  function intersectPlane(bounds, origin, normal) {
    const p = [];
    let d = 0;
    let sign = 1;
    let firstOne = 1;
    for (let z = 4; z <= 5; ++z) {
      p[2] = bounds[z];
      for (let y = 2; y <= 3; ++y) {
        p[1] = bounds[y];
        for (let x = 0; x <= 1; ++x) {
          p[0] = bounds[x];
          d = vtkPlane$1.evaluate(normal, origin, p);
          if (firstOne) {
            sign = d >= 0 ? 1 : -1;
            firstOne = 0;
          }
          if (d === 0 || sign > 0 && d < 0 || sign < 0 && d > 0) {
            return 1;
          }
        }
      }
    }
    return 0;
  }
  function intersect(bounds, bBounds) {
    if (!(isValid(bounds) && isValid(bBounds))) {
      return false;
    }
    const newBounds = [0, 0, 0, 0, 0, 0];
    let intersection2;
    for (let i = 0; i < 3; i++) {
      intersection2 = false;
      if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
        intersection2 = true;
        newBounds[i * 2] = bBounds[i * 2];
      } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
        intersection2 = true;
        newBounds[i * 2] = bounds[i * 2];
      }
      if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
        intersection2 = true;
        newBounds[i * 2 + 1] = bBounds[2 * i + 1];
      } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
        intersection2 = true;
        newBounds[i * 2 + 1] = bounds[i * 2 + 1];
      }
      if (!intersection2) {
        return false;
      }
    }
    bounds[0] = newBounds[0];
    bounds[1] = newBounds[1];
    bounds[2] = newBounds[2];
    bounds[3] = newBounds[3];
    bounds[4] = newBounds[4];
    bounds[5] = newBounds[5];
    return true;
  }
  function intersects(bounds, bBounds) {
    if (!(isValid(bounds) && isValid(bBounds))) {
      return false;
    }
    for (let i = 0; i < 3; i++) {
      if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
        continue;
      } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
        continue;
      }
      if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
        continue;
      } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
        continue;
      }
      return false;
    }
    return true;
  }
  function containsPoint(bounds, x, y, z) {
    if (x < bounds[0] || x > bounds[1]) {
      return false;
    }
    if (y < bounds[2] || y > bounds[3]) {
      return false;
    }
    if (z < bounds[4] || z > bounds[5]) {
      return false;
    }
    return true;
  }
  function contains(bounds, otherBounds) {
    if (!intersects(bounds, otherBounds)) {
      return false;
    }
    if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {
      return false;
    }
    if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {
      return false;
    }
    return true;
  }
  function cutWithPlane(bounds, origin, normal) {
    const index = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];
    const d = [0, 0, 0, 0, 0, 0, 0, 0];
    let idx = 0;
    for (let ix = 0; ix < 2; ix++) {
      for (let iy = 2; iy < 4; iy++) {
        for (let iz = 4; iz < 6; iz++) {
          const x = [bounds[ix], bounds[iy], bounds[iz]];
          d[idx++] = vtkPlane$1.evaluate(normal, origin, x);
        }
      }
    }
    let dir = 2;
    while (dir--) {
      if (oppositeSign(d[index[dir][0]], d[index[dir][4]]) && oppositeSign(d[index[dir][1]], d[index[dir][5]]) && oppositeSign(d[index[dir][2]], d[index[dir][6]]) && oppositeSign(d[index[dir][3]], d[index[dir][7]])) {
        break;
      }
    }
    if (dir < 0) {
      return false;
    }
    const sign = Math.sign(normal[dir]);
    const size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);
    let t = sign > 0 ? 1 : 0;
    for (let i = 0; i < 4; i++) {
      if (size === 0) {
        continue;
      }
      const ti = Math.abs(d[index[dir][i]]) / size;
      if (sign > 0 && ti < t) {
        t = ti;
      }
      if (sign < 0 && ti > t) {
        t = ti;
      }
    }
    const bound = (1 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];
    if (sign > 0) {
      bounds[dir * 2] = bound;
    } else {
      bounds[dir * 2 + 1] = bound;
    }
    return true;
  }
  function clampDivisions(targetBins, divs) {
    for (let i = 0; i < 3; ++i) {
      divs[i] = divs[i] < 1 ? 1 : divs[i];
    }
    let numBins = divs[0] * divs[1] * divs[2];
    while (numBins > targetBins) {
      for (let i = 0; i < 3; ++i) {
        divs[i] = divs[i] > 1 ? divs[i] - 1 : 1;
      }
      numBins = divs[0] * divs[1] * divs[2];
    }
  }
  function computeDivisions(bounds, totalBins, divs) {
    let adjustedBounds = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
    totalBins = totalBins <= 0 ? 1 : totalBins;
    let numNonZero = 0;
    const nonZero = [0, 0, 0];
    let maxIdx = -1;
    let max4 = 0;
    const lengths = getLengths(bounds);
    const totLen = lengths[0] + lengths[1] + lengths[2];
    const zeroDetectionTolerance = totLen * (1e-3 / 3);
    for (let i = 0; i < 3; ++i) {
      if (lengths[i] > max4) {
        maxIdx = i;
        max4 = lengths[i];
      }
      if (lengths[i] > zeroDetectionTolerance) {
        nonZero[i] = 1;
        numNonZero++;
      } else {
        nonZero[i] = 0;
      }
    }
    const minPoint = getMinPoint(bounds);
    const maxPoint = getMaxPoint(bounds);
    if (numNonZero < 1) {
      divs[0] = 1;
      divs[1] = 1;
      divs[2] = 1;
      adjustedBounds[0] = minPoint[0] - 0.5;
      adjustedBounds[1] = maxPoint[0] + 0.5;
      adjustedBounds[2] = minPoint[1] - 0.5;
      adjustedBounds[3] = maxPoint[1] + 0.5;
      adjustedBounds[4] = minPoint[2] - 0.5;
      adjustedBounds[5] = maxPoint[2] + 0.5;
      return 1;
    }
    let f = totalBins;
    f /= nonZero[0] ? lengths[0] / totLen : 1;
    f /= nonZero[1] ? lengths[1] / totLen : 1;
    f /= nonZero[2] ? lengths[2] / totLen : 1;
    f **= 1 / numNonZero;
    for (let i = 0; i < 3; ++i) {
      divs[i] = nonZero[i] ? Math.floor(f * lengths[i] / totLen) : 1;
      divs[i] = divs[i] < 1 ? 1 : divs[i];
    }
    clampDivisions(totalBins, divs);
    const delta = 0.5 * lengths[maxIdx] / divs[maxIdx];
    for (let i = 0; i < 3; ++i) {
      if (nonZero[i]) {
        adjustedBounds[2 * i] = minPoint[i];
        adjustedBounds[2 * i + 1] = maxPoint[i];
      } else {
        adjustedBounds[2 * i] = minPoint[i] - delta;
        adjustedBounds[2 * i + 1] = maxPoint[i] + delta;
      }
    }
    return divs[0] * divs[1] * divs[2];
  }
  function distance2ToBounds(x, bounds) {
    if (x[0] >= bounds[0] && x[0] <= bounds[1] && x[1] >= bounds[2] && x[1] <= bounds[3] && x[2] >= bounds[4] && x[2] <= bounds[5]) {
      return 0;
    }
    const deltas = [0, 0, 0];
    if (x[0] < bounds[0]) {
      deltas[0] = bounds[0] - x[0];
    } else if (x[0] > bounds[1]) {
      deltas[0] = x[0] - bounds[1];
    }
    if (x[1] < bounds[2]) {
      deltas[1] = bounds[2] - x[1];
    } else if (x[1] > bounds[3]) {
      deltas[1] = x[1] - bounds[3];
    }
    if (x[2] < bounds[4]) {
      deltas[2] = bounds[4] - x[2];
    } else if (x[2] > bounds[5]) {
      deltas[2] = x[2] - bounds[5];
    }
    return dot4(deltas, deltas);
  }
  var BoundingBox = class {
    constructor(refBounds) {
      this.bounds = refBounds;
      if (!this.bounds) {
        this.bounds = new Float64Array(INIT_BOUNDS);
      }
    }
    getBounds() {
      return this.bounds;
    }
    equals(otherBounds) {
      return equals7(this.bounds, otherBounds);
    }
    isValid() {
      return isValid(this.bounds);
    }
    setBounds(otherBounds) {
      return setBounds(this.bounds, otherBounds);
    }
    reset() {
      return reset(this.bounds);
    }
    addPoint() {
      for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {
        xyz[_key] = arguments[_key];
      }
      return addPoint(this.bounds, ...xyz);
    }
    addPoints(points) {
      return addPoints(this.bounds, points);
    }
    addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {
      return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);
    }
    setMinPoint(x, y, z) {
      return setMinPoint(this.bounds, x, y, z);
    }
    setMaxPoint(x, y, z) {
      return setMaxPoint(this.bounds, x, y, z);
    }
    inflate(delta) {
      return inflate(this.bounds, delta);
    }
    scale(sx, sy, sz) {
      return scale6(this.bounds, sx, sy, sz);
    }
    getCenter() {
      return getCenter(this.bounds);
    }
    getLength(index) {
      return getLength(this.bounds, index);
    }
    getLengths() {
      return getLengths(this.bounds);
    }
    getMaxLength() {
      return getMaxLength(this.bounds);
    }
    getDiagonalLength() {
      return getDiagonalLength(this.bounds);
    }
    getDiagonalLength2() {
      return getDiagonalLength2(this.bounds);
    }
    getMinPoint() {
      return getMinPoint(this.bounds);
    }
    getMaxPoint() {
      return getMaxPoint(this.bounds);
    }
    getXRange() {
      return getXRange(this.bounds);
    }
    getYRange() {
      return getYRange(this.bounds);
    }
    getZRange() {
      return getZRange(this.bounds);
    }
    getCorners(corners) {
      return getCorners(this.bounds, corners);
    }
    computeCornerPoints(point1, point2) {
      return computeCornerPoints(this.bounds, point1, point2);
    }
    computeLocalBounds(u, v, w) {
      return computeLocalBounds(this.bounds, u, v, w);
    }
    transformBounds(transform) {
      let out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return transformBounds(this.bounds, transform, out);
    }
    computeScale3(scale32) {
      return computeScale3(this.bounds, scale32);
    }
    cutWithPlane(origin, normal) {
      return cutWithPlane(this.bounds, origin, normal);
    }
    intersectBox(origin, dir, coord, tolerance) {
      return intersectBox(this.bounds, origin, dir, coord, tolerance);
    }
    intersectPlane(origin, normal) {
      return intersectPlane(this.bounds, origin, normal);
    }
    intersect(otherBounds) {
      return intersect(this.bounds, otherBounds);
    }
    intersects(otherBounds) {
      return intersects(this.bounds, otherBounds);
    }
    containsPoint(x, y, z) {
      return containsPoint(this.bounds, x, y, z);
    }
    contains(otherBounds) {
      return intersects(this.bounds, otherBounds);
    }
    computeDivisions(totalBins, divs) {
      let adjustedBounds = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      return computeDivisions(this.bounds, totalBins, divs, adjustedBounds);
    }
    distance2ToBounds(x) {
      return distance2ToBounds(x, this.bounds);
    }
  };
  function newInstance7(initialValues) {
    const bounds = initialValues && initialValues.bounds;
    return new BoundingBox(bounds);
  }
  var STATIC2 = {
    equals: equals7,
    isValid,
    setBounds,
    reset,
    addPoint,
    addPoints,
    addBounds,
    setMinPoint,
    setMaxPoint,
    inflate,
    scale: scale6,
    scaleAboutCenter,
    getCenter,
    getLength,
    getLengths,
    getMaxLength,
    getDiagonalLength,
    getDiagonalLength2,
    getMinPoint,
    getMaxPoint,
    getXRange,
    getYRange,
    getZRange,
    getCorners,
    computeCornerPoints,
    computeLocalBounds,
    transformBounds,
    computeScale3,
    cutWithPlane,
    intersectBox,
    intersectPlane,
    intersect,
    intersects,
    containsPoint,
    contains,
    computeDivisions,
    clampDivisions,
    distance2ToBounds,
    INIT_BOUNDS
  };
  var vtkBoundingBox = {
    newInstance: newInstance7,
    ...STATIC2
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js
  var {
    vtkDebugMacro: vtkDebugMacro3,
    vtkErrorMacro: vtkErrorMacro5,
    vtkWarningMacro: vtkWarningMacro3
  } = macro$1;
  function notImplemented3(method) {
    return () => vtkErrorMacro5(`vtkRenderer::${method} - NOT IMPLEMENTED`);
  }
  function vtkRenderer(publicAPI, model) {
    model.classHierarchy.push("vtkRenderer");
    const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
      type: "ComputeVisiblePropBoundsEvent",
      renderer: publicAPI
    };
    const RESET_CAMERA_CLIPPING_RANGE_EVENT = {
      type: "ResetCameraClippingRangeEvent",
      renderer: publicAPI
    };
    const RESET_CAMERA_EVENT = {
      type: "ResetCameraEvent",
      renderer: publicAPI
    };
    publicAPI.updateCamera = () => {
      if (!model.activeCamera) {
        vtkDebugMacro3("No cameras are on, creating one.");
        publicAPI.getActiveCameraAndResetIfCreated();
      }
      model.activeCamera.render(publicAPI);
      return true;
    };
    publicAPI.updateLightsGeometryToFollowCamera = () => {
      const camera = publicAPI.getActiveCameraAndResetIfCreated();
      model.lights.forEach((light) => {
        if (light.lightTypeIsSceneLight()) ;
        else if (light.lightTypeIsHeadLight()) {
          light.setPositionFrom(camera.getPositionByReference());
          light.setFocalPointFrom(camera.getFocalPointByReference());
          light.modified(camera.getMTime());
        } else if (light.lightTypeIsCameraLight()) {
          light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4_exports.create()));
        } else {
          vtkErrorMacro5("light has unknown light type", light.get());
        }
      });
    };
    publicAPI.updateLightGeometry = () => {
      if (model.lightFollowCamera) {
        return publicAPI.updateLightsGeometryToFollowCamera();
      }
      return true;
    };
    publicAPI.allocateTime = notImplemented3("allocateTime");
    publicAPI.updateGeometry = notImplemented3("updateGeometry");
    publicAPI.getVTKWindow = () => model._renderWindow;
    publicAPI.setLayer = (layer) => {
      vtkDebugMacro3(publicAPI.getClassName(), publicAPI, "setting Layer to ", layer);
      if (model.layer !== layer) {
        model.layer = layer;
        publicAPI.modified();
      }
      publicAPI.setPreserveColorBuffer(!!layer);
    };
    publicAPI.setActiveCamera = (camera) => {
      if (model.activeCamera === camera) {
        return false;
      }
      model.activeCamera = camera;
      publicAPI.modified();
      publicAPI.invokeEvent({
        type: "ActiveCameraEvent",
        camera
      });
      return true;
    };
    publicAPI.makeCamera = () => {
      const camera = vtkCamera$1.newInstance();
      publicAPI.invokeEvent({
        type: "CreateCameraEvent",
        camera
      });
      return camera;
    };
    publicAPI.getActiveCamera = () => {
      if (!model.activeCamera) {
        model.activeCamera = publicAPI.makeCamera();
      }
      return model.activeCamera;
    };
    publicAPI.getActiveCameraAndResetIfCreated = () => {
      if (!model.activeCamera) {
        publicAPI.getActiveCamera();
        publicAPI.resetCamera();
      }
      return model.activeCamera;
    };
    publicAPI.getActors = () => {
      model.actors = [];
      model.props.forEach((prop) => {
        model.actors = model.actors.concat(prop.getActors());
      });
      return model.actors;
    };
    publicAPI.addActor = publicAPI.addViewProp;
    publicAPI.removeActor = (actor) => {
      model.actors = model.actors.filter((a) => a !== actor);
      publicAPI.removeViewProp(actor);
      publicAPI.modified();
    };
    publicAPI.removeAllActors = () => {
      const actors = publicAPI.getActors();
      actors.forEach((actor) => {
        publicAPI.removeViewProp(actor);
      });
      model.actors = [];
      publicAPI.modified();
    };
    publicAPI.getVolumes = () => {
      model.volumes = [];
      model.props.forEach((prop) => {
        model.volumes = model.volumes.concat(prop.getVolumes());
      });
      return model.volumes;
    };
    publicAPI.addVolume = publicAPI.addViewProp;
    publicAPI.removeVolume = (volume) => {
      model.volumes = model.volumes.filter((v) => v !== volume);
      publicAPI.removeViewProp(volume);
      publicAPI.modified();
    };
    publicAPI.removeAllVolumes = () => {
      const volumes = publicAPI.getVolumes();
      volumes.forEach((volume) => {
        publicAPI.removeViewProp(volume);
      });
      model.volumes = [];
      publicAPI.modified();
    };
    publicAPI.hasLight = (light) => model.lights.includes(light);
    publicAPI.addLight = (light) => {
      if (light && !publicAPI.hasLight(light)) {
        model.lights.push(light);
        publicAPI.modified();
      }
    };
    publicAPI.removeLight = (light) => {
      model.lights = model.lights.filter((l) => l !== light);
      publicAPI.modified();
    };
    publicAPI.removeAllLights = () => {
      model.lights = [];
      publicAPI.modified();
    };
    publicAPI.setLightCollection = (lights) => {
      model.lights = lights;
      publicAPI.modified();
    };
    publicAPI.makeLight = vtkLight$1.newInstance;
    publicAPI.createLight = () => {
      if (!model.automaticLightCreation) {
        return;
      }
      if (model._createdLight) {
        publicAPI.removeLight(model._createdLight);
        model._createdLight.delete();
        model._createdLight = null;
      }
      model._createdLight = publicAPI.makeLight();
      publicAPI.addLight(model._createdLight);
      model._createdLight.setLightTypeToHeadLight();
      model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
      model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());
    };
    publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {
      let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);
      vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);
      return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
    };
    publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {
      let vpd = publicAPI.worldToView(x, y, z);
      vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);
      return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
    };
    publicAPI.viewToWorld = (x, y, z) => {
      if (model.activeCamera === null) {
        vtkErrorMacro5("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0");
        return [0, 0, 0];
      }
      const matrix = model.activeCamera.getViewMatrix();
      mat4_exports.invert(matrix, matrix);
      mat4_exports.transpose(matrix, matrix);
      const result = new Float64Array([x, y, z]);
      vec3_exports.transformMat4(result, result, matrix);
      return result;
    };
    publicAPI.projectionToView = (x, y, z, aspect) => {
      if (model.activeCamera === null) {
        vtkErrorMacro5("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0");
        return [0, 0, 0];
      }
      const matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
      mat4_exports.invert(matrix, matrix);
      mat4_exports.transpose(matrix, matrix);
      const result = new Float64Array([x, y, z]);
      vec3_exports.transformMat4(result, result, matrix);
      return result;
    };
    publicAPI.worldToView = (x, y, z) => {
      if (model.activeCamera === null) {
        vtkErrorMacro5("WorldToView: no active camera, cannot compute view to world, returning 0,0,0");
        return [0, 0, 0];
      }
      const matrix = model.activeCamera.getViewMatrix();
      mat4_exports.transpose(matrix, matrix);
      const result = new Float64Array([x, y, z]);
      vec3_exports.transformMat4(result, result, matrix);
      return result;
    };
    publicAPI.viewToProjection = (x, y, z, aspect) => {
      if (model.activeCamera === null) {
        vtkErrorMacro5("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0");
        return [0, 0, 0];
      }
      const matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
      mat4_exports.transpose(matrix, matrix);
      const result = new Float64Array([x, y, z]);
      vec3_exports.transformMat4(result, result, matrix);
      return result;
    };
    publicAPI.computeVisiblePropBounds = () => {
      model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];
      model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];
      model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];
      model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];
      model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];
      model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];
      let nothingVisible = true;
      publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);
      for (let index = 0; index < model.props.length; ++index) {
        const prop = model.props[index];
        if (prop.getVisibility() && prop.getUseBounds()) {
          const bounds = prop.getBounds();
          if (bounds && areBoundsInitialized(bounds)) {
            nothingVisible = false;
            if (bounds[0] < model.allBounds[0]) {
              model.allBounds[0] = bounds[0];
            }
            if (bounds[1] > model.allBounds[1]) {
              model.allBounds[1] = bounds[1];
            }
            if (bounds[2] < model.allBounds[2]) {
              model.allBounds[2] = bounds[2];
            }
            if (bounds[3] > model.allBounds[3]) {
              model.allBounds[3] = bounds[3];
            }
            if (bounds[4] < model.allBounds[4]) {
              model.allBounds[4] = bounds[4];
            }
            if (bounds[5] > model.allBounds[5]) {
              model.allBounds[5] = bounds[5];
            }
          }
        }
      }
      if (nothingVisible) {
        uninitializeBounds(model.allBounds);
        vtkDebugMacro3("Can't compute bounds, no 3D props are visible");
      }
      return model.allBounds;
    };
    publicAPI.resetCamera = function() {
      let bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
      const center = [0, 0, 0];
      if (!areBoundsInitialized(boundsToUse)) {
        vtkDebugMacro3("Cannot reset camera!");
        return false;
      }
      let vn = null;
      if (publicAPI.getActiveCamera()) {
        vn = model.activeCamera.getViewPlaneNormal();
      } else {
        vtkErrorMacro5("Trying to reset non-existent camera");
        return false;
      }
      model.activeCamera.setViewAngle(30);
      center[0] = (boundsToUse[0] + boundsToUse[1]) / 2;
      center[1] = (boundsToUse[2] + boundsToUse[3]) / 2;
      center[2] = (boundsToUse[4] + boundsToUse[5]) / 2;
      let w1 = boundsToUse[1] - boundsToUse[0];
      let w2 = boundsToUse[3] - boundsToUse[2];
      let w3 = boundsToUse[5] - boundsToUse[4];
      w1 *= w1;
      w2 *= w2;
      w3 *= w3;
      let radius = w1 + w2 + w3;
      radius = radius === 0 ? 1 : radius;
      radius = Math.sqrt(radius) * 0.5;
      const angle2 = radiansFromDegrees(model.activeCamera.getViewAngle());
      const parallelScale = radius;
      const distance3 = radius / Math.sin(angle2 * 0.5);
      const vup = model.activeCamera.getViewUp();
      if (Math.abs(dot4(vup, vn)) > 0.999) {
        vtkWarningMacro3("Resetting view-up since view plane normal is parallel");
        model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
      }
      model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
      model.activeCamera.setPosition(center[0] + distance3 * vn[0], center[1] + distance3 * vn[1], center[2] + distance3 * vn[2]);
      publicAPI.resetCameraClippingRange(boundsToUse);
      model.activeCamera.setParallelScale(parallelScale);
      model.activeCamera.setPhysicalScale(radius);
      model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);
      publicAPI.invokeEvent(RESET_CAMERA_EVENT);
      return true;
    };
    publicAPI.resetCameraClippingRange = function() {
      let bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
      if (!areBoundsInitialized(boundsToUse)) {
        vtkDebugMacro3("Cannot reset camera clipping range!");
        return false;
      }
      publicAPI.getActiveCameraAndResetIfCreated();
      if (!model.activeCamera) {
        vtkErrorMacro5("Trying to reset clipping range of non-existent camera");
        return false;
      }
      const range = model.activeCamera.computeClippingRange(boundsToUse);
      let minGap = 0;
      if (model.activeCamera.getParallelProjection()) {
        minGap = 0.2 * model.activeCamera.getParallelScale();
      } else {
        const angle2 = radiansFromDegrees(model.activeCamera.getViewAngle());
        minGap = 0.2 * Math.tan(angle2 / 2) * range[1];
      }
      if (range[1] - range[0] < minGap) {
        minGap = minGap - range[1] + range[0];
        range[1] += minGap / 2;
        range[0] -= minGap / 2;
      }
      if (range[0] < 0) {
        range[0] = 0;
      }
      range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
      range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;
      range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];
      if (!model.nearClippingPlaneTolerance) {
        model.nearClippingPlaneTolerance = 0.01;
      }
      if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
        range[0] = model.nearClippingPlaneTolerance * range[1];
      }
      model.activeCamera.setClippingRange(range[0], range[1]);
      publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
      return false;
    };
    publicAPI.setRenderWindow = (renderWindow) => {
      if (renderWindow !== model._renderWindow) {
        model._vtkWindow = renderWindow;
        model._renderWindow = renderWindow;
      }
    };
    publicAPI.visibleActorCount = () => model.props.filter((prop) => prop.getVisibility()).length;
    publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;
    publicAPI.getMTime = () => {
      let m1 = model.mtime;
      const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;
      if (m2 > m1) {
        m1 = m2;
      }
      const m3 = model._createdLight ? model._createdLight.getMTime() : 0;
      if (m3 > m1) {
        m1 = m3;
      }
      return m1;
    };
    publicAPI.getTransparent = () => !!model.preserveColorBuffer;
    publicAPI.isActiveCameraCreated = () => !!model.activeCamera;
  }
  var DEFAULT_VALUES6 = {
    pickedProp: null,
    activeCamera: null,
    allBounds: [],
    ambient: [1, 1, 1],
    allocatedRenderTime: 100,
    timeFactor: 1,
    automaticLightCreation: true,
    twoSidedLighting: true,
    lastRenderTimeInSeconds: -1,
    renderWindow: null,
    lights: [],
    actors: [],
    volumes: [],
    lightFollowCamera: true,
    numberOfPropsRendered: 0,
    propArray: null,
    pathArray: null,
    layer: 0,
    preserveColorBuffer: false,
    preserveDepthBuffer: false,
    computeVisiblePropBounds: createUninitializedBounds(),
    interactive: true,
    nearClippingPlaneTolerance: 0,
    clippingRangeExpansion: 0.05,
    erase: true,
    draw: true,
    useShadows: false,
    useDepthPeeling: false,
    occlusionRatio: 0,
    maximumNumberOfPeels: 4,
    selector: null,
    delegate: null,
    texturedBackground: false,
    backgroundTexture: null,
    environmentTexture: null,
    environmentTextureDiffuseStrength: 1,
    environmentTextureSpecularStrength: 1,
    useEnvironmentTextureAsBackground: false,
    pass: 0
  };
  function extend6(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES6, initialValues);
    vtkViewport$1.extend(publicAPI, model, initialValues);
    if (!model.background) model.background = [0, 0, 0, 1];
    while (model.background.length < 3) model.background.push(0);
    if (model.background.length === 3) model.background.push(1);
    get(publicAPI, model, ["_renderWindow", "allocatedRenderTime", "timeFactor", "lastRenderTimeInSeconds", "numberOfPropsRendered", "lastRenderingUsedDepthPeeling", "selector"]);
    setGet(publicAPI, model, ["twoSidedLighting", "lightFollowCamera", "automaticLightCreation", "erase", "draw", "nearClippingPlaneTolerance", "clippingRangeExpansion", "backingStore", "interactive", "layer", "preserveColorBuffer", "preserveDepthBuffer", "useDepthPeeling", "occlusionRatio", "maximumNumberOfPeels", "delegate", "backgroundTexture", "texturedBackground", "environmentTexture", "environmentTextureDiffuseStrength", "environmentTextureSpecularStrength", "useEnvironmentTextureAsBackground", "useShadows", "pass"]);
    getArray(publicAPI, model, ["actors", "volumes", "lights"]);
    setGetArray(publicAPI, model, ["background"], 4, 1);
    moveToProtected(publicAPI, model, ["renderWindow"]);
    vtkRenderer(publicAPI, model);
  }
  var newInstance8 = newInstance(extend6, "vtkRenderer");
  var vtkRenderer$1 = {
    newInstance: newInstance8,
    extend: extend6
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/RenderWindow.js
  var DEFAULT_VIEW_API = "WebGL";
  var VIEW_CONSTRUCTORS = /* @__PURE__ */ Object.create(null);
  function registerViewConstructor(name, constructor) {
    VIEW_CONSTRUCTORS[name] = constructor;
  }
  function listViewAPIs() {
    return Object.keys(VIEW_CONSTRUCTORS);
  }
  function newAPISpecificView(name) {
    let initialValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return VIEW_CONSTRUCTORS[name] && VIEW_CONSTRUCTORS[name](initialValues);
  }
  function vtkRenderWindow(publicAPI, model) {
    model.classHierarchy.push("vtkRenderWindow");
    publicAPI.addRenderer = (renderer) => {
      if (publicAPI.hasRenderer(renderer)) {
        return;
      }
      renderer.setRenderWindow(publicAPI);
      model.renderers.push(renderer);
      publicAPI.modified();
    };
    publicAPI.removeRenderer = (renderer) => {
      model.renderers = model.renderers.filter((r) => r !== renderer);
      publicAPI.modified();
    };
    publicAPI.hasRenderer = (ren) => model.renderers.indexOf(ren) !== -1;
    publicAPI.newAPISpecificView = function(name) {
      let initialValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return newAPISpecificView(name || model.defaultViewAPI, initialValues);
    };
    publicAPI.addView = (view) => {
      if (publicAPI.hasView(view)) {
        return;
      }
      view.setRenderable(publicAPI);
      model._views.push(view);
      publicAPI.modified();
    };
    publicAPI.removeView = (view) => {
      model._views = model._views.filter((r) => r !== view);
      publicAPI.modified();
    };
    publicAPI.hasView = (view) => model._views.indexOf(view) !== -1;
    publicAPI.preRender = () => {
      model.renderers.forEach((ren) => {
        if (!ren.isActiveCameraCreated()) {
          ren.resetCamera();
        }
      });
    };
    publicAPI.render = () => {
      publicAPI.preRender();
      if (model.interactor) {
        model.interactor.render();
      } else {
        model._views.forEach((view) => view.traverseAllPasses());
      }
    };
    publicAPI.getStatistics = () => {
      const results = {
        propCount: 0,
        invisiblePropCount: 0,
        gpuMemoryMB: 0
      };
      model._views.forEach((v) => {
        if (v.getGraphicsMemoryInfo) results.gpuMemoryMB += v.getGraphicsMemoryInfo() / 1e6;
      });
      model.renderers.forEach((ren) => {
        const props = ren.getViewProps();
        const gren = model._views[0].getViewNodeFor(ren);
        props.forEach((prop) => {
          if (prop.getVisibility()) {
            results.propCount += 1;
            const mpr = prop.getMapper && prop.getMapper();
            if (mpr && mpr.getPrimitiveCount) {
              const gmpr = gren.getViewNodeFor(mpr);
              if (gmpr) {
                if (gmpr.getAllocatedGPUMemoryInBytes) {
                  results.gpuMemoryMB += gmpr.getAllocatedGPUMemoryInBytes() / 1e6;
                }
                const pcount = mpr.getPrimitiveCount();
                Object.keys(pcount).forEach((keyName) => {
                  if (!results[keyName]) {
                    results[keyName] = 0;
                  }
                  results[keyName] += pcount[keyName];
                });
              }
            }
          } else {
            results.invisiblePropCount += 1;
          }
        });
      });
      results.str = Object.keys(results).map((keyName) => `${keyName}: ${results[keyName]}`).join("\n");
      return results;
    };
    publicAPI.captureImages = function() {
      let format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      macro.setImmediate(publicAPI.render);
      return model._views.map((view) => view.captureNextImage ? view.captureNextImage(format2, opts) : void 0).filter((i) => !!i);
    };
    publicAPI.addRenderWindow = (child) => {
      if (model.childRenderWindows.includes(child)) {
        return false;
      }
      model.childRenderWindows.push(child);
      publicAPI.modified();
      return true;
    };
    publicAPI.removeRenderWindow = (child) => {
      const childIndex = model.childRenderWindows.findIndex((x) => x === child);
      if (childIndex < 0) {
        return false;
      }
      model.childRenderWindows.splice(childIndex, 1);
      publicAPI.modified();
      return true;
    };
  }
  var DEFAULT_VALUES7 = {
    defaultViewAPI: DEFAULT_VIEW_API,
    renderers: [],
    views: [],
    interactor: null,
    neverRendered: true,
    numberOfLayers: 1,
    childRenderWindows: []
  };
  function extend7(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES7, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["interactor", "numberOfLayers", "_views", "defaultViewAPI"]);
    macro.get(publicAPI, model, ["neverRendered"]);
    macro.getArray(publicAPI, model, ["renderers", "childRenderWindows"]);
    macro.moveToProtected(publicAPI, model, ["views"]);
    macro.event(publicAPI, model, "completion");
    vtkRenderWindow(publicAPI, model);
  }
  var newInstance9 = macro.newInstance(extend7, "vtkRenderWindow");
  var vtkRenderWindow$1 = {
    newInstance: newInstance9,
    extend: extend7,
    registerViewConstructor,
    listViewAPIs,
    newAPISpecificView
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor/Constants.js
  var Device = {
    Unknown: 0,
    LeftController: 1,
    RightController: 2
  };
  var Input = {
    Unknown: 0,
    Trigger: 1,
    TrackPad: 2,
    Grip: 3,
    Thumbstick: 4,
    A: 5,
    B: 6,
    ApplicationMenu: 7
    // Not exposed in WebXR API
  };
  var Axis = {
    Unknown: 0,
    TouchpadX: 1,
    TouchpadY: 2,
    ThumbstickX: 3,
    ThumbstickY: 4
  };
  var MouseButton = {
    LeftButton: 1,
    MiddleButton: 2,
    RightButton: 3
  };
  var Constants = {
    Device,
    Input,
    Axis,
    MouseButton
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor.js
  var {
    Device: Device2,
    Input: Input2
  } = Constants;
  var {
    vtkWarningMacro: vtkWarningMacro4,
    vtkErrorMacro: vtkErrorMacro6,
    normalizeWheel: normalizeWheel2,
    vtkOnceErrorMacro: vtkOnceErrorMacro2
  } = macro;
  var EMPTY_MOUSE_EVENT = {
    ctrlKey: false,
    altKey: false,
    shiftKey: false
  };
  var deviceInputMap = {
    "xr-standard": [Input2.Trigger, Input2.Grip, Input2.TrackPad, Input2.Thumbstick, Input2.A, Input2.B]
  };
  var handledEvents = ["StartAnimation", "Animation", "EndAnimation", "PointerEnter", "PointerLeave", "MouseEnter", "MouseLeave", "StartMouseMove", "MouseMove", "EndMouseMove", "LeftButtonPress", "LeftButtonRelease", "MiddleButtonPress", "MiddleButtonRelease", "RightButtonPress", "RightButtonRelease", "KeyPress", "KeyDown", "KeyUp", "StartMouseWheel", "MouseWheel", "EndMouseWheel", "StartPinch", "Pinch", "EndPinch", "StartPan", "Pan", "EndPan", "StartRotate", "Rotate", "EndRotate", "Button3D", "Move3D", "StartPointerLock", "EndPointerLock", "StartInteraction", "Interaction", "EndInteraction", "AnimationFrameRateUpdate"];
  function preventDefault(event2) {
    if (event2.cancelable) {
      event2.preventDefault();
    }
  }
  function pointerCacheToPositions(cache) {
    const positions = /* @__PURE__ */ Object.create(null);
    cache.forEach((_ref) => {
      let {
        pointerId,
        position
      } = _ref;
      positions[pointerId] = position;
    });
    return positions;
  }
  function vtkRenderWindowInteractor(publicAPI, model) {
    model.classHierarchy.push("vtkRenderWindowInteractor");
    const superClass = {
      ...publicAPI
    };
    const animationRequesters = /* @__PURE__ */ new Set();
    const pointerCache = /* @__PURE__ */ new Map();
    let wheelCoefficient = 1;
    publicAPI.start = () => {
      if (!model.initialized) {
        publicAPI.initialize();
        if (!model.initialized) {
          return;
        }
      }
      publicAPI.startEventLoop();
    };
    publicAPI.setRenderWindow = (aren) => {
      vtkErrorMacro6("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor");
    };
    publicAPI.setInteractorStyle = (style) => {
      if (model.interactorStyle !== style) {
        if (model.interactorStyle != null) {
          model.interactorStyle.setInteractor(null);
        }
        model.interactorStyle = style;
        if (model.interactorStyle != null) {
          if (model.interactorStyle.getInteractor() !== publicAPI) {
            model.interactorStyle.setInteractor(publicAPI);
          }
        }
      }
    };
    publicAPI.initialize = () => {
      model.initialized = true;
      publicAPI.enable();
      publicAPI.render();
    };
    publicAPI.enable = () => publicAPI.setEnabled(true);
    publicAPI.disable = () => publicAPI.setEnabled(false);
    publicAPI.startEventLoop = () => vtkWarningMacro4("empty event loop");
    function updateCurrentRenderer(x, y) {
      if (!model._forcedRenderer) {
        model.currentRenderer = publicAPI.findPokedRenderer(x, y);
      }
    }
    publicAPI.getCurrentRenderer = () => {
      if (model.currentRenderer) {
        return model.currentRenderer;
      }
      updateCurrentRenderer(0, 0);
      return model.currentRenderer;
    };
    function _getScreenEventPositionFor(source) {
      const canvas = model._view.getCanvas();
      const bounds = canvas.getBoundingClientRect();
      const scaleX = canvas.width / bounds.width;
      const scaleY = canvas.height / bounds.height;
      const position = {
        x: scaleX * (source.clientX - bounds.left),
        y: scaleY * (bounds.height - source.clientY + bounds.top),
        z: 0,
        movementX: scaleX * source.movementX,
        movementY: scaleY * source.movementY
      };
      if (pointerCache.size <= 1 || !model.currentRenderer) {
        updateCurrentRenderer(position.x, position.y);
      }
      return position;
    }
    const getScreenEventPositionFor = model._getScreenEventPositionFor || _getScreenEventPositionFor;
    function getModifierKeysFor(event2) {
      return {
        controlKey: event2.ctrlKey,
        altKey: event2.altKey,
        shiftKey: event2.shiftKey
      };
    }
    function getKeysFor(event2) {
      const modifierKeys = getModifierKeysFor(event2);
      const keys = {
        key: event2.key,
        keyCode: event2.charCode,
        ...modifierKeys
      };
      return keys;
    }
    function getDeviceTypeFor(event2) {
      return event2.pointerType || "";
    }
    const _bindEvents = () => {
      if (model.container === null) {
        return;
      }
      const {
        container
      } = model;
      container.addEventListener("contextmenu", preventDefault);
      container.addEventListener("wheel", publicAPI.handleWheel);
      container.addEventListener("DOMMouseScroll", publicAPI.handleWheel);
      container.addEventListener("pointerenter", publicAPI.handlePointerEnter);
      container.addEventListener("pointerleave", publicAPI.handlePointerLeave);
      container.addEventListener("pointermove", publicAPI.handlePointerMove, {
        passive: false
      });
      container.addEventListener("pointerdown", publicAPI.handlePointerDown, {
        passive: false
      });
      container.addEventListener("pointerup", publicAPI.handlePointerUp);
      container.addEventListener("pointercancel", publicAPI.handlePointerCancel);
      container.addEventListener("keypress", publicAPI.handleKeyPress);
      container.addEventListener("keydown", publicAPI.handleKeyDown);
      document.addEventListener("keyup", publicAPI.handleKeyUp);
      document.addEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
      container.tabIndex = 0;
      container.style.touchAction = "none";
      container.style.userSelect = "none";
      container.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
    };
    publicAPI.bindEvents = (container) => {
      if (container === null) {
        return;
      }
      const res = superClass.setContainer(container);
      if (res) {
        _bindEvents();
      }
    };
    const _unbindEvents = () => {
      clearTimeout(model.moveTimeoutID);
      clearTimeout(model.wheelTimeoutID);
      model.moveTimeoutID = 0;
      model.wheelTimeoutID = 0;
      wheelCoefficient = 1;
      const {
        container
      } = model;
      if (container) {
        container.removeEventListener("contextmenu", preventDefault);
        container.removeEventListener("wheel", publicAPI.handleWheel);
        container.removeEventListener("DOMMouseScroll", publicAPI.handleWheel);
        container.removeEventListener("pointerenter", publicAPI.handlePointerEnter);
        container.removeEventListener("pointerleave", publicAPI.handlePointerLeave);
        container.removeEventListener("pointermove", publicAPI.handlePointerMove, {
          passive: false
        });
        container.removeEventListener("pointerdown", publicAPI.handlePointerDown, {
          passive: false
        });
        container.removeEventListener("pointerup", publicAPI.handlePointerUp);
        container.removeEventListener("pointercancel", publicAPI.handlePointerCancel);
        container.removeEventListener("keypress", publicAPI.handleKeyPress);
        container.removeEventListener("keydown", publicAPI.handleKeyDown);
      }
      document.removeEventListener("keyup", publicAPI.handleKeyUp);
      document.removeEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
      pointerCache.clear();
    };
    publicAPI.unbindEvents = () => {
      _unbindEvents();
      superClass.setContainer(null);
    };
    publicAPI.handleKeyPress = (event2) => {
      const data = getKeysFor(event2);
      publicAPI.keyPressEvent(data);
    };
    publicAPI.handleKeyDown = (event2) => {
      const data = getKeysFor(event2);
      publicAPI.keyDownEvent(data);
    };
    publicAPI.handleKeyUp = (event2) => {
      const data = getKeysFor(event2);
      publicAPI.keyUpEvent(data);
    };
    publicAPI.handlePointerEnter = (event2) => {
      const callData = {
        ...getModifierKeysFor(event2),
        position: getScreenEventPositionFor(event2),
        deviceType: getDeviceTypeFor(event2)
      };
      publicAPI.pointerEnterEvent(callData);
      if (callData.deviceType === "mouse") {
        publicAPI.mouseEnterEvent(callData);
      }
    };
    publicAPI.handlePointerLeave = (event2) => {
      const callData = {
        ...getModifierKeysFor(event2),
        position: getScreenEventPositionFor(event2),
        deviceType: getDeviceTypeFor(event2)
      };
      publicAPI.pointerLeaveEvent(callData);
      if (callData.deviceType === "mouse") {
        publicAPI.mouseLeaveEvent(callData);
      }
    };
    publicAPI.handlePointerDown = (event2) => {
      if (event2.button > 2 || publicAPI.isPointerLocked()) {
        return;
      }
      if (model.preventDefaultOnPointerDown) {
        preventDefault(event2);
      }
      if (event2.target.hasPointerCapture(event2.pointerId)) {
        event2.target.releasePointerCapture(event2.pointerId);
      }
      model.container.setPointerCapture(event2.pointerId);
      if (pointerCache.has(event2.pointerId)) {
        vtkWarningMacro4("[RenderWindowInteractor] duplicate pointerId detected");
      }
      pointerCache.set(event2.pointerId, {
        pointerId: event2.pointerId,
        position: getScreenEventPositionFor(event2)
      });
      switch (event2.pointerType) {
        case "pen":
        case "touch":
          publicAPI.handleTouchStart(event2);
          break;
        case "mouse":
        default:
          publicAPI.handleMouseDown(event2);
          break;
      }
    };
    publicAPI.handlePointerUp = (event2) => {
      if (pointerCache.has(event2.pointerId)) {
        if (model.preventDefaultOnPointerUp) {
          preventDefault(event2);
        }
        pointerCache.delete(event2.pointerId);
        model.container.releasePointerCapture(event2.pointerId);
        switch (event2.pointerType) {
          case "pen":
          case "touch":
            publicAPI.handleTouchEnd(event2);
            break;
          case "mouse":
          default:
            publicAPI.handleMouseUp(event2);
            break;
        }
      }
    };
    publicAPI.handlePointerCancel = (event2) => {
      if (pointerCache.has(event2.pointerId)) {
        pointerCache.delete(event2.pointerId);
        switch (event2.pointerType) {
          case "pen":
          case "touch":
            publicAPI.handleTouchEnd(event2);
            break;
          case "mouse":
          default:
            publicAPI.handleMouseUp(event2);
            break;
        }
      }
    };
    publicAPI.handlePointerMove = (event2) => {
      if (pointerCache.has(event2.pointerId)) {
        const pointer = pointerCache.get(event2.pointerId);
        pointer.position = getScreenEventPositionFor(event2);
      }
      switch (event2.pointerType) {
        case "pen":
        case "touch":
          publicAPI.handleTouchMove(event2);
          break;
        case "mouse":
        default:
          publicAPI.handleMouseMove(event2);
          break;
      }
    };
    publicAPI.handleMouseDown = (event2) => {
      const callData = {
        ...getModifierKeysFor(event2),
        position: getScreenEventPositionFor(event2),
        deviceType: getDeviceTypeFor(event2)
      };
      switch (event2.button) {
        case 0:
          publicAPI.leftButtonPressEvent(callData);
          break;
        case 1:
          publicAPI.middleButtonPressEvent(callData);
          break;
        case 2:
          publicAPI.rightButtonPressEvent(callData);
          break;
        default:
          vtkErrorMacro6(`Unknown mouse button pressed: ${event2.button}`);
          break;
      }
    };
    publicAPI.requestPointerLock = () => {
      if (model.container) {
        model.container.requestPointerLock();
      }
    };
    publicAPI.exitPointerLock = () => document.exitPointerLock?.();
    publicAPI.isPointerLocked = () => !!model.container && document.pointerLockElement === model.container;
    publicAPI.handlePointerLockChange = () => {
      if (publicAPI.isPointerLocked()) {
        publicAPI.startPointerLockEvent();
      } else {
        publicAPI.endPointerLockEvent();
      }
    };
    function forceRender() {
      if (model._view && model.enabled && model.enableRender) {
        model.inRender = true;
        model._view.traverseAllPasses();
        model.inRender = false;
      }
      publicAPI.invokeRenderEvent();
    }
    publicAPI.requestAnimation = (requestor) => {
      if (requestor === void 0) {
        vtkErrorMacro6(`undefined requester, can not start animating`);
        return;
      }
      if (animationRequesters.has(requestor)) {
        vtkWarningMacro4(`requester is already registered for animating`);
        return;
      }
      animationRequesters.add(requestor);
      if (!model.animationRequest && animationRequesters.size === 1 && !model.xrAnimation) {
        model._animationStartTime = Date.now();
        model._animationFrameCount = 0;
        model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
        publicAPI.startAnimationEvent();
      }
    };
    publicAPI.extendAnimation = (duration) => {
      const newEnd = Date.now() + duration;
      model._animationExtendedEnd = Math.max(model._animationExtendedEnd, newEnd);
      if (!model.animationRequest && animationRequesters.size === 0 && !model.xrAnimation) {
        model._animationStartTime = Date.now();
        model._animationFrameCount = 0;
        model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
        publicAPI.startAnimationEvent();
      }
    };
    publicAPI.isAnimating = () => model.xrAnimation || model.animationRequest !== null;
    publicAPI.cancelAnimation = function(requestor) {
      let skipWarning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!animationRequesters.has(requestor)) {
        if (!skipWarning) {
          const requestStr = requestor && requestor.getClassName ? requestor.getClassName() : requestor;
          vtkWarningMacro4(`${requestStr} did not request an animation`);
        }
        return;
      }
      animationRequesters.delete(requestor);
      if (model.animationRequest && animationRequesters.size === 0 && Date.now() > model._animationExtendedEnd) {
        cancelAnimationFrame(model.animationRequest);
        model.animationRequest = null;
        publicAPI.endAnimationEvent();
        publicAPI.render();
      }
    };
    publicAPI.switchToXRAnimation = () => {
      if (model.animationRequest) {
        cancelAnimationFrame(model.animationRequest);
        model.animationRequest = null;
      }
      model.xrAnimation = true;
    };
    publicAPI.returnFromXRAnimation = () => {
      model.xrAnimation = false;
      if (animationRequesters.size !== 0) {
        model.recentAnimationFrameRate = 10;
        model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      }
    };
    publicAPI.updateXRGamepads = (xrSession, xrFrame, xrRefSpace) => {
      xrSession.inputSources.forEach((inputSource) => {
        const gripPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.gripSpace, xrRefSpace);
        const targetRayPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.targetRaySpace, xrRefSpace);
        const gamepad = inputSource.gamepad;
        const hand = inputSource.handedness;
        if (!gamepad) {
          return;
        }
        if (!(gamepad.index in model.lastGamepadValues)) {
          model.lastGamepadValues[gamepad.index] = {
            left: {
              buttons: {}
            },
            right: {
              buttons: {}
            },
            none: {
              buttons: {}
            }
          };
        }
        for (let buttonIdx = 0; buttonIdx < gamepad.buttons.length; ++buttonIdx) {
          if (!(buttonIdx in model.lastGamepadValues[gamepad.index][hand].buttons)) {
            model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = false;
          }
          if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] !== gamepad.buttons[buttonIdx].pressed && gripPose != null) {
            publicAPI.button3DEvent({
              gamepad,
              position: gripPose.transform.position,
              orientation: gripPose.transform.orientation,
              targetPosition: targetRayPose.transform.position,
              targetOrientation: targetRayPose.transform.orientation,
              pressed: gamepad.buttons[buttonIdx].pressed,
              device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController,
              input: deviceInputMap[gamepad.mapping] && deviceInputMap[gamepad.mapping][buttonIdx] ? deviceInputMap[gamepad.mapping][buttonIdx] : Input2.Trigger
            });
            model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = gamepad.buttons[buttonIdx].pressed;
          }
          if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] && gripPose != null) {
            publicAPI.move3DEvent({
              gamepad,
              position: gripPose.transform.position,
              orientation: gripPose.transform.orientation,
              targetPosition: targetRayPose.transform.position,
              targetOrientation: targetRayPose.transform.orientation,
              device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController
            });
          }
        }
      });
    };
    publicAPI.handleMouseMove = (event2) => {
      const callData = {
        ...getModifierKeysFor(event2),
        position: getScreenEventPositionFor(event2),
        deviceType: getDeviceTypeFor(event2)
      };
      if (model.moveTimeoutID === 0) {
        publicAPI.startMouseMoveEvent(callData);
      } else {
        publicAPI.mouseMoveEvent(callData);
        clearTimeout(model.moveTimeoutID);
      }
      model.moveTimeoutID = setTimeout(() => {
        publicAPI.endMouseMoveEvent();
        model.moveTimeoutID = 0;
      }, 200);
    };
    publicAPI.handleAnimation = () => {
      const currTime = Date.now();
      model._animationFrameCount++;
      if (currTime - model._animationStartTime > 1e3 && model._animationFrameCount > 1) {
        model.recentAnimationFrameRate = 1e3 * (model._animationFrameCount - 1) / (currTime - model._animationStartTime);
        model.lastFrameTime = 1 / model.recentAnimationFrameRate;
        publicAPI.animationFrameRateUpdateEvent();
        model._animationStartTime = currTime;
        model._animationFrameCount = 1;
      }
      publicAPI.animationEvent();
      forceRender();
      if (animationRequesters.size > 0 || Date.now() < model._animationExtendedEnd) {
        model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      } else {
        cancelAnimationFrame(model.animationRequest);
        model.animationRequest = null;
        publicAPI.endAnimationEvent();
        publicAPI.render();
      }
    };
    publicAPI.handleWheel = (event2) => {
      preventDefault(event2);
      const callData = {
        ...normalizeWheel2(event2),
        ...getModifierKeysFor(event2),
        position: getScreenEventPositionFor(event2),
        deviceType: getDeviceTypeFor(event2)
      };
      if (model.wheelTimeoutID === 0) {
        if (Math.abs(callData.spinY) >= 0.3) {
          wheelCoefficient = Math.abs(callData.spinY);
        } else {
          wheelCoefficient = 1;
        }
      }
      callData.spinY /= wheelCoefficient;
      if (model.wheelTimeoutID === 0) {
        publicAPI.startMouseWheelEvent(callData);
        publicAPI.mouseWheelEvent(callData);
      } else {
        publicAPI.mouseWheelEvent(callData);
        clearTimeout(model.wheelTimeoutID);
      }
      if (model.mouseScrollDebounceByPass) {
        publicAPI.extendAnimation(600);
        publicAPI.endMouseWheelEvent();
        model.wheelTimeoutID = 0;
      } else {
        model.wheelTimeoutID = setTimeout(() => {
          publicAPI.extendAnimation(600);
          publicAPI.endMouseWheelEvent();
          model.wheelTimeoutID = 0;
        }, 200);
      }
    };
    publicAPI.handleMouseUp = (event2) => {
      const callData = {
        ...getModifierKeysFor(event2),
        position: getScreenEventPositionFor(event2),
        deviceType: getDeviceTypeFor(event2)
      };
      switch (event2.button) {
        case 0:
          publicAPI.leftButtonReleaseEvent(callData);
          break;
        case 1:
          publicAPI.middleButtonReleaseEvent(callData);
          break;
        case 2:
          publicAPI.rightButtonReleaseEvent(callData);
          break;
        default:
          vtkErrorMacro6(`Unknown mouse button released: ${event2.button}`);
          break;
      }
    };
    publicAPI.handleTouchStart = (event2) => {
      const pointers = [...pointerCache.values()];
      if (model.recognizeGestures && pointers.length > 1) {
        const positions = pointerCacheToPositions(pointerCache);
        if (pointers.length === 2) {
          const callData = {
            ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
            position: pointers[0].position,
            deviceType: getDeviceTypeFor(event2)
          };
          publicAPI.leftButtonReleaseEvent(callData);
        }
        publicAPI.recognizeGesture("TouchStart", positions);
      } else if (pointers.length === 1) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: getScreenEventPositionFor(event2),
          deviceType: getDeviceTypeFor(event2)
        };
        publicAPI.leftButtonPressEvent(callData);
      }
    };
    publicAPI.handleTouchMove = (event2) => {
      const pointers = [...pointerCache.values()];
      if (model.recognizeGestures && pointers.length > 1) {
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture("TouchMove", positions);
      } else if (pointers.length === 1) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event2)
        };
        publicAPI.mouseMoveEvent(callData);
      }
    };
    publicAPI.handleTouchEnd = (event2) => {
      const pointers = [...pointerCache.values()];
      if (model.recognizeGestures) {
        if (pointers.length === 0) {
          const callData = {
            ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
            position: getScreenEventPositionFor(event2),
            deviceType: getDeviceTypeFor(event2)
          };
          publicAPI.leftButtonReleaseEvent(callData);
        } else if (pointers.length === 1) {
          const positions = pointerCacheToPositions(pointerCache);
          publicAPI.recognizeGesture("TouchEnd", positions);
          const callData = {
            ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
            position: pointers[0].position,
            deviceType: getDeviceTypeFor(event2)
          };
          publicAPI.leftButtonPressEvent(callData);
        } else {
          const positions = pointerCacheToPositions(pointerCache);
          publicAPI.recognizeGesture("TouchMove", positions);
        }
      } else if (pointers.length === 1) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event2)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      }
    };
    publicAPI.setView = (val) => {
      if (model._view === val) {
        return;
      }
      model._view = val;
      model._view.getRenderable().setInteractor(publicAPI);
      publicAPI.modified();
    };
    publicAPI.getFirstRenderer = () => model._view?.getRenderable()?.getRenderersByReference()?.[0];
    publicAPI.findPokedRenderer = function() {
      let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (!model._view) {
        return null;
      }
      const rc = model._view?.getRenderable()?.getRenderers();
      if (!rc || rc.length === 0) {
        return null;
      }
      rc.sort((a, b) => a.getLayer() - b.getLayer());
      let interactiveren = null;
      let viewportren = null;
      let currentRenderer = null;
      let count = rc.length;
      while (count--) {
        const aren = rc[count];
        if (model._view.isInViewport(x, y, aren) && aren.getInteractive()) {
          currentRenderer = aren;
          break;
        }
        if (interactiveren === null && aren.getInteractive()) {
          interactiveren = aren;
        }
        if (viewportren === null && model._view.isInViewport(x, y, aren)) {
          viewportren = aren;
        }
      }
      if (currentRenderer === null) {
        currentRenderer = interactiveren;
      }
      if (currentRenderer === null) {
        currentRenderer = viewportren;
      }
      if (currentRenderer == null) {
        currentRenderer = rc[0];
      }
      return currentRenderer;
    };
    publicAPI.render = () => {
      if (!publicAPI.isAnimating() && !model.inRender) {
        forceRender();
      }
    };
    handledEvents.forEach((eventName) => {
      const lowerFirst = eventName.charAt(0).toLowerCase() + eventName.slice(1);
      publicAPI[`${lowerFirst}Event`] = (arg) => {
        if (!model.enabled) {
          return;
        }
        const renderer = publicAPI.getCurrentRenderer();
        if (!renderer) {
          vtkOnceErrorMacro2(`
          Can not forward events without a current renderer on the interactor.
        `);
          return;
        }
        const callData = {
          type: eventName,
          pokedRenderer: model.currentRenderer,
          firstRenderer: publicAPI.getFirstRenderer(),
          // Add the arguments to the call data
          ...arg
        };
        publicAPI[`invoke${eventName}`](callData);
      };
    });
    publicAPI.recognizeGesture = (event2, positions) => {
      if (Object.keys(positions).length > 2) {
        return;
      }
      if (!model.startingEventPositions) {
        model.startingEventPositions = {};
      }
      if (event2 === "TouchStart") {
        Object.keys(positions).forEach((key) => {
          model.startingEventPositions[key] = positions[key];
        });
        model.currentGesture = "Start";
        return;
      }
      if (event2 === "TouchEnd") {
        if (model.currentGesture === "Pinch") {
          publicAPI.render();
          publicAPI.endPinchEvent();
        }
        if (model.currentGesture === "Rotate") {
          publicAPI.render();
          publicAPI.endRotateEvent();
        }
        if (model.currentGesture === "Pan") {
          publicAPI.render();
          publicAPI.endPanEvent();
        }
        model.currentGesture = "Start";
        model.startingEventPositions = {};
        return;
      }
      let count = 0;
      const posVals = [];
      const startVals = [];
      Object.keys(positions).forEach((key) => {
        posVals[count] = positions[key];
        startVals[count] = model.startingEventPositions[key];
        count++;
      });
      const originalDistance = Math.sqrt((startVals[0].x - startVals[1].x) * (startVals[0].x - startVals[1].x) + (startVals[0].y - startVals[1].y) * (startVals[0].y - startVals[1].y));
      const newDistance = Math.sqrt((posVals[0].x - posVals[1].x) * (posVals[0].x - posVals[1].x) + (posVals[0].y - posVals[1].y) * (posVals[0].y - posVals[1].y));
      let originalAngle = degreesFromRadians(Math.atan2(startVals[1].y - startVals[0].y, startVals[1].x - startVals[0].x));
      let newAngle = degreesFromRadians(Math.atan2(posVals[1].y - posVals[0].y, posVals[1].x - posVals[0].x));
      let angleDeviation = newAngle - originalAngle;
      newAngle = newAngle + 180 >= 360 ? newAngle - 180 : newAngle + 180;
      originalAngle = originalAngle + 180 >= 360 ? originalAngle - 180 : originalAngle + 180;
      if (Math.abs(newAngle - originalAngle) < Math.abs(angleDeviation)) {
        angleDeviation = newAngle - originalAngle;
      }
      const trans = [];
      trans[0] = (posVals[0].x - startVals[0].x + posVals[1].x - startVals[1].x) / 2;
      trans[1] = (posVals[0].y - startVals[0].y + posVals[1].y - startVals[1].y) / 2;
      if (event2 === "TouchMove") {
        if (model.currentGesture === "Start") {
          let thresh = 0.01 * Math.sqrt(model.container.clientWidth * model.container.clientWidth + model.container.clientHeight * model.container.clientHeight);
          if (thresh < 15) {
            thresh = 15;
          }
          const pinchDistance = Math.abs(newDistance - originalDistance);
          const rotateDistance = newDistance * 3.1415926 * Math.abs(angleDeviation) / 360;
          const panDistance = Math.sqrt(trans[0] * trans[0] + trans[1] * trans[1]);
          if (pinchDistance > thresh && pinchDistance > rotateDistance && pinchDistance > panDistance) {
            model.currentGesture = "Pinch";
            const callData = {
              scale: 1,
              touches: positions
            };
            publicAPI.startPinchEvent(callData);
          } else if (rotateDistance > thresh && rotateDistance > panDistance) {
            model.currentGesture = "Rotate";
            const callData = {
              rotation: 0,
              touches: positions
            };
            publicAPI.startRotateEvent(callData);
          } else if (panDistance > thresh) {
            model.currentGesture = "Pan";
            const callData = {
              translation: [0, 0],
              touches: positions
            };
            publicAPI.startPanEvent(callData);
          }
        } else {
          if (model.currentGesture === "Rotate") {
            const callData = {
              rotation: angleDeviation,
              touches: positions
            };
            publicAPI.rotateEvent(callData);
          }
          if (model.currentGesture === "Pinch") {
            const callData = {
              scale: newDistance / originalDistance,
              touches: positions
            };
            publicAPI.pinchEvent(callData);
          }
          if (model.currentGesture === "Pan") {
            const callData = {
              translation: trans,
              touches: positions
            };
            publicAPI.panEvent(callData);
          }
        }
      }
    };
    publicAPI.handleVisibilityChange = () => {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
    };
    publicAPI.setCurrentRenderer = (r) => {
      model._forcedRenderer = !!r;
      model.currentRenderer = r;
    };
    publicAPI.setContainer = (container) => {
      _unbindEvents();
      const res = superClass.setContainer(container ?? null);
      if (res) {
        _bindEvents();
      }
      return res;
    };
    publicAPI.delete = () => {
      while (animationRequesters.size) {
        publicAPI.cancelAnimation(animationRequesters.values().next().value);
      }
      if (typeof document.hidden !== "undefined") {
        document.removeEventListener("visibilitychange", publicAPI.handleVisibilityChange);
      }
      if (model.container) {
        publicAPI.setContainer(null);
      }
      superClass.delete();
    };
    if (typeof document.hidden !== "undefined") {
      document.addEventListener("visibilitychange", publicAPI.handleVisibilityChange, false);
    }
  }
  var DEFAULT_VALUES8 = {
    renderWindow: null,
    interactorStyle: null,
    picker: null,
    pickingManager: null,
    initialized: false,
    enabled: false,
    enableRender: true,
    currentRenderer: null,
    lightFollowCamera: true,
    desiredUpdateRate: 30,
    stillUpdateRate: 2,
    container: null,
    // _view: null,
    recognizeGestures: true,
    currentGesture: "Start",
    animationRequest: null,
    lastFrameTime: 0.1,
    recentAnimationFrameRate: 10,
    wheelTimeoutID: 0,
    moveTimeoutID: 0,
    lastGamepadValues: {},
    preventDefaultOnPointerDown: false,
    preventDefaultOnPointerUp: false,
    mouseScrollDebounceByPass: false
  };
  function extend8(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES8, initialValues);
    macro.obj(publicAPI, model);
    model._animationExtendedEnd = 0;
    macro.event(publicAPI, model, "RenderEvent");
    handledEvents.forEach((eventName) => macro.event(publicAPI, model, eventName));
    macro.get(publicAPI, model, ["initialized", "interactorStyle", "lastFrameTime", "recentAnimationFrameRate", "_view"]);
    macro.setGet(publicAPI, model, ["container", "lightFollowCamera", "enabled", "enableRender", "recognizeGestures", "desiredUpdateRate", "stillUpdateRate", "picker", "preventDefaultOnPointerDown", "preventDefaultOnPointerUp", "mouseScrollDebounceByPass"]);
    macro.moveToProtected(publicAPI, model, ["view"]);
    vtkRenderWindowInteractor(publicAPI, model);
  }
  var newInstance10 = macro.newInstance(extend8, "vtkRenderWindowInteractor");
  var vtkRenderWindowInteractor$1 = {
    newInstance: newInstance10,
    extend: extend8,
    handledEvents,
    ...Constants
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/InteractorObserver.js
  var {
    vtkErrorMacro: vtkErrorMacro7,
    VOID: VOID2
  } = macro;
  function computeWorldToDisplay(renderer, x, y, z) {
    const view = renderer.getRenderWindow().getViews()[0];
    return view.worldToDisplay(x, y, z, renderer);
  }
  function computeDisplayToWorld(renderer, x, y, z) {
    const view = renderer.getRenderWindow().getViews()[0];
    return view.displayToWorld(x, y, z, renderer);
  }
  var STATIC3 = {
    computeWorldToDisplay,
    computeDisplayToWorld
  };
  function vtkInteractorObserver(publicAPI, model) {
    model.classHierarchy.push("vtkInteractorObserver");
    const superClass = {
      ...publicAPI
    };
    function unsubscribeFromEvents() {
      while (model.subscribedEvents.length) {
        model.subscribedEvents.pop().unsubscribe();
      }
    }
    function subscribeToEvents() {
      vtkRenderWindowInteractor$1.handledEvents.forEach((eventName) => {
        if (publicAPI[`handle${eventName}`]) {
          model.subscribedEvents.push(model._interactor[`on${eventName}`]((callData) => {
            if (model.processEvents) {
              return publicAPI[`handle${eventName}`](callData);
            }
            return VOID2;
          }, model.priority));
        }
      });
    }
    publicAPI.setInteractor = (i) => {
      if (i === model._interactor) {
        return;
      }
      unsubscribeFromEvents();
      model._interactor = i;
      if (i && model.enabled) {
        subscribeToEvents();
      }
      publicAPI.modified();
    };
    publicAPI.setEnabled = (enable) => {
      if (enable === model.enabled) {
        return;
      }
      unsubscribeFromEvents();
      if (enable) {
        if (model._interactor) {
          subscribeToEvents();
        } else {
          vtkErrorMacro7(`
          The interactor must be set before subscribing to events
        `);
        }
      }
      model.enabled = enable;
      publicAPI.modified();
    };
    publicAPI.computeDisplayToWorld = (renderer, x, y, z) => {
      if (!renderer) {
        return null;
      }
      return model._interactor.getView().displayToWorld(x, y, z, renderer);
    };
    publicAPI.computeWorldToDisplay = (renderer, x, y, z) => {
      if (!renderer) {
        return null;
      }
      return model._interactor.getView().worldToDisplay(x, y, z, renderer);
    };
    publicAPI.setPriority = (priority) => {
      const modified = superClass.setPriority(priority);
      if (modified && model._interactor) {
        unsubscribeFromEvents();
        subscribeToEvents();
      }
    };
  }
  var DEFAULT_VALUES9 = {
    enabled: true,
    // _interactor: null,
    priority: 0,
    processEvents: true,
    subscribedEvents: []
  };
  function extend9(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES9, initialValues);
    macro.obj(publicAPI, model);
    macro.event(publicAPI, model, "InteractionEvent");
    macro.event(publicAPI, model, "StartInteractionEvent");
    macro.event(publicAPI, model, "EndInteractionEvent");
    macro.get(publicAPI, model, ["_interactor", "enabled"]);
    macro.setGet(publicAPI, model, ["priority", "processEvents"]);
    macro.moveToProtected(publicAPI, model, ["interactor"]);
    vtkInteractorObserver(publicAPI, model);
  }
  var newInstance11 = macro.newInstance(extend9, "vtkInteractorObserver");
  var vtkInteractorObserver$1 = {
    newInstance: newInstance11,
    extend: extend9,
    ...STATIC3
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle/Constants.js
  var States = {
    IS_START: 0,
    IS_NONE: 0,
    IS_ROTATE: 1,
    IS_PAN: 2,
    IS_SPIN: 3,
    IS_DOLLY: 4,
    IS_CAMERA_POSE: 11,
    IS_WINDOW_LEVEL: 1024,
    IS_SLICE: 1025
  };
  var vtkInteractorStyleConstants = {
    States
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle.js
  var {
    States: States2
  } = vtkInteractorStyleConstants;
  var stateNames = {
    Rotate: States2.IS_ROTATE,
    Pan: States2.IS_PAN,
    Spin: States2.IS_SPIN,
    Dolly: States2.IS_DOLLY,
    CameraPose: States2.IS_CAMERA_POSE,
    WindowLevel: States2.IS_WINDOW_LEVEL,
    Slice: States2.IS_SLICE
  };
  function vtkInteractorStyle(publicAPI, model) {
    model.classHierarchy.push("vtkInteractorStyle");
    Object.keys(stateNames).forEach((key) => {
      macro.event(publicAPI, model, `Start${key}Event`);
      publicAPI[`start${key}`] = () => {
        if (model.state !== States2.IS_NONE) {
          return;
        }
        model.state = stateNames[key];
        model._interactor.requestAnimation(publicAPI);
        publicAPI.invokeStartInteractionEvent({
          type: "StartInteractionEvent"
        });
        publicAPI[`invokeStart${key}Event`]({
          type: `Start${key}Event`
        });
      };
      macro.event(publicAPI, model, `End${key}Event`);
      publicAPI[`end${key}`] = () => {
        if (model.state !== stateNames[key]) {
          return;
        }
        model.state = States2.IS_NONE;
        model._interactor.cancelAnimation(publicAPI);
        publicAPI.invokeEndInteractionEvent({
          type: "EndInteractionEvent"
        });
        publicAPI[`invokeEnd${key}Event`]({
          type: `End${key}Event`
        });
        model._interactor.render();
      };
    });
    model.getRenderer = (callData) => model.focusedRenderer || callData.pokedRenderer;
    publicAPI.handleKeyPress = (callData) => {
      const rwi = model._interactor;
      let ac = null;
      switch (callData.key) {
        case "r":
        case "R":
          model.getRenderer(callData).resetCamera();
          rwi.render();
          break;
        case "w":
        case "W":
          ac = model.getRenderer(callData).getActors();
          ac.forEach((anActor) => {
            const prop = anActor.getProperty();
            if (prop.setRepresentationToWireframe) {
              prop.setRepresentationToWireframe();
            }
          });
          rwi.render();
          break;
        case "s":
        case "S":
          ac = model.getRenderer(callData).getActors();
          ac.forEach((anActor) => {
            const prop = anActor.getProperty();
            if (prop.setRepresentationToSurface) {
              prop.setRepresentationToSurface();
            }
          });
          rwi.render();
          break;
        case "v":
        case "V":
          ac = model.getRenderer(callData).getActors();
          ac.forEach((anActor) => {
            const prop = anActor.getProperty();
            if (prop.setRepresentationToPoints) {
              prop.setRepresentationToPoints();
            }
          });
          rwi.render();
          break;
      }
    };
  }
  var DEFAULT_VALUES10 = {
    state: States2.IS_NONE,
    handleObservers: 1,
    autoAdjustCameraClippingRange: 1
  };
  function extend10(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES10, initialValues);
    vtkInteractorObserver$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["focusedRenderer"]);
    vtkInteractorStyle(publicAPI, model);
  }
  var newInstance12 = macro.newInstance(extend10, "vtkInteractorStyle");
  var vtkInteractorStyle$1 = {
    newInstance: newInstance12,
    extend: extend10,
    ...vtkInteractorStyleConstants
  };

  // node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleTrackballCamera.js
  var {
    States: States3
  } = vtkInteractorStyleConstants;
  function vtkInteractorStyleTrackballCamera(publicAPI, model) {
    model.classHierarchy.push("vtkInteractorStyleTrackballCamera");
    publicAPI.handleMouseMove = (callData) => {
      const pos = callData.position;
      const renderer = model.getRenderer(callData);
      switch (model.state) {
        case States3.IS_ROTATE:
          publicAPI.handleMouseRotate(renderer, pos);
          publicAPI.invokeInteractionEvent({
            type: "InteractionEvent"
          });
          break;
        case States3.IS_PAN:
          publicAPI.handleMousePan(renderer, pos);
          publicAPI.invokeInteractionEvent({
            type: "InteractionEvent"
          });
          break;
        case States3.IS_DOLLY:
          publicAPI.handleMouseDolly(renderer, pos);
          publicAPI.invokeInteractionEvent({
            type: "InteractionEvent"
          });
          break;
        case States3.IS_SPIN:
          publicAPI.handleMouseSpin(renderer, pos);
          publicAPI.invokeInteractionEvent({
            type: "InteractionEvent"
          });
          break;
      }
      model.previousPosition = pos;
    };
    publicAPI.handleButton3D = (ed) => {
      if (ed && ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad)) {
        publicAPI.startCameraPose();
        return;
      }
      if (ed && !ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad) && model.state === States3.IS_CAMERA_POSE) {
        publicAPI.endCameraPose();
      }
    };
    publicAPI.handleMove3D = (ed) => {
      switch (model.state) {
        case States3.IS_CAMERA_POSE:
          publicAPI.updateCameraPose(ed);
          break;
      }
    };
    publicAPI.updateCameraPose = (ed) => {
      const camera = model.getRenderer(ed).getActiveCamera();
      const oldTrans = camera.getPhysicalTranslation();
      const speed = 0.5;
      const pscale = speed * 0.05 * camera.getPhysicalScale();
      const dir = camera.physicalOrientationToWorldDirection([ed.orientation.x, ed.orientation.y, ed.orientation.z, ed.orientation.w]);
      camera.setPhysicalTranslation(oldTrans[0] + dir[0] * pscale, oldTrans[1] + dir[1] * pscale, oldTrans[2] + dir[2] * pscale);
    };
    publicAPI.handleLeftButtonPress = (callData) => {
      const pos = callData.position;
      model.previousPosition = pos;
      if (callData.shiftKey) {
        if (callData.controlKey || callData.altKey) {
          publicAPI.startDolly();
        } else {
          publicAPI.startPan();
        }
      } else {
        if (callData.controlKey || callData.altKey) {
          publicAPI.startSpin();
        } else {
          publicAPI.startRotate();
        }
      }
    };
    publicAPI.handleLeftButtonRelease = () => {
      switch (model.state) {
        case States3.IS_DOLLY:
          publicAPI.endDolly();
          break;
        case States3.IS_PAN:
          publicAPI.endPan();
          break;
        case States3.IS_SPIN:
          publicAPI.endSpin();
          break;
        case States3.IS_ROTATE:
          publicAPI.endRotate();
          break;
      }
    };
    publicAPI.handleStartMouseWheel = () => {
      publicAPI.startDolly();
    };
    publicAPI.handleEndMouseWheel = () => {
      publicAPI.endDolly();
    };
    publicAPI.handleStartPinch = (callData) => {
      model.previousScale = callData.scale;
      publicAPI.startDolly();
    };
    publicAPI.handleEndPinch = () => {
      publicAPI.endDolly();
    };
    publicAPI.handleStartRotate = (callData) => {
      model.previousRotation = callData.rotation;
      publicAPI.startRotate();
    };
    publicAPI.handleEndRotate = () => {
      publicAPI.endRotate();
    };
    publicAPI.handleStartPan = (callData) => {
      model.previousTranslation = callData.translation;
      publicAPI.startPan();
    };
    publicAPI.handleEndPan = () => {
      publicAPI.endPan();
    };
    publicAPI.handlePinch = (callData) => {
      publicAPI.dollyByFactor(model.getRenderer(callData), callData.scale / model.previousScale);
      model.previousScale = callData.scale;
    };
    publicAPI.handlePan = (callData) => {
      const camera = model.getRenderer(callData).getActiveCamera();
      let viewFocus = camera.getFocalPoint();
      viewFocus = publicAPI.computeWorldToDisplay(model.getRenderer(callData), viewFocus[0], viewFocus[1], viewFocus[2]);
      const focalDepth = viewFocus[2];
      const trans = callData.translation;
      const lastTrans = model.previousTranslation;
      const newPickPoint = publicAPI.computeDisplayToWorld(model.getRenderer(callData), viewFocus[0] + trans[0] - lastTrans[0], viewFocus[1] + trans[1] - lastTrans[1], focalDepth);
      const oldPickPoint = publicAPI.computeDisplayToWorld(model.getRenderer(callData), viewFocus[0], viewFocus[1], focalDepth);
      const motionVector = [];
      motionVector[0] = oldPickPoint[0] - newPickPoint[0];
      motionVector[1] = oldPickPoint[1] - newPickPoint[1];
      motionVector[2] = oldPickPoint[2] - newPickPoint[2];
      viewFocus = camera.getFocalPoint();
      const viewPoint = camera.getPosition();
      camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
      camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
      if (model._interactor.getLightFollowCamera()) {
        model.getRenderer(callData).updateLightsGeometryToFollowCamera();
      }
      camera.orthogonalizeViewUp();
      model.previousTranslation = callData.translation;
    };
    publicAPI.handleRotate = (callData) => {
      const camera = model.getRenderer(callData).getActiveCamera();
      camera.roll(callData.rotation - model.previousRotation);
      camera.orthogonalizeViewUp();
      model.previousRotation = callData.rotation;
    };
    publicAPI.handleMouseRotate = (renderer, position) => {
      if (!model.previousPosition) {
        return;
      }
      const rwi = model._interactor;
      const dx = position.x - model.previousPosition.x;
      const dy = position.y - model.previousPosition.y;
      const size = rwi.getView().getViewportSize(renderer);
      let deltaElevation = -0.1;
      let deltaAzimuth = -0.1;
      if (size[0] && size[1]) {
        deltaElevation = -20 / size[1];
        deltaAzimuth = -20 / size[0];
      }
      const rxf = dx * deltaAzimuth * model.motionFactor;
      const ryf = dy * deltaElevation * model.motionFactor;
      const camera = renderer.getActiveCamera();
      if (!Number.isNaN(rxf) && !Number.isNaN(ryf)) {
        camera.azimuth(rxf);
        camera.elevation(ryf);
        camera.orthogonalizeViewUp();
      }
      if (model.autoAdjustCameraClippingRange) {
        renderer.resetCameraClippingRange();
      }
      if (rwi.getLightFollowCamera()) {
        renderer.updateLightsGeometryToFollowCamera();
      }
    };
    publicAPI.handleMouseSpin = (renderer, position) => {
      if (!model.previousPosition) {
        return;
      }
      const rwi = model._interactor;
      const camera = renderer.getActiveCamera();
      const center = rwi.getView().getViewportCenter(renderer);
      const oldAngle = degreesFromRadians(Math.atan2(model.previousPosition.y - center[1], model.previousPosition.x - center[0]));
      const newAngle = degreesFromRadians(Math.atan2(position.y - center[1], position.x - center[0])) - oldAngle;
      if (!Number.isNaN(newAngle)) {
        camera.roll(newAngle);
        camera.orthogonalizeViewUp();
      }
    };
    publicAPI.handleMousePan = (renderer, position) => {
      if (!model.previousPosition) {
        return;
      }
      const camera = renderer.getActiveCamera();
      let viewFocus = camera.getFocalPoint();
      viewFocus = publicAPI.computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
      const focalDepth = viewFocus[2];
      const newPickPoint = publicAPI.computeDisplayToWorld(renderer, position.x, position.y, focalDepth);
      const oldPickPoint = publicAPI.computeDisplayToWorld(renderer, model.previousPosition.x, model.previousPosition.y, focalDepth);
      const motionVector = [];
      motionVector[0] = oldPickPoint[0] - newPickPoint[0];
      motionVector[1] = oldPickPoint[1] - newPickPoint[1];
      motionVector[2] = oldPickPoint[2] - newPickPoint[2];
      viewFocus = camera.getFocalPoint();
      const viewPoint = camera.getPosition();
      camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
      camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
      if (model._interactor.getLightFollowCamera()) {
        renderer.updateLightsGeometryToFollowCamera();
      }
    };
    publicAPI.handleMouseDolly = (renderer, position) => {
      if (!model.previousPosition) {
        return;
      }
      const dy = position.y - model.previousPosition.y;
      const rwi = model._interactor;
      const center = rwi.getView().getViewportCenter(renderer);
      const dyf = model.motionFactor * dy / center[1];
      publicAPI.dollyByFactor(renderer, 1.1 ** dyf);
    };
    publicAPI.handleMouseWheel = (callData) => {
      const dyf = 1 - callData.spinY / model.zoomFactor;
      publicAPI.dollyByFactor(model.getRenderer(callData), dyf);
    };
    publicAPI.dollyByFactor = (renderer, factor) => {
      if (Number.isNaN(factor)) {
        return;
      }
      const camera = renderer.getActiveCamera();
      if (camera.getParallelProjection()) {
        camera.setParallelScale(camera.getParallelScale() / factor);
      } else {
        camera.dolly(factor);
        if (model.autoAdjustCameraClippingRange) {
          renderer.resetCameraClippingRange();
        }
      }
      if (model._interactor.getLightFollowCamera()) {
        renderer.updateLightsGeometryToFollowCamera();
      }
    };
  }
  var DEFAULT_VALUES11 = {
    motionFactor: 10,
    zoomFactor: 10
  };
  function extend11(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES11, initialValues);
    vtkInteractorStyle$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["motionFactor", "zoomFactor"]);
    vtkInteractorStyleTrackballCamera(publicAPI, model);
  }
  var newInstance13 = macro.newInstance(extend11, "vtkInteractorStyleTrackballCamera");
  var vtkInteractorStyleTrackballCamera$1 = {
    newInstance: newInstance13,
    extend: extend11
  };

  // node_modules/@kitware/vtk.js/Common/Core/URLExtract.js
  function identity5(i) {
    return i;
  }
  function toNativeType(str6) {
    if (str6 === null || str6 === "null") {
      return null;
    }
    if (str6 === "true") {
      return true;
    }
    if (str6 === "false") {
      return false;
    }
    if (str6 === void 0 || str6 === "undefined") {
      return void 0;
    }
    if (str6[0] === "[" && str6[str6.length - 1] === "]") {
      return str6.substring(1, str6.length - 1).split(",").map((s) => toNativeType(s.trim()));
    }
    if (str6 === "" || Number.isNaN(Number(str6))) {
      return str6;
    }
    return Number(str6);
  }
  function extractURLParameters() {
    let castToNativeType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    let query = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window.location.search;
    const summary = {};
    const convert3 = castToNativeType ? toNativeType : identity5;
    const params = new URLSearchParams(query);
    params.forEach((value, key) => {
      if (key) {
        summary[key] = value ? convert3(value) : true;
      }
    });
    return summary;
  }
  var vtkURLExtract = {
    toNativeType,
    extractURLParameters
  };

  // node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
  var DataTypeByteSize = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
  };
  var VtkDataTypes = {
    VOID: "",
    // not sure to know what that should be
    CHAR: "Int8Array",
    SIGNED_CHAR: "Int8Array",
    UNSIGNED_CHAR: "Uint8Array",
    UNSIGNED_CHAR_CLAMPED: "Uint8ClampedArray",
    // should be used for VTK.js internal purpose only
    SHORT: "Int16Array",
    UNSIGNED_SHORT: "Uint16Array",
    INT: "Int32Array",
    UNSIGNED_INT: "Uint32Array",
    FLOAT: "Float32Array",
    DOUBLE: "Float64Array"
  };
  var DefaultDataType = VtkDataTypes.FLOAT;
  var Constants2 = {
    DefaultDataType,
    DataTypeByteSize,
    VtkDataTypes
  };

  // node_modules/@kitware/vtk.js/Common/Core/DataArray.js
  var {
    vtkErrorMacro: vtkErrorMacro8
  } = macro$1;
  var {
    DefaultDataType: DefaultDataType2
  } = Constants2;
  var EPSILON3 = 1e-6;
  function fastComputeRange(arr, offset, numberOfComponents) {
    const len4 = arr.length;
    let min4 = Number.MAX_VALUE;
    let max4 = -Number.MAX_VALUE;
    let x;
    let i;
    for (i = offset; i < len4; i += numberOfComponents) {
      if (!Number.isNaN(arr[i])) {
        min4 = arr[i];
        max4 = min4;
        break;
      }
    }
    for (; i < len4; i += numberOfComponents) {
      x = arr[i];
      if (x < min4) {
        min4 = x;
      } else if (x > max4) {
        max4 = x;
      }
    }
    return {
      min: min4,
      max: max4
    };
  }
  function createRangeHelper() {
    let min4 = Number.MAX_VALUE;
    let max4 = -Number.MAX_VALUE;
    let count = 0;
    let sum = 0;
    return {
      add(value) {
        if (min4 > value) {
          min4 = value;
        }
        if (max4 < value) {
          max4 = value;
        }
        count++;
        sum += value;
      },
      get() {
        return {
          min: min4,
          max: max4,
          count,
          sum,
          mean: sum / count
        };
      },
      getRange() {
        return {
          min: min4,
          max: max4
        };
      }
    };
  }
  function computeRange(values) {
    let component = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let numberOfComponents = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    if (component < 0 && numberOfComponents > 1) {
      const size = values.length;
      const numberOfValues = size / numberOfComponents;
      const data = new Float64Array(numberOfValues);
      for (let i = 0, j = 0; i < numberOfValues; ++i) {
        for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {
          data[i] += values[j] * values[j];
        }
        data[i] **= 0.5;
      }
      return fastComputeRange(data, 0, 1);
    }
    return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);
  }
  function ensureRangeSize(rangeArray) {
    let size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const ranges = rangeArray || [];
    while (ranges.length <= size) {
      ranges.push(null);
    }
    return ranges;
  }
  function getDataType(typedArray) {
    return Object.prototype.toString.call(typedArray).slice(8, -1);
  }
  function getMaxNorm(normArray) {
    const numComps = normArray.getNumberOfComponents();
    let maxNorm = 0;
    const tuple = new Array(numComps);
    for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {
      normArray.getTuple(i, tuple);
      const norm$1 = norm(tuple, numComps);
      if (norm$1 > maxNorm) {
        maxNorm = norm$1;
      }
    }
    return maxNorm;
  }
  var STATIC4 = {
    computeRange,
    createRangeHelper,
    fastComputeRange,
    getDataType,
    getMaxNorm
  };
  function vtkDataArray(publicAPI, model) {
    model.classHierarchy.push("vtkDataArray");
    function resize2(requestedNumTuples) {
      if (requestedNumTuples < 0) {
        return false;
      }
      const numComps = publicAPI.getNumberOfComponents();
      const numAllocatedTuples = model.values.length / (numComps > 0 ? numComps : 1);
      if (requestedNumTuples === numAllocatedTuples) {
        return true;
      }
      if (requestedNumTuples > numAllocatedTuples) {
        const oldValues = model.values;
        model.values = newTypedArray(model.dataType, (requestedNumTuples + numAllocatedTuples) * numComps);
        model.values.set(oldValues);
        return true;
      }
      if (model.size > requestedNumTuples * numComps) {
        model.size = requestedNumTuples * numComps;
        publicAPI.dataChange();
      }
      return true;
    }
    publicAPI.dataChange = () => {
      model.ranges = null;
      publicAPI.modified();
    };
    publicAPI.allocate = (extraNumTuples) => {
      resize2(publicAPI.getNumberOfTuples() + extraNumTuples);
    };
    publicAPI.resize = (requestedNumTuples) => {
      resize2(requestedNumTuples);
      const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();
      if (model.size !== newSize) {
        model.size = newSize;
        publicAPI.dataChange();
        return true;
      }
      return false;
    };
    publicAPI.initialize = () => {
      publicAPI.resize(0);
      return publicAPI;
    };
    publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;
    publicAPI.getComponent = function(tupleIdx) {
      let compIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return model.values[tupleIdx * model.numberOfComponents + compIdx];
    };
    publicAPI.setComponent = (tupleIdx, compIdx, value) => {
      if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
        model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
        publicAPI.dataChange();
      }
    };
    publicAPI.getValue = (valueIdx) => {
      const idx = valueIdx / model.numberOfComponents;
      const comp = valueIdx % model.numberOfComponents;
      return publicAPI.getComponent(idx, comp);
    };
    publicAPI.setValue = (valueIdx, value) => {
      const idx = valueIdx / model.numberOfComponents;
      const comp = valueIdx % model.numberOfComponents;
      publicAPI.setComponent(idx, comp, value);
    };
    publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);
    publicAPI.getRange = function() {
      let componentIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      let rangeIdx = componentIndex;
      if (rangeIdx < 0) {
        rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;
      }
      let range = null;
      if (!model.ranges) {
        model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
      }
      range = model.ranges[rangeIdx];
      if (range) {
        model.rangeTuple[0] = range.min;
        model.rangeTuple[1] = range.max;
        return model.rangeTuple;
      }
      range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);
      model.ranges[rangeIdx] = range;
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    };
    publicAPI.setRange = (rangeValue, componentIndex) => {
      if (!model.ranges) {
        model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
      }
      const range = {
        min: rangeValue.min,
        max: rangeValue.max
      };
      model.ranges[componentIndex] = range;
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    };
    publicAPI.getRanges = function() {
      let computeRanges = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!computeRanges) {
        return structuredClone(model.ranges);
      }
      const ranges = [];
      for (let i = 0; i < model.numberOfComponents; i++) {
        const [min4, max4] = publicAPI.getRange(i);
        const range = {
          min: min4,
          max: max4
        };
        ranges.push(range);
      }
      if (model.numberOfComponents > 1) {
        const [min4, max4] = publicAPI.getRange(-1);
        const range = {
          min: min4,
          max: max4
        };
        ranges.push(range);
      }
      return ranges;
    };
    publicAPI.setTuple = (idx, tuple) => {
      const offset = idx * model.numberOfComponents;
      for (let i = 0; i < model.numberOfComponents; i++) {
        model.values[offset + i] = tuple[i];
      }
    };
    publicAPI.setTuples = (idx, tuples) => {
      let i = idx * model.numberOfComponents;
      const last = Math.min(tuples.length, model.size - i);
      for (let j = 0; j < last; ) {
        model.values[i++] = tuples[j++];
      }
    };
    publicAPI.insertTuple = (idx, tuple) => {
      if (model.size <= idx * model.numberOfComponents) {
        model.size = (idx + 1) * model.numberOfComponents;
        resize2(idx + 1);
      }
      publicAPI.setTuple(idx, tuple);
      return idx;
    };
    publicAPI.insertTuples = (idx, tuples) => {
      const end = idx + tuples.length / model.numberOfComponents;
      if (model.size < end * model.numberOfComponents) {
        model.size = end * model.numberOfComponents;
        resize2(end);
      }
      publicAPI.setTuples(idx, tuples);
      return end;
    };
    publicAPI.insertNextTuple = (tuple) => {
      const idx = model.size / model.numberOfComponents;
      return publicAPI.insertTuple(idx, tuple);
    };
    publicAPI.insertNextTuples = (tuples) => {
      const idx = model.size / model.numberOfComponents;
      return publicAPI.insertTuples(idx, tuples);
    };
    publicAPI.findTuple = function(tuple) {
      let precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : EPSILON3;
      for (let i = 0; i < model.size; i += model.numberOfComponents) {
        if (Math.abs(tuple[0] - model.values[i]) <= precision) {
          let match = true;
          for (let j = 1; j < model.numberOfComponents; ++j) {
            if (Math.abs(tuple[j] - model.values[i + j]) > precision) {
              match = false;
              break;
            }
          }
          if (match) {
            return i / model.numberOfComponents;
          }
        }
      }
      return -1;
    };
    publicAPI.getTuple = function(idx) {
      let tupleToFill = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      const numberOfComponents = model.numberOfComponents || 1;
      const offset = idx * numberOfComponents;
      switch (numberOfComponents) {
        case 4:
          tupleToFill[3] = model.values[offset + 3];
        // eslint-disable-next-line no-fallthrough
        case 3:
          tupleToFill[2] = model.values[offset + 2];
        // eslint-disable-next-line no-fallthrough
        case 2:
          tupleToFill[1] = model.values[offset + 1];
        // eslint-disable-next-line no-fallthrough
        case 1:
          tupleToFill[0] = model.values[offset];
          break;
        default:
          for (let i = numberOfComponents - 1; i >= 0; --i) {
            tupleToFill[i] = model.values[offset + i];
          }
      }
      return tupleToFill;
    };
    publicAPI.getTuples = (fromId, toId) => {
      const from = (fromId ?? 0) * model.numberOfComponents;
      const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;
      const arr = publicAPI.getData().subarray(from, to);
      return arr.length > 0 ? arr : null;
    };
    publicAPI.getTupleLocation = function() {
      let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      return idx * model.numberOfComponents;
    };
    publicAPI.getNumberOfComponents = () => model.numberOfComponents;
    publicAPI.getNumberOfValues = () => model.size;
    publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;
    publicAPI.getDataType = () => model.dataType;
    publicAPI.newClone = () => newInstance14({
      empty: true,
      name: model.name,
      dataType: model.dataType,
      numberOfComponents: model.numberOfComponents
    });
    publicAPI.getName = () => {
      if (!model.name) {
        publicAPI.modified();
        model.name = `vtkDataArray${publicAPI.getMTime()}`;
      }
      return model.name;
    };
    publicAPI.setData = (typedArray, numberOfComponents) => {
      model.values = typedArray;
      model.size = typedArray.length;
      model.dataType = getDataType(typedArray);
      if (numberOfComponents) {
        model.numberOfComponents = numberOfComponents;
      }
      if (model.size % model.numberOfComponents !== 0) {
        model.numberOfComponents = 1;
      }
      publicAPI.dataChange();
    };
    publicAPI.getState = () => {
      if (model.deleted) {
        return null;
      }
      const jsonArchive = {
        ...model,
        vtkClass: publicAPI.getClassName()
      };
      jsonArchive.values = Array.from(jsonArchive.values);
      delete jsonArchive.buffer;
      Object.keys(jsonArchive).forEach((keyName) => {
        if (!jsonArchive[keyName]) {
          delete jsonArchive[keyName];
        }
      });
      const sortedObj = {};
      Object.keys(jsonArchive).sort().forEach((name) => {
        sortedObj[name] = jsonArchive[name];
      });
      if (sortedObj.mtime) {
        delete sortedObj.mtime;
      }
      return sortedObj;
    };
    publicAPI.deepCopy = (other) => {
      const currentType = publicAPI.getDataType();
      const currentArray = model.values;
      publicAPI.shallowCopy(other);
      model.ranges = structuredClone(other.getRanges());
      if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {
        currentArray.set(other.getData());
        model.values = currentArray;
        publicAPI.dataChange();
      } else {
        publicAPI.setData(other.getData().slice());
      }
    };
    publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {
      const numberOfComponents = model.numberOfComponents || 1;
      if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {
        vtkErrorMacro8("numberOfComponents must match");
      }
      const tuple1 = source1.getTuple(source1Idx);
      const tuple2 = source2.getTuple(source2Idx);
      const out = [];
      out.length = numberOfComponents;
      switch (numberOfComponents) {
        case 4:
          out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;
        // eslint-disable-next-line no-fallthrough
        case 3:
          out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;
        // eslint-disable-next-line no-fallthrough
        case 2:
          out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;
        // eslint-disable-next-line no-fallthrough
        case 1:
          out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;
          break;
        default:
          for (let i = 0; i < numberOfComponents; i++) {
            out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;
          }
      }
      return publicAPI.insertTuple(idx, out);
    };
  }
  var DEFAULT_VALUES12 = {
    name: "",
    numberOfComponents: 1,
    dataType: DefaultDataType2,
    rangeTuple: [0, 0]
    // size: undefined,
    // values: null,
    // ranges: null,
  };
  function extend12(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES12, initialValues);
    if (Array.isArray(initialValues.values) && initialValues.dataType === void 0) {
      console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array");
    }
    if (!model.empty && !model.values && !model.size) {
      throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");
    }
    if (!model.values) {
      model.values = newTypedArray(model.dataType, model.size);
    } else if (Array.isArray(model.values)) {
      model.values = newTypedArrayFrom(model.dataType, model.values);
    }
    if (model.values) {
      model.size = model.size ?? model.values.length;
      model.dataType = getDataType(model.values);
    }
    obj(publicAPI, model);
    set(publicAPI, model, ["name", "numberOfComponents"]);
    if (model.size % model.numberOfComponents !== 0) {
      throw new RangeError("model.size is not a multiple of model.numberOfComponents");
    }
    vtkDataArray(publicAPI, model);
  }
  var newInstance14 = newInstance(extend12, "vtkDataArray");
  var vtkDataArray$1 = {
    newInstance: newInstance14,
    extend: extend12,
    ...STATIC4,
    ...Constants2
  };

  // node_modules/@kitware/vtk.js/Common/Core/Points.js
  var {
    vtkErrorMacro: vtkErrorMacro9
  } = macro;
  function vtkPoints(publicAPI, model) {
    let boundMTime = 0;
    model.classHierarchy.push("vtkPoints");
    publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
    publicAPI.setNumberOfPoints = function(nbPoints) {
      let dimension = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
      if (publicAPI.getNumberOfPoints() !== nbPoints) {
        model.size = nbPoints * dimension;
        model.values = macro.newTypedArray(model.dataType, model.size);
        publicAPI.setNumberOfComponents(dimension);
        publicAPI.modified();
      }
    };
    publicAPI.setPoint = function(idx) {
      for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        xyz[_key - 1] = arguments[_key];
      }
      publicAPI.setTuple(idx, xyz);
    };
    publicAPI.getPoint = publicAPI.getTuple;
    publicAPI.findPoint = publicAPI.findTuple;
    publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);
    publicAPI.insertPoint = (ptId, point) => publicAPI.insertTuple(ptId, point);
    const superGetBounds = publicAPI.getBounds;
    publicAPI.getBounds = () => {
      if (boundMTime < model.mtime) {
        publicAPI.computeBounds();
      }
      return superGetBounds();
    };
    const superGetBoundsByReference = publicAPI.getBoundsByReference;
    publicAPI.getBoundsByReference = () => {
      if (boundMTime < model.mtime) {
        publicAPI.computeBounds();
      }
      return superGetBoundsByReference();
    };
    publicAPI.computeBounds = () => {
      if (publicAPI.getNumberOfComponents() === 3) {
        const xRange = publicAPI.getRange(0);
        model.bounds[0] = xRange[0];
        model.bounds[1] = xRange[1];
        const yRange = publicAPI.getRange(1);
        model.bounds[2] = yRange[0];
        model.bounds[3] = yRange[1];
        const zRange = publicAPI.getRange(2);
        model.bounds[4] = zRange[0];
        model.bounds[5] = zRange[1];
      } else if (publicAPI.getNumberOfComponents() === 2) {
        const xRange = publicAPI.getRange(0);
        model.bounds[0] = xRange[0];
        model.bounds[1] = xRange[1];
        const yRange = publicAPI.getRange(1);
        model.bounds[2] = yRange[0];
        model.bounds[3] = yRange[1];
        model.bounds[4] = 0;
        model.bounds[5] = 0;
      } else {
        vtkErrorMacro9(`getBounds called on an array with components of ${publicAPI.getNumberOfComponents()}`);
        uninitializeBounds(model.bounds);
      }
      boundMTime = macro.getCurrentGlobalMTime();
    };
    publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
  }
  var DEFAULT_VALUES13 = {
    empty: true,
    numberOfComponents: 3,
    dataType: VtkDataTypes.FLOAT,
    bounds: [1, -1, 1, -1, 1, -1]
  };
  function extend13(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES13, initialValues);
    vtkDataArray$1.extend(publicAPI, model, initialValues);
    macro.getArray(publicAPI, model, ["bounds"], 6);
    vtkPoints(publicAPI, model);
  }
  var newInstance15 = macro.newInstance(extend13, "vtkPoints");
  var vtkPoints$1 = {
    newInstance: newInstance15,
    extend: extend13
  };

  // node_modules/@kitware/vtk.js/Common/Core/CellArray.js
  var {
    isVtkObject: isVtkObject2
  } = macro;
  function extractCellSizes(cellArray) {
    let currentIdx = 0;
    return cellArray.filter((value, index) => {
      if (index === currentIdx) {
        currentIdx += value + 1;
        return true;
      }
      return false;
    });
  }
  function getNumberOfCells(cellArray) {
    let cellId = 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length; ) {
      cellArrayIndex += cellArray[cellArrayIndex] + 1;
      cellId++;
    }
    return cellId;
  }
  var STATIC5 = {
    extractCellSizes,
    getNumberOfCells
  };
  function vtkCellArray(publicAPI, model) {
    model.classHierarchy.push("vtkCellArray");
    const superClass = {
      ...publicAPI
    };
    publicAPI.getNumberOfCells = (recompute) => {
      if (model.numberOfCells !== void 0 && !recompute) {
        return model.numberOfCells;
      }
      if (model.cellSizes) {
        model.numberOfCells = model.cellSizes.length;
      } else {
        model.numberOfCells = getNumberOfCells(publicAPI.getData());
      }
      return model.numberOfCells;
    };
    publicAPI.getCellSizes = (recompute) => {
      if (model.cellSizes !== void 0 && !recompute) {
        return model.cellSizes;
      }
      model.cellSizes = extractCellSizes(publicAPI.getData());
      return model.cellSizes;
    };
    publicAPI.resize = (requestedNumTuples) => {
      const oldNumTuples = publicAPI.getNumberOfTuples();
      superClass.resize(requestedNumTuples);
      const newNumTuples = publicAPI.getNumberOfTuples();
      if (newNumTuples < oldNumTuples) {
        if (newNumTuples === 0) {
          model.numberOfCells = 0;
          model.cellSizes = [];
        } else {
          model.numberOfCells = void 0;
          model.cellSizes = void 0;
        }
      }
    };
    publicAPI.setData = (typedArray) => {
      superClass.setData(typedArray, 1);
      model.numberOfCells = void 0;
      model.cellSizes = void 0;
    };
    publicAPI.getCell = (loc) => {
      let cellLoc = loc;
      const numberOfPoints = model.values[cellLoc++];
      return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
    };
    publicAPI.insertNextCell = (cell) => {
      let cellPointIds;
      if (isVtkObject2(cell)) {
        cellPointIds = cell.getPointsIds();
      } else {
        cellPointIds = cell;
      }
      const cellId = publicAPI.getNumberOfCells();
      publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);
      ++model.numberOfCells;
      if (model.cellSizes != null) {
        model.cellSizes.push(cellPointIds.length);
      }
      return cellId;
    };
    publicAPI.getMaxCellSize = () => publicAPI.getCellSizes().reduce((a, b) => Math.max(a, b), 0);
  }
  function defaultValues(initialValues) {
    return {
      empty: true,
      numberOfComponents: 1,
      dataType: VtkDataTypes.UNSIGNED_INT,
      ...initialValues
    };
  }
  function extend14(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    vtkDataArray$1.extend(publicAPI, model, defaultValues(initialValues));
    vtkCellArray(publicAPI, model);
  }
  var newInstance16 = macro.newInstance(extend14, "vtkCellArray");
  var vtkCellArray$1 = {
    newInstance: newInstance16,
    extend: extend14,
    ...STATIC5
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/Cell.js
  function vtkCell(publicAPI, model) {
    model.classHierarchy.push("vtkCell");
    publicAPI.initialize = function(points) {
      let pointIdsList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (!pointIdsList) {
        model.points = points;
        model.pointsIds = new Array(points.getNumberOfPoints());
        for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {
          model.pointsIds[i] = i;
        }
      } else {
        model.pointsIds = pointIdsList;
        let triangleData = model.points.getData();
        if (triangleData.length !== 3 * model.pointsIds.length) {
          triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
        }
        const pointsData = points.getData();
        model.pointsIds.forEach((pointId, index) => {
          let pointOffset = 3 * pointId;
          let trianglePointOffset = 3 * index;
          triangleData[trianglePointOffset] = pointsData[pointOffset];
          triangleData[++trianglePointOffset] = pointsData[++pointOffset];
          triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        });
        model.points.setData(triangleData);
      }
    };
    publicAPI.getBounds = () => model.points.getBounds();
    publicAPI.getLength2 = () => {
      const lengths = vtkBoundingBox.getLengths(publicAPI.getBounds());
      return lengths[0] * lengths[0] + lengths[1] * lengths[1] + lengths[2] * lengths[2];
    };
    publicAPI.getParametricDistance = (pcoords) => {
      let pDist;
      let pDistMax = 0;
      for (let i = 0; i < 3; i++) {
        if (pcoords[i] < 0) {
          pDist = -pcoords[i];
        } else if (pcoords[i] > 1) {
          pDist = pcoords[i] - 1;
        } else {
          pDist = 0;
        }
        if (pDist > pDistMax) {
          pDistMax = pDist;
        }
      }
      return pDistMax;
    };
    publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
    publicAPI.deepCopy = (cell) => {
      cell.initialize(model.points, model.pointsIds);
    };
    publicAPI.getCellDimension = () => {
    };
    publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {
    };
    publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist22, weights) => {
      macro.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.");
    };
  }
  var DEFAULT_VALUES14 = {
    bounds: [-1, -1, -1, -1, -1, -1],
    pointsIds: []
  };
  function extend15(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES14, initialValues);
    macro.obj(publicAPI, model);
    if (!model.points) {
      model.points = vtkPoints$1.newInstance();
    }
    macro.get(publicAPI, model, ["points", "pointsIds"]);
    vtkCell(publicAPI, model);
  }
  var newInstance17 = macro.newInstance(extend15, "vtkCell");
  var vtkCell$1 = {
    newInstance: newInstance17,
    extend: extend15
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js
  function resize(model, sz) {
    let newSize = sz;
    if (sz >= model.array.length) {
      newSize += model.array.length;
    }
    while (newSize > model.array.length) model.array.push({
      ncells: 0,
      cells: null
    });
    model.array.length = newSize;
  }
  function vtkCellLinks(publicAPI, model) {
    model.classHierarchy.push("vtkCellLinks");
    publicAPI.buildLinks = (data) => {
      const numPts = data.getPoints().getNumberOfPoints();
      const numCells = data.getNumberOfCells();
      const linkLoc = new Uint32Array(numPts);
      if (data.isA("vtkPolyData")) {
        for (let cellId = 0; cellId < numCells; ++cellId) {
          const {
            cellPointIds
          } = data.getCellPoints(cellId);
          cellPointIds.forEach((cellPointId) => {
            publicAPI.incrementLinkCount(cellPointId);
          });
        }
        publicAPI.allocateLinks(numPts);
        model.maxId = numPts - 1;
        for (let cellId = 0; cellId < numCells; ++cellId) {
          const {
            cellPointIds
          } = data.getCellPoints(cellId);
          cellPointIds.forEach((cellPointId) => {
            publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
          });
        }
      } else {
        for (let cellId = 0; cellId < numCells; cellId++) {
          const cell = vtkCell$1.newInstance();
          cell.getPointsIds().forEach((cellPointId) => {
            publicAPI.incrementLinkCount(cellPointId);
          });
        }
        publicAPI.allocateLinks(numPts);
        model.maxId = numPts - 1;
        for (let cellId = 0; cellId < numCells; ++cellId) {
          const cell = vtkCell$1.newInstance();
          cell.getPointsIds().forEach((cellPointId) => {
            publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
          });
        }
      }
    };
    publicAPI.allocate = function(numLinks) {
      let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
      model.array = Array(numLinks).fill().map(() => ({
        ncells: 0,
        cells: null
      }));
      model.extend = ext;
      model.maxId = -1;
    };
    publicAPI.initialize = () => {
      model.array = null;
    };
    publicAPI.getLink = (ptId) => model.array[ptId];
    publicAPI.getNcells = (ptId) => model.array[ptId].ncells;
    publicAPI.getCells = (ptId) => model.array[ptId].cells;
    publicAPI.insertNextPoint = (numLinks) => {
      model.array.push({
        ncells: numLinks,
        cells: Array(numLinks)
      });
      ++model.maxId;
    };
    publicAPI.insertNextCellReference = (ptId, cellId) => {
      model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
    };
    publicAPI.deletePoint = (ptId) => {
      model.array[ptId].ncells = 0;
      model.array[ptId].cells = null;
    };
    publicAPI.removeCellReference = (cellId, ptId) => {
      model.array[ptId].cells = model.array[ptId].cells.filter((cell) => cell !== cellId);
      model.array[ptId].ncells = model.array[ptId].cells.length;
    };
    publicAPI.addCellReference = (cellId, ptId) => {
      model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
    };
    publicAPI.resizeCellList = (ptId, size) => {
      model.array[ptId].cells.length = size;
    };
    publicAPI.squeeze = () => {
      resize(model, model.maxId + 1);
    };
    publicAPI.reset = () => {
      model.maxId = -1;
    };
    publicAPI.deepCopy = (src) => {
      model.array = [...src.array];
      model.extend = src.extend;
      model.maxId = src.maxId;
    };
    publicAPI.incrementLinkCount = (ptId) => {
      ++model.array[ptId].ncells;
    };
    publicAPI.allocateLinks = (n) => {
      for (let i = 0; i < n; ++i) {
        model.array[i].cells = new Array(model.array[i].ncells);
      }
    };
    publicAPI.insertCellReference = (ptId, pos, cellId) => {
      model.array[ptId].cells[pos] = cellId;
    };
  }
  var DEFAULT_VALUES15 = {
    array: null,
    // pointer to data
    maxId: 0,
    // maximum index inserted thus far
    extend: 0
    // grow array by this point
  };
  function extend16(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES15, initialValues);
    macro.obj(publicAPI, model);
    vtkCellLinks(publicAPI, model);
  }
  var newInstance18 = macro.newInstance(extend16, "vtkCellLinks");
  var vtkCellLinks$1 = {
    newInstance: newInstance18,
    extend: extend16
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js
  var CellType = {
    // Linear cells
    VTK_EMPTY_CELL: 0,
    VTK_VERTEX: 1,
    VTK_POLY_VERTEX: 2,
    VTK_LINE: 3,
    VTK_POLY_LINE: 4,
    VTK_TRIANGLE: 5,
    VTK_TRIANGLE_STRIP: 6,
    VTK_POLYGON: 7,
    VTK_PIXEL: 8,
    VTK_QUAD: 9,
    VTK_TETRA: 10,
    VTK_VOXEL: 11,
    VTK_HEXAHEDRON: 12,
    VTK_WEDGE: 13,
    VTK_PYRAMID: 14,
    VTK_PENTAGONAL_PRISM: 15,
    VTK_HEXAGONAL_PRISM: 16,
    // Quadratic, isoparametric cells
    VTK_QUADRATIC_EDGE: 21,
    VTK_QUADRATIC_TRIANGLE: 22,
    VTK_QUADRATIC_QUAD: 23,
    VTK_QUADRATIC_POLYGON: 36,
    VTK_QUADRATIC_TETRA: 24,
    VTK_QUADRATIC_HEXAHEDRON: 25,
    VTK_QUADRATIC_WEDGE: 26,
    VTK_QUADRATIC_PYRAMID: 27,
    VTK_BIQUADRATIC_QUAD: 28,
    VTK_TRIQUADRATIC_HEXAHEDRON: 29,
    VTK_QUADRATIC_LINEAR_QUAD: 30,
    VTK_QUADRATIC_LINEAR_WEDGE: 31,
    VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
    VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
    VTK_BIQUADRATIC_TRIANGLE: 34,
    // Cubic, isoparametric cell
    VTK_CUBIC_LINE: 35,
    // Special class of cells formed by convex group of points
    VTK_CONVEX_POINT_SET: 41,
    // Polyhedron cell (consisting of polygonal faces)
    VTK_POLYHEDRON: 42,
    // Higher order cells in parametric form
    VTK_PARAMETRIC_CURVE: 51,
    VTK_PARAMETRIC_SURFACE: 52,
    VTK_PARAMETRIC_TRI_SURFACE: 53,
    VTK_PARAMETRIC_QUAD_SURFACE: 54,
    VTK_PARAMETRIC_TETRA_REGION: 55,
    VTK_PARAMETRIC_HEX_REGION: 56,
    // Higher order cells
    VTK_HIGHER_ORDER_EDGE: 60,
    VTK_HIGHER_ORDER_TRIANGLE: 61,
    VTK_HIGHER_ORDER_QUAD: 62,
    VTK_HIGHER_ORDER_POLYGON: 63,
    VTK_HIGHER_ORDER_TETRAHEDRON: 64,
    VTK_HIGHER_ORDER_WEDGE: 65,
    VTK_HIGHER_ORDER_PYRAMID: 66,
    VTK_HIGHER_ORDER_HEXAHEDRON: 67,
    // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)
    VTK_LAGRANGE_CURVE: 68,
    VTK_LAGRANGE_TRIANGLE: 69,
    VTK_LAGRANGE_QUADRILATERAL: 70,
    VTK_LAGRANGE_TETRAHEDRON: 71,
    VTK_LAGRANGE_HEXAHEDRON: 72,
    VTK_LAGRANGE_WEDGE: 73,
    VTK_LAGRANGE_PYRAMID: 74,
    VTK_NUMBER_OF_CELL_TYPES: 75
  };
  var CellTypesStrings = ["vtkEmptyCell", "vtkVertex", "vtkPolyVertex", "vtkLine", "vtkPolyLine", "vtkTriangle", "vtkTriangleStrip", "vtkPolygon", "vtkPixel", "vtkQuad", "vtkTetra", "vtkVoxel", "vtkHexahedron", "vtkWedge", "vtkPyramid", "vtkPentagonalPrism", "vtkHexagonalPrism", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkQuadraticEdge", "vtkQuadraticTriangle", "vtkQuadraticQuad", "vtkQuadraticTetra", "vtkQuadraticHexahedron", "vtkQuadraticWedge", "vtkQuadraticPyramid", "vtkBiQuadraticQuad", "vtkTriQuadraticHexahedron", "vtkQuadraticLinearQuad", "vtkQuadraticLinearWedge", "vtkBiQuadraticQuadraticWedge", "vtkBiQuadraticQuadraticHexahedron", "vtkBiQuadraticTriangle", "vtkCubicLine", "vtkQuadraticPolygon", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkConvexPointSet", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkParametricCurve", "vtkParametricSurface", "vtkParametricTriSurface", "vtkParametricQuadSurface", "vtkParametricTetraRegion", "vtkParametricHexRegion", "UnknownClass", "UnknownClass", "UnknownClass", "vtkHigherOrderEdge", "vtkHigherOrderTriangle", "vtkHigherOrderQuad", "vtkHigherOrderPolygon", "vtkHigherOrderTetrahedron", "vtkHigherOrderWedge", "vtkHigherOrderPyramid", "vtkHigherOrderHexahedron"];

  // node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js
  function getClassNameFromTypeId(typeId) {
    return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : "UnknownClass";
  }
  function getTypeIdFromClassName(cellTypeString) {
    return CellTypesStrings.findIndex(cellTypeString);
  }
  function isLinear(type) {
    return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
  }
  function hasSubCells(cellType) {
    return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;
  }
  var STATIC6 = {
    getClassNameFromTypeId,
    getTypeIdFromClassName,
    isLinear,
    hasSubCells
  };
  function vtkCellTypes(publicAPI, model) {
    model.classHierarchy.push("vtkCellTypes");
    publicAPI.allocate = function() {
      let sz = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 512;
      let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
      model.size = sz > 0 ? sz : 1;
      model.extend = ext > 0 ? ext : 1;
      model.maxId = -1;
      model.typeArray = new Uint8Array(sz);
      model.locationArray = new Uint32Array(sz);
    };
    publicAPI.insertCell = (cellId, type, loc) => {
      model.typeArray[cellId] = type;
      model.locationArray[cellId] = loc;
      if (cellId > model.maxId) {
        model.maxId = cellId;
      }
    };
    publicAPI.insertNextCell = (type, loc) => {
      publicAPI.insertCell(++model.maxId, type, loc);
      return model.maxId;
    };
    publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {
      model.size = ncells;
      model.typeArray = cellTypes;
      model.locationArray = cellLocations;
      model.maxId = ncells - 1;
    };
    publicAPI.getCellLocation = (cellId) => model.locationArray[cellId];
    publicAPI.deleteCell = (cellId) => {
      model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
    };
    publicAPI.getNumberOfTypes = () => model.maxId + 1;
    publicAPI.isType = (type) => {
      const numTypes = publicAPI.getNumberOfTypes();
      for (let i = 0; i < numTypes; ++i) {
        if (type === publicAPI.getCellType(i)) {
          return true;
        }
      }
      return false;
    };
    publicAPI.insertNextType = (type) => publicAPI.insertNextCell(type, -1);
    publicAPI.getCellType = (cellId) => model.typeArray[cellId];
    publicAPI.reset = () => {
      model.maxId = -1;
    };
    publicAPI.deepCopy = (src) => {
      publicAPI.allocate(src.getSize(), src.getExtend());
      model.typeArray.set(src.getTypeArray());
      model.locationArray.set(src.getLocationArray());
      model.maxId = src.getMaxId();
    };
  }
  var DEFAULT_VALUES16 = {
    // typeArray: null, // pointer to types array
    // locationArray: null;   // pointer to array of offsets
    size: 0,
    // allocated size of data
    maxId: -1,
    // maximum index inserted thus far
    extend: 1e3
    // grow array by this point
  };
  function extend17(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES16, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["size", "maxId", "extend"]);
    macro.getArray(publicAPI, model, ["typeArray", "locationArray"]);
    vtkCellTypes(publicAPI, model);
  }
  var newInstance19 = macro.newInstance(extend17, "vtkCellTypes");
  var vtkCellTypes$1 = {
    newInstance: newInstance19,
    extend: extend17,
    ...STATIC6
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js
  var IntersectionState = {
    NO_INTERSECTION: 0,
    YES_INTERSECTION: 1,
    ON_LINE: 2
  };
  var Constants3 = {
    IntersectionState
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/Line.js
  var {
    IntersectionState: IntersectionState2
  } = Constants3;
  function distanceToLine(x, p1, p2) {
    let closestPoint = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    const outObj = {
      t: Number.MIN_VALUE,
      distance: 0
    };
    const p21 = [];
    let closest;
    p21[0] = p2[0] - p1[0];
    p21[1] = p2[1] - p1[1];
    p21[2] = p2[2] - p1[2];
    const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
    const denom = dot4(p21, p21);
    let tolerance = 1e-5 * num;
    if (denom !== 0) {
      outObj.t = num / denom;
    }
    if (tolerance < 0) {
      tolerance = -tolerance;
    }
    if (-tolerance < denom && denom < tolerance) {
      closest = p1;
    } else if (denom <= 0 || outObj.t < 0) {
      closest = p1;
    } else if (outObj.t > 1) {
      closest = p2;
    } else {
      closest = p21;
      p21[0] = p1[0] + outObj.t * p21[0];
      p21[1] = p1[1] + outObj.t * p21[1];
      p21[2] = p1[2] + outObj.t * p21[2];
    }
    if (closestPoint) {
      closestPoint[0] = closest[0];
      closestPoint[1] = closest[1];
      closestPoint[2] = closest[2];
    }
    outObj.distance = distance2BetweenPoints(closest, x);
    return outObj;
  }
  function intersection(a1, a2, b1, b2, u, v) {
    const a21 = [];
    const b21 = [];
    const b1a1 = [];
    u[0] = 0;
    v[0] = 0;
    subtract5(a2, a1, a21);
    subtract5(b2, b1, b21);
    subtract5(b1, a1, b1a1);
    const A = [dot4(a21, a21), -dot4(a21, b21), -dot4(a21, b21), dot4(b21, b21)];
    const c = [];
    c[0] = dot4(a21, b1a1);
    c[1] = -dot4(b21, b1a1);
    if (solveLinearSystem(A, c, 2) === 0) {
      let minDist = Number.MAX_VALUE;
      const p = [a1, a2, b1, b2];
      const l1 = [b1, b1, a1, a1];
      const l2 = [b2, b2, a2, a2];
      [v[0], v[0], u[0], u[0]];
      [u[0], u[0], v[0], v[0]];
      let obj2;
      for (let i = 0; i < 4; i++) {
        obj2 = distanceToLine(p[i], l1[i], l2[i]);
        if (obj2.distance < minDist) {
          minDist = obj2.distance;
          obj2.t;
        }
      }
      return IntersectionState2.ON_LINE;
    }
    u[0] = c[0];
    v[0] = c[1];
    if (u[0] >= 0 && u[0] <= 1 && v[0] >= 0 && v[0] <= 1) {
      return IntersectionState2.YES_INTERSECTION;
    }
    return IntersectionState2.NO_INTERSECTION;
  }
  var STATIC7 = {
    distanceToLine,
    intersection
  };
  function vtkLine(publicAPI, model) {
    model.classHierarchy.push("vtkLine");
    function isBetweenPoints(t) {
      return t >= 0 && t <= 1;
    }
    publicAPI.getCellDimension = () => 1;
    publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
      const outObj = {
        intersect: 0,
        t: Number.MAX_VALUE,
        subId: 0,
        betweenPoints: null
      };
      pcoords[1] = 0;
      pcoords[2] = 0;
      const projXYZ = [];
      const a1 = [];
      const a2 = [];
      model.points.getPoint(0, a1);
      model.points.getPoint(1, a2);
      const u = [];
      const v = [];
      const intersect2 = intersection(p1, p2, a1, a2, u, v);
      outObj.t = u[0];
      outObj.betweenPoints = isBetweenPoints(outObj.t);
      pcoords[0] = v[0];
      if (intersect2 === IntersectionState2.YES_INTERSECTION) {
        for (let i = 0; i < 3; i++) {
          x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
          projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
        }
        if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
      } else {
        let outDistance;
        if (outObj.t < 0) {
          outDistance = distanceToLine(p1, a1, a2, x);
          if (outDistance.distance <= tol * tol) {
            outObj.t = 0;
            outObj.intersect = 1;
            outObj.betweenPoints = true;
            return outObj;
          }
          return outObj;
        }
        if (outObj.t > 1) {
          outDistance = distanceToLine(p2, a1, a2, x);
          if (outDistance.distance <= tol * tol) {
            outObj.t = 1;
            outObj.intersect = 1;
            outObj.betweenPoints = true;
            return outObj;
          }
          return outObj;
        }
        if (pcoords[0] < 0) {
          pcoords[0] = 0;
          outDistance = distanceToLine(a1, p1, p2, x);
          outObj.t = outDistance.t;
          if (outDistance.distance <= tol * tol) {
            outObj.intersect = 1;
            return outObj;
          }
          return outObj;
        }
        if (pcoords[0] > 1) {
          pcoords[0] = 1;
          outDistance = distanceToLine(a2, p1, p2, x);
          outObj.t = outDistance.t;
          if (outDistance.distance <= tol * tol) {
            outObj.intersect = 1;
            return outObj;
          }
          return outObj;
        }
      }
      return outObj;
    };
    publicAPI.evaluateLocation = (pcoords, x, weights) => {
      const a1 = [];
      const a2 = [];
      model.points.getPoint(0, a1);
      model.points.getPoint(1, a2);
      for (let i = 0; i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
      }
      weights[0] = 1 - pcoords[0];
      weights[1] = pcoords[0];
    };
    publicAPI.evaluateOrientation = (pcoords, q, weights) => {
      if (model.orientations) {
        quat_exports.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);
        weights[0] = 1 - pcoords[0];
        weights[1] = pcoords[0];
        return true;
      }
      return false;
    };
  }
  var DEFAULT_VALUES17 = {
    orientations: null
    // an array of two quat or null
  };
  function extend18(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES17, initialValues);
    vtkCell$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["orientations"]);
    vtkLine(publicAPI, model);
  }
  var newInstance20 = macro.newInstance(extend18, "vtkLine");
  var vtkLine$1 = {
    newInstance: newInstance20,
    extend: extend18,
    ...STATIC7,
    ...Constants3
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js
  var {
    vtkErrorMacro: vtkErrorMacro10,
    vtkWarningMacro: vtkWarningMacro5
  } = macro;
  function vtkFieldData(publicAPI, model) {
    model.classHierarchy.push("vtkFieldData");
    const superGetState = publicAPI.getState;
    if (model.arrays) {
      model.arrays = model.arrays.map((item) => ({
        data: vtk(item.data)
      }));
    }
    publicAPI.initialize = () => {
      publicAPI.initializeFields();
      publicAPI.copyAllOn();
      publicAPI.clearFieldFlags();
    };
    publicAPI.initializeFields = () => {
      model.arrays = [];
      model.copyFieldFlags = {};
      publicAPI.modified();
    };
    publicAPI.copyStructure = (other) => {
      publicAPI.initializeFields();
      model.copyFieldFlags = other.getCopyFieldFlags().map((x) => x);
      model.arrays = other.getArrays().map((x) => ({
        data: x
      }));
    };
    publicAPI.getNumberOfArrays = () => model.arrays.length;
    publicAPI.getNumberOfActiveArrays = () => model.arrays.length;
    publicAPI.addArray = (arr) => {
      const name = arr.getName();
      const {
        array,
        index
      } = publicAPI.getArrayWithIndex(name);
      if (array != null) {
        model.arrays[index] = {
          data: arr
        };
        return index;
      }
      model.arrays = [].concat(model.arrays, {
        data: arr
      });
      return model.arrays.length - 1;
    };
    publicAPI.removeAllArrays = () => {
      model.arrays = [];
    };
    publicAPI.removeArray = (arrayName) => {
      const index = model.arrays.findIndex((array) => array.data.getName() === arrayName);
      return publicAPI.removeArrayByIndex(index);
    };
    publicAPI.removeArrayByIndex = (arrayIdx) => {
      if (arrayIdx !== -1 && arrayIdx < model.arrays.length) {
        model.arrays.splice(arrayIdx, 1);
        return true;
      }
      return false;
    };
    publicAPI.getArrays = () => model.arrays.map((entry) => entry.data);
    publicAPI.getArray = (arraySpec) => typeof arraySpec === "number" ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);
    publicAPI.getArrayByName = (arrayName) => model.arrays.reduce((a, b, i) => b.data.getName() === arrayName ? b.data : a, null);
    publicAPI.getArrayWithIndex = (arrayName) => {
      const index = model.arrays.findIndex((array) => array.data.getName() === arrayName);
      return {
        array: index !== -1 ? model.arrays[index].data : null,
        index
      };
    };
    publicAPI.getArrayByIndex = (idx) => idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
    publicAPI.hasArray = (arrayName) => publicAPI.getArrayWithIndex(arrayName).index >= 0;
    publicAPI.getArrayName = (idx) => {
      const arr = model.arrays[idx];
      return arr ? arr.data.getName() : "";
    };
    publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;
    publicAPI.getFlag = (arrayName) => model.copyFieldFlags[arrayName];
    publicAPI.passData = function(other) {
      let fromId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      let toId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      other.getArrays().forEach((arr) => {
        const copyFlag = publicAPI.getFlag(arr.getName());
        if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
          let destArr = publicAPI.getArrayByName(arr.getName());
          if (!destArr) {
            if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
              publicAPI.addArray(arr);
              other.getAttributes(arr).forEach((attrType) => {
                publicAPI.setAttribute(arr, attrType);
              });
            } else {
              const ncomps = arr.getNumberOfComponents();
              let newSize = arr.getNumberOfValues();
              const tId = toId > -1 ? toId : fromId;
              if (newSize <= tId * ncomps) {
                newSize = (tId + 1) * ncomps;
              }
              destArr = vtkDataArray$1.newInstance({
                name: arr.getName(),
                dataType: arr.getDataType(),
                numberOfComponents: ncomps,
                values: macro.newTypedArray(arr.getDataType(), newSize),
                size: 0
              });
              destArr.insertTuple(tId, arr.getTuple(fromId));
              publicAPI.addArray(destArr);
              other.getAttributes(arr).forEach((attrType) => {
                publicAPI.setAttribute(destArr, attrType);
              });
            }
          } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
            if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
              const tId = toId > -1 ? toId : fromId;
              destArr.insertTuple(tId, arr.getTuple(fromId));
            } else {
              destArr.insertTuples(0, arr.getTuples());
            }
          } else {
            vtkErrorMacro10("Unhandled case in passData");
          }
        }
      });
    };
    publicAPI.interpolateData = function(other) {
      let fromId1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      let fromId2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      let toId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
      let t = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
      other.getArrays().forEach((arr) => {
        const copyFlag = publicAPI.getFlag(arr.getName());
        if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
          let destArr = publicAPI.getArrayByName(arr.getName());
          if (!destArr) {
            if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {
              publicAPI.addArray(arr);
              other.getAttributes(arr).forEach((attrType) => {
                publicAPI.setAttribute(arr, attrType);
              });
            } else {
              const ncomps = arr.getNumberOfComponents();
              let newSize = arr.getNumberOfValues();
              const tId = toId > -1 ? toId : fromId1;
              if (newSize <= tId * ncomps) {
                newSize = (tId + 1) * ncomps;
              }
              destArr = vtkDataArray$1.newInstance({
                name: arr.getName(),
                dataType: arr.getDataType(),
                numberOfComponents: ncomps,
                values: macro.newTypedArray(arr.getDataType(), newSize),
                size: 0
              });
              destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
              publicAPI.addArray(destArr);
              other.getAttributes(arr).forEach((attrType) => {
                publicAPI.setAttribute(destArr, attrType);
              });
            }
          } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
            if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {
              const tId = toId > -1 ? toId : fromId1;
              destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
              vtkWarningMacro5("Unexpected case in interpolateData");
            } else {
              destArr.insertTuples(arr.getTuples());
            }
          } else {
            vtkErrorMacro10("Unhandled case in interpolateData");
          }
        }
      });
    };
    publicAPI.copyFieldOn = (arrayName) => {
      model.copyFieldFlags[arrayName] = true;
    };
    publicAPI.copyFieldOff = (arrayName) => {
      model.copyFieldFlags[arrayName] = false;
    };
    publicAPI.copyAllOn = () => {
      if (!model.doCopyAllOn || model.doCopyAllOff) {
        model.doCopyAllOn = true;
        model.doCopyAllOff = false;
        publicAPI.modified();
      }
    };
    publicAPI.copyAllOff = () => {
      if (model.doCopyAllOn || !model.doCopyAllOff) {
        model.doCopyAllOn = false;
        model.doCopyAllOff = true;
        publicAPI.modified();
      }
    };
    publicAPI.clearFieldFlags = () => {
      model.copyFieldFlags = {};
    };
    publicAPI.deepCopy = (other) => {
      model.arrays = other.getArrays().map((arr) => {
        const arrNew = arr.newClone();
        arrNew.deepCopy(arr);
        return {
          data: arrNew
        };
      });
    };
    publicAPI.copyFlags = (other) => other.getCopyFieldFlags().map((x) => x);
    publicAPI.reset = () => model.arrays.forEach((entry) => entry.data.reset());
    publicAPI.getMTime = () => model.arrays.reduce((a, b) => b.data.getMTime() > a ? b.data.getMTime() : a, model.mtime);
    publicAPI.getNumberOfComponents = () => model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);
    publicAPI.getNumberOfTuples = () => model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;
    publicAPI.getState = () => {
      const result = superGetState();
      if (result) {
        result.arrays = model.arrays.map((item) => ({
          data: item.data.getState()
        }));
      }
      return result;
    };
  }
  var DEFAULT_VALUES18 = {
    arrays: [],
    copyFieldFlags: [],
    // fields not to copy
    doCopyAllOn: true,
    doCopyAllOff: false
  };
  function extend19(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES18, initialValues);
    macro.obj(publicAPI, model);
    vtkFieldData(publicAPI, model);
  }
  var newInstance21 = macro.newInstance(extend19, "vtkFieldData");
  var vtkFieldData$1 = {
    newInstance: newInstance21,
    extend: extend19
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js
  var AttributeTypes = {
    SCALARS: 0,
    VECTORS: 1,
    NORMALS: 2,
    TCOORDS: 3,
    TENSORS: 4,
    GLOBALIDS: 5,
    PEDIGREEIDS: 6,
    EDGEFLAG: 7,
    NUM_ATTRIBUTES: 8
  };
  var AttributeLimitTypes = {
    MAX: 0,
    EXACT: 1,
    NOLIMIT: 2
  };
  var CellGhostTypes = {
    DUPLICATECELL: 1,
    // the cell is present on multiple processors
    HIGHCONNECTIVITYCELL: 2,
    // the cell has more neighbors than in a regular mesh
    LOWCONNECTIVITYCELL: 4,
    // the cell has less neighbors than in a regular mesh
    REFINEDCELL: 8,
    // other cells are present that refines it.
    EXTERIORCELL: 16,
    // the cell is on the exterior of the data set
    HIDDENCELL: 32
    // the cell is needed to maintain connectivity, but the data values should be ignored.
  };
  var PointGhostTypes = {
    DUPLICATEPOINT: 1,
    // the cell is present on multiple processors
    HIDDENPOINT: 2
    // the point is needed to maintain connectivity, but the data values should be ignored.
  };
  var AttributeCopyOperations = {
    COPYTUPLE: 0,
    INTERPOLATE: 1,
    PASSDATA: 2,
    ALLCOPY: 3
    // all of the above
  };
  var ghostArrayName = "vtkGhostType";
  var DesiredOutputPrecision = {
    DEFAULT: 0,
    // use the point type that does not truncate any data
    SINGLE: 1,
    // use Float32Array
    DOUBLE: 2
    // use Float64Array
  };
  var Constants4 = {
    AttributeCopyOperations,
    AttributeLimitTypes,
    AttributeTypes,
    CellGhostTypes,
    DesiredOutputPrecision,
    PointGhostTypes,
    ghostArrayName
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js
  var {
    AttributeTypes: AttributeTypes2,
    AttributeCopyOperations: AttributeCopyOperations2
  } = Constants4;
  var {
    vtkWarningMacro: vtkWarningMacro6
  } = macro;
  function vtkDataSetAttributes(publicAPI, model) {
    const attrTypes = ["Scalars", "Vectors", "Normals", "TCoords", "Tensors", "GlobalIds", "PedigreeIds"];
    function cleanAttributeType(attType) {
      let cleanAttType = attrTypes.find((ee) => AttributeTypes2[ee.toUpperCase()] === attType || typeof attType !== "number" && ee.toLowerCase() === attType.toLowerCase());
      if (typeof cleanAttType === "undefined") {
        cleanAttType = null;
      }
      return cleanAttType;
    }
    model.classHierarchy.push("vtkDataSetAttributes");
    const superClass = {
      ...publicAPI
    };
    publicAPI.checkNumberOfComponents = (x) => true;
    publicAPI.setAttribute = (arr, uncleanAttType) => {
      const attType = cleanAttributeType(uncleanAttType);
      if (arr && attType.toUpperCase() === "PEDIGREEIDS" && !arr.isA("vtkDataArray")) {
        vtkWarningMacro6(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);
        return -1;
      }
      if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
        vtkWarningMacro6(`Cannot set attribute ${attType}. Incorrect number of components.`);
        return -1;
      }
      let currentAttribute = model[`active${attType}`];
      if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {
        if (model.arrays[currentAttribute] === arr) {
          return currentAttribute;
        }
        publicAPI.removeArrayByIndex(currentAttribute);
      }
      if (arr) {
        currentAttribute = publicAPI.addArray(arr);
        model[`active${attType}`] = currentAttribute;
      } else {
        model[`active${attType}`] = -1;
      }
      publicAPI.modified();
      return model[`active${attType}`];
    };
    publicAPI.getAttributes = (arr) => attrTypes.filter((attrType) => publicAPI[`get${attrType}`]() === arr);
    publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);
    publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {
      const attType = cleanAttributeType(uncleanAttType);
      if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
        if (attType.toUpperCase() !== "PEDIGREEIDS") {
          const arr = publicAPI.getArrayByIndex(arrayIdx);
          if (!arr.isA("vtkDataArray")) {
            vtkWarningMacro6(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);
            return -1;
          }
          if (!publicAPI.checkNumberOfComponents(arr, attType)) {
            vtkWarningMacro6(`Cannot set attribute ${attType}. Incorrect number of components.`);
            return -1;
          }
        }
        model[`active${attType}`] = arrayIdx;
        publicAPI.modified();
        return arrayIdx;
      }
      if (arrayIdx === -1) {
        model[`active${attType}`] = arrayIdx;
        publicAPI.modified();
      }
      return -1;
    };
    publicAPI.getActiveAttribute = (attType) => {
      const cleanAttType = cleanAttributeType(attType);
      return publicAPI[`get${cleanAttType}`]();
    };
    publicAPI.removeAllArrays = () => {
      attrTypes.forEach((attType) => {
        model[`active${attType}`] = -1;
      });
      superClass.removeAllArrays();
    };
    publicAPI.removeArrayByIndex = (arrayIdx) => {
      if (arrayIdx !== -1) {
        attrTypes.forEach((attType) => {
          if (arrayIdx === model[`active${attType}`]) {
            model[`active${attType}`] = -1;
          } else if (arrayIdx < model[`active${attType}`]) {
            model[`active${attType}`] -= 1;
          }
        });
      }
      return superClass.removeArrayByIndex(arrayIdx);
    };
    attrTypes.forEach((value) => {
      const activeVal = `active${value}`;
      publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);
      publicAPI[`set${value}`] = (da) => publicAPI.setAttribute(da, value);
      publicAPI[`setActive${value}`] = (arrayName) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);
      publicAPI[`copy${value}Off`] = () => {
        const attType = value.toUpperCase();
        model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = false;
      };
      publicAPI[`copy${value}On`] = () => {
        const attType = value.toUpperCase();
        model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = true;
      };
    });
    publicAPI.initializeAttributeCopyFlags = () => {
      model.copyAttributeFlags = [];
      Object.keys(AttributeCopyOperations2).filter((op) => op !== "ALLCOPY").forEach((attCopyOp) => {
        model.copyAttributeFlags[AttributeCopyOperations2[attCopyOp]] = Object.keys(AttributeTypes2).filter((ty) => ty !== "NUM_ATTRIBUTES").reduce((a, b) => {
          a[AttributeTypes2[b]] = true;
          return a;
        }, []);
      });
      model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.GLOBALIDS] = false;
      model.copyAttributeFlags[AttributeCopyOperations2.INTERPOLATE][AttributeTypes2.GLOBALIDS] = false;
      model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.PEDIGREEIDS] = false;
    };
    publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);
    if (model.dataArrays && Object.keys(model.dataArrays).length) {
      Object.keys(model.dataArrays).forEach((name) => {
        if (!model.dataArrays[name].ref && model.dataArrays[name].type === "vtkDataArray") {
          publicAPI.addArray(vtkDataArray$1.newInstance(model.dataArrays[name]));
        }
      });
    }
    const superShallowCopy = publicAPI.shallowCopy;
    publicAPI.shallowCopy = (other, debug) => {
      superShallowCopy(other, debug);
      model.arrays = other.getArrays().map((arr) => {
        const arrNew = arr.newClone();
        arrNew.shallowCopy(arr, debug);
        return {
          data: arrNew
        };
      });
    };
    publicAPI.initializeAttributeCopyFlags();
  }
  var DEFAULT_VALUES19 = {
    activeScalars: -1,
    activeVectors: -1,
    activeTensors: -1,
    activeNormals: -1,
    activeTCoords: -1,
    activeGlobalIds: -1,
    activePedigreeIds: -1
  };
  function extend20(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES19, initialValues);
    vtkFieldData$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["activeScalars", "activeNormals", "activeTCoords", "activeVectors", "activeTensors", "activeGlobalIds", "activePedigreeIds"]);
    if (!model.arrays) {
      model.arrays = {};
    }
    vtkDataSetAttributes(publicAPI, model);
  }
  var newInstance22 = macro.newInstance(extend20, "vtkDataSetAttributes");
  var vtkDataSetAttributes$1 = {
    newInstance: newInstance22,
    extend: extend20,
    ...Constants4
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/DataSet/Constants.js
  var FieldDataTypes = {
    UNIFORM: 0,
    // data that does not vary over points/cells/etc.
    DATA_OBJECT_FIELD: 0,
    // to match VTK
    COORDINATE: 1,
    // data that specifies the location of each point
    POINT_DATA: 1,
    // to match VTK
    POINT: 2,
    // data defined at each point, but that does not specify the point location
    POINT_FIELD_DATA: 2,
    // to match VTK
    CELL: 3,
    // data defined at each cell, but that does not specify the cell
    CELL_FIELD_DATA: 3,
    // to match VTK
    VERTEX: 4,
    // data defined at each graph vertex, but that does not specify the graph vertex
    VERTEX_FIELD_DATA: 4,
    // to match VTK
    EDGE: 5,
    // data defined at each graph edge, but that does not specify the graph edge
    EDGE_FIELD_DATA: 5,
    // to match VTK
    ROW: 6,
    // data specifying a table row
    ROW_DATA: 6
    // to match VTK
  };
  var FieldAssociations = {
    FIELD_ASSOCIATION_POINTS: 0,
    FIELD_ASSOCIATION_CELLS: 1,
    FIELD_ASSOCIATION_NONE: 2,
    FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
    FIELD_ASSOCIATION_VERTICES: 4,
    FIELD_ASSOCIATION_EDGES: 5,
    FIELD_ASSOCIATION_ROWS: 6,
    NUMBER_OF_ASSOCIATIONS: 7
  };
  var Constants5 = {
    FieldDataTypes,
    FieldAssociations
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js
  var DATASET_FIELDS = ["pointData", "cellData", "fieldData"];
  function vtkDataSet(publicAPI, model) {
    model.classHierarchy.push("vtkDataSet");
    DATASET_FIELDS.forEach((fieldName) => {
      if (!model[fieldName]) {
        model[fieldName] = vtkDataSetAttributes$1.newInstance();
      } else {
        model[fieldName] = vtk(model[fieldName]);
      }
    });
    publicAPI.computeBounds = () => {
      if (model.modifiedTime && model.computeTime && model.modifiedTime > model.computeTime || !model.computeTime) {
        const points = publicAPI.getPoints();
        if (points?.getNumberOfPoints()) {
          vtkBoundingBox.setBounds(model.bounds, points.getBoundsByReference());
        } else {
          model.bounds = vtkMath.createUninitializedBounds();
        }
        model.computeTime = macro.getCurrentGlobalMTime();
      }
    };
    publicAPI.getLength2 = () => {
      const bounds = publicAPI.getBoundsByReference();
      if (!bounds || bounds.length !== 6) return 0;
      return vtkBoundingBox.getDiagonalLength2(bounds);
    };
    publicAPI.getLength = () => Math.sqrt(publicAPI.getLength2());
    publicAPI.getCenter = () => {
      const bounds = publicAPI.getBoundsByReference();
      if (!bounds || bounds.length !== 6) return [0, 0, 0];
      return vtkBoundingBox.getCenter(bounds);
    };
    publicAPI.getCellBounds = (cellId) => {
      const cell = publicAPI.getCell(cellId);
      if (cell) {
        return cell.getBounds();
      }
      return vtkMath.createUninitializedBounds();
    };
    publicAPI.getBounds = macro.chain(() => publicAPI.computeBounds, publicAPI.getBounds);
    publicAPI.getBoundsByReference = macro.chain(() => publicAPI.computeBounds, publicAPI.getBoundsByReference);
    const superShallowCopy = publicAPI.shallowCopy;
    publicAPI.shallowCopy = function(other) {
      let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      superShallowCopy(other, debug);
      DATASET_FIELDS.forEach((fieldName) => {
        model[fieldName] = vtkDataSetAttributes$1.newInstance();
        model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
      });
    };
    const superGetMTime = publicAPI.getMTime;
    publicAPI.getMTime = () => DATASET_FIELDS.reduce((mTime, fieldName) => Math.max(mTime, model[fieldName]?.getMTime() ?? mTime), superGetMTime());
    publicAPI.initialize = () => {
      DATASET_FIELDS.forEach((fieldName) => model[fieldName]?.initialize());
      return publicAPI;
    };
  }
  var DEFAULT_VALUES20 = {
    // pointData: null,
    // cellData: null,
    // fieldData: null,
  };
  function extend21(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES20, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, DATASET_FIELDS);
    macro.getArray(publicAPI, model, ["bounds"], 6);
    vtkDataSet(publicAPI, model);
  }
  var newInstance23 = macro.newInstance(extend21, "vtkDataSet");
  var vtkDataSet$1 = {
    newInstance: newInstance23,
    extend: extend21,
    ...Constants5
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js
  function vtkPointSet(publicAPI, model) {
    model.classHierarchy.push("vtkPointSet");
    if (!model.points) {
      model.points = vtkPoints$1.newInstance();
    } else {
      model.points = vtk(model.points);
    }
    publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
    publicAPI.getBounds = () => model.points.getBounds();
    publicAPI.computeBounds = () => {
      publicAPI.getBounds();
    };
    const superShallowCopy = publicAPI.shallowCopy;
    publicAPI.shallowCopy = function(other) {
      let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      superShallowCopy(other, debug);
      model.points = vtkPoints$1.newInstance();
      model.points.shallowCopy(other.getPoints());
    };
    const superGetMTime = publicAPI.getMTime;
    publicAPI.getMTime = () => {
      const mTime = superGetMTime();
      return Math.max(mTime, model.points?.getMTime() ?? mTime);
    };
    const superInitialize = publicAPI.initialize;
    publicAPI.initialize = () => {
      model.points?.initialize();
      return superInitialize();
    };
  }
  var DEFAULT_VALUES21 = {
    // points: null,
  };
  function extend22(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES21, initialValues);
    vtkDataSet$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["points"]);
    vtkPointSet(publicAPI, model);
  }
  var newInstance24 = macro.newInstance(extend22, "vtkPointSet");
  var vtkPointSet$1 = {
    newInstance: newInstance24,
    extend: extend22
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/PolyLine.js
  function vtkPolyLine(publicAPI, model) {
    model.classHierarchy.push("vtkPolyLine");
    const line = vtkLine$1.newInstance();
    line.getPoints().setNumberOfPoints(2);
    publicAPI.getCellDimension = () => 1;
    publicAPI.intersectWithLine = (t1, t2, p1, p2, tol, x, pcoords) => {
      const outObj = {
        intersect: 0,
        t: Number.MAX_VALUE,
        subId: 0,
        betweenPoints: null
      };
      const numLines = publicAPI.getNumberOfPoints() - 1;
      let pDistMin = Number.MAX_VALUE;
      for (let subId = 0; subId < numLines; subId++) {
        const pCoords = [0, 0, 0];
        line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
        const lineIntersected = line.intersectWithLine(p1, p2, tol, x, pcoords);
        if (lineIntersected.intersect === 1 && lineIntersected.t <= outObj.t + tol && lineIntersected.t >= t1 && lineIntersected.t <= t2) {
          outObj.intersect = 1;
          const pDist = line.getParametricDistance(pCoords);
          if (pDist < pDistMin || pDist === pDistMin && lineIntersected.t < outObj.t) {
            outObj.subId = subId;
            outObj.t = lineIntersected.t;
            pDistMin = pDist;
            for (let k = 0; k < 3; k++) {
              x[k];
              pCoords[k];
            }
          }
        }
      }
      return outObj;
    };
    publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {
      line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
      return line.evaluateLocation(pcoords, x, weights);
    };
    publicAPI.evaluateOrientation = (subId, pcoords, q, weights) => {
      if (model.orientations) {
        line.setOrientations([model.orientations[subId], model.orientations[subId + 1]]);
      } else {
        line.setOrientations(null);
      }
      return line.evaluateOrientation(pcoords, q, weights);
    };
    publicAPI.getDistancesToFirstPoint = () => {
      const dTime = model.distancesTime.getMTime();
      if (dTime < model.points.getMTime() || dTime < publicAPI.getMTime()) {
        const numPoints = publicAPI.getNumberOfPoints();
        if (!model.distances) {
          model.distances = new Array(numPoints);
        } else {
          model.distances.length = numPoints;
        }
        if (numPoints > 0) {
          const previousPoint = new Array(3);
          const currentPoint = new Array(3);
          let totalDistance = 0;
          model.distances[0] = totalDistance;
          model.points.getPoint(0, previousPoint);
          for (let i = 1; i < numPoints; ++i) {
            model.points.getPoint(i, currentPoint);
            totalDistance += model.distanceFunction(previousPoint, currentPoint);
            model.distances[i] = totalDistance;
            vec3_exports.copy(previousPoint, currentPoint);
          }
        }
        model.distancesTime.modified();
      }
      return model.distances;
    };
    publicAPI.findPointIdAtDistanceFromFirstPoint = (distance3) => {
      const distances = publicAPI.getDistancesToFirstPoint();
      if (distances.length < 2) {
        return -1;
      }
      let minId = 0;
      let maxId = distances.length - 1;
      if (distance3 < distances[minId] || distance3 > distances[maxId] || distances[maxId] === 0) {
        return -1;
      }
      while (maxId - minId > 1) {
        const midId = Math.floor((minId + maxId) / 2);
        if (distances[midId] <= distance3) {
          minId = midId;
        } else {
          maxId = midId;
        }
      }
      return minId;
    };
  }
  var DEFAULT_VALUES22 = {
    orientations: null,
    // an array of quat or null
    distanceFunction: vec3_exports.dist
  };
  function extend23(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES22, initialValues);
    vtkCell$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["orientations", "distanceFunction"]);
    model.distancesTime = {};
    macro.obj(model.distancesTime, {
      mtime: 0
    });
    vtkPolyLine(publicAPI, model);
  }
  var newInstance25 = macro.newInstance(extend23, "vtkPolyLine");
  var vtkPolyLine$1 = {
    newInstance: newInstance25,
    extend: extend23
  };

  // node_modules/@kitware/vtk.js/Common/Core/PriorityQueue.js
  function vtkPriorityQueue(publicAPI, model) {
    model.classHierarchy.push("vtkPriorityQueue");
    publicAPI.push = (priority, element) => {
      const i = model.elements.findIndex((e) => e.priority > priority);
      model.elements.splice(i, 0, {
        priority,
        element
      });
    };
    publicAPI.pop = () => {
      if (model.elements.length > 0) {
        return model.elements.shift().element;
      }
      return null;
    };
    publicAPI.deleteById = (id) => {
      model.elements = model.elements.filter((_ref) => {
        let {
          element
        } = _ref;
        return element.id !== id;
      });
    };
    publicAPI.length = () => model.elements.length;
  }
  var DEFAULT_VALUES23 = {
    elements: []
  };
  function extend24(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES23, initialValues);
    macro.obj(publicAPI, model);
    vtkPriorityQueue(publicAPI, model);
  }
  var newInstance26 = macro.newInstance(extend24, "vtkPriorityQueue");
  var vtkPriorityQueue$1 = {
    newInstance: newInstance26,
    extend: extend24
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/Polygon/Constants.js
  var EPSILON4 = 1e-6;
  var FLOAT_EPSILON = 11920929e-14;
  var TOLERANCE = 1e-8;
  var PolygonWithPointIntersectionState = {
    FAILURE: -1,
    OUTSIDE: 0,
    INSIDE: 1,
    INTERSECTION: 2,
    ON_LINE: 3
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/Polygon.js
  function pointLocation(axis0, axis1, p0, p1, point) {
    return (p1[axis0] - p0[axis0]) * (point[axis1] - p0[axis1]) - (point[axis0] - p0[axis0]) * (p1[axis1] - p0[axis1]);
  }
  function pointInPolygon(point, vertices, bounds, normal) {
    if (point[0] < bounds[0] || point[0] > bounds[1] || point[1] < bounds[2] || point[1] > bounds[3] || point[2] < bounds[4] || point[2] > bounds[5]) {
      return PolygonWithPointIntersectionState.OUTSIDE;
    }
    if (normalize4(normal) <= FLOAT_EPSILON) {
      return PolygonWithPointIntersectionState.FAILURE;
    }
    let tol2 = TOLERANCE * ((bounds[1] - bounds[0]) * (bounds[1] - bounds[0]) + (bounds[3] - bounds[2]) * (bounds[3] - bounds[2]) + (bounds[5] - bounds[4]) * (bounds[5] - bounds[4]));
    tol2 *= tol2;
    tol2 = tol2 === 0 ? FLOAT_EPSILON : tol2;
    const p0 = [];
    const p1 = [];
    for (let i = 0; i < vertices.length; ) {
      p0[0] = vertices[i++];
      p0[1] = vertices[i++];
      p0[2] = vertices[i++];
      if (distance2BetweenPoints(point, p0) <= tol2) {
        return PolygonWithPointIntersectionState.INSIDE;
      }
      const {
        distance: distance3,
        t
      } = vtkLine$1.distanceToLine(point, p0, p1);
      if (distance3 <= tol2 && t > 0 && t < 1) {
        return PolygonWithPointIntersectionState.INSIDE;
      }
    }
    let axis0;
    let axis1;
    if (Math.abs(normal[0]) > Math.abs(normal[1])) {
      if (Math.abs(normal[0]) > Math.abs(normal[2])) {
        axis0 = 1;
        axis1 = 2;
      } else {
        axis0 = 0;
        axis1 = 1;
      }
    } else if (Math.abs(normal[1]) > Math.abs(normal[2])) {
      axis0 = 0;
      axis1 = 2;
    } else {
      axis0 = 0;
      axis1 = 1;
    }
    let wn = 0;
    for (let i = 0; i < vertices.length; ) {
      p0[0] = vertices[i++];
      p0[1] = vertices[i++];
      p0[2] = vertices[i++];
      if (i < vertices.length) {
        p1[0] = vertices[i];
        p1[1] = vertices[i + 1];
        p1[2] = vertices[i + 2];
      } else {
        p1[0] = vertices[0];
        p1[1] = vertices[1];
        p1[2] = vertices[2];
      }
      if (p0[axis1] <= point[axis1]) {
        if (p1[axis1] > point[axis1]) {
          if (pointLocation(axis0, axis1, p0, p1, point) > 0) {
            ++wn;
          }
        }
      } else if (p1[axis1] <= point[axis1]) {
        if (pointLocation(axis0, axis1, p0, p1, point) < 0) {
          --wn;
        }
      }
    }
    return wn === 0 ? PolygonWithPointIntersectionState.OUTSIDE : PolygonWithPointIntersectionState.INSIDE;
  }
  function getBounds(poly, points, bounds) {
    const n = poly.length;
    const p = [];
    points.getPoint(poly[0], p);
    bounds[0] = p[0];
    bounds[1] = p[0];
    bounds[2] = p[1];
    bounds[3] = p[1];
    bounds[4] = p[2];
    bounds[5] = p[2];
    for (let j = 1; j < n; j++) {
      points.getPoint(poly[j], p);
      vtkBoundingBox.addPoint(bounds, ...p);
    }
    const length4 = vtkBoundingBox.getLengths(bounds);
    return dot4(length4, length4);
  }
  function getNormal(poly, points, normal) {
    normal.length = 3;
    normal[0] = 0;
    normal[1] = 0;
    normal[2] = 0;
    const p0 = [];
    let p1 = [];
    let p2 = [];
    const v1 = [];
    const v2 = [];
    points.getPoint(poly[0], p0);
    points.getPoint(poly[1], p1);
    for (let j = 2; j < poly.length; j++) {
      points.getPoint(poly[j], p2);
      subtract5(p2, p1, v1);
      subtract5(p0, p1, v2);
      const n = [0, 0, 0];
      cross3(v1, v2, n);
      add6(normal, n, normal);
      [p1, p2] = [p2, p1];
    }
    return normalize4(normal);
  }
  function computeCentroid(poly, points) {
    let centroid = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0, 0, 0];
    centroid[0] = 0;
    centroid[1] = 0;
    centroid[2] = 0;
    const n = poly.length;
    const p = [];
    for (let i = 0; i < n; i++) {
      points.getPoint(poly[i], p);
      centroid[0] += p[0];
      centroid[1] += p[1];
      centroid[2] += p[2];
    }
    centroid[0] /= n;
    centroid[1] /= n;
    centroid[2] /= n;
    return centroid;
  }
  var STATIC8 = {
    PolygonWithPointIntersectionState,
    pointInPolygon,
    getBounds,
    getNormal,
    computeCentroid
  };
  function vtkPolygon(publicAPI, model) {
    model.classHierarchy.push("vtkPolygon");
    function computeNormal2() {
      const v1 = [0, 0, 0];
      const v2 = [0, 0, 0];
      model.normal = [0, 0, 0];
      const anchor = [...model.firstPoint.point];
      let point = model.firstPoint;
      for (let i = 0; i < model.pointCount; i++) {
        subtract5(point.point, anchor, v1);
        subtract5(point.next.point, anchor, v2);
        const n = [0, 0, 0];
        cross3(v1, v2, n);
        add6(model.normal, n, model.normal);
        point = point.next;
      }
      return normalize4(model.normal);
    }
    function computeMeasure(point) {
      const v1 = [0, 0, 0];
      const v2 = [0, 0, 0];
      const v3 = [0, 0, 0];
      const v4 = [0, 0, 0];
      subtract5(point.point, point.previous.point, v1);
      subtract5(point.next.point, point.point, v2);
      subtract5(point.previous.point, point.next.point, v3);
      cross3(v1, v2, v4);
      const area = dot4(v4, model.normal);
      if (area <= 0) {
        return -1;
      }
      const perimeter = norm(v1) + norm(v2) + norm(v3);
      return perimeter * perimeter / area;
    }
    function canRemoveVertex(point) {
      if (model.pointCount <= 3) {
        return true;
      }
      const previous = point.previous;
      const next = point.next;
      const v = [0, 0, 0];
      subtract5(next.point, previous.point, v);
      const sN = [0, 0, 0];
      cross3(v, model.normal, sN);
      normalize4(sN);
      if (norm(sN) === 0) {
        return false;
      }
      let val = vtkPlane$1.evaluate(sN, previous.point, next.next.point);
      let currentSign = val > EPSILON4 ? 1 : val < -EPSILON4 ? -1 : 0;
      let oneNegative = currentSign < 0 ? 1 : 0;
      for (let vertex = next.next.next; vertex.id !== previous.id; vertex = vertex.next) {
        const previousVertex = vertex.previous;
        val = vtkPlane$1.evaluate(sN, previous.point, vertex.point);
        const sign = val > EPSILON4 ? 1 : val < -EPSILON4 ? -1 : 0;
        if (sign !== currentSign) {
          if (!oneNegative) {
            oneNegative = sign <= 0 ? 1 : 0;
          }
          if (vtkLine$1.intersection(previous.point, next.point, vertex.point, previousVertex.point, [0], [0]) === IntersectionState.YES_INTERSECTION) {
            return false;
          }
          currentSign = sign;
        }
      }
      return oneNegative === 1;
    }
    function removePoint(point, queue) {
      model.pointCount -= 1;
      const previous = point.previous;
      const next = point.next;
      model.tris = model.tris.concat(point.point);
      model.tris = model.tris.concat(next.point);
      model.tris = model.tris.concat(previous.point);
      previous.next = next;
      next.previous = previous;
      queue.deleteById(previous.id);
      queue.deleteById(next.id);
      const previousMeasure = computeMeasure(previous);
      if (previousMeasure > 0) {
        queue.push(previousMeasure, previous);
      }
      const nextMeasure = computeMeasure(next);
      if (nextMeasure > 0) {
        queue.push(nextMeasure, next);
      }
      if (point.id === model.firstPoint.id) {
        model.firstPoint = next;
      }
    }
    function earCutTriangulation() {
      computeNormal2();
      const vertexQueue = vtkPriorityQueue$1.newInstance();
      let point = model.firstPoint;
      for (let i = 0; i < model.pointCount; i++) {
        const measure = computeMeasure(point);
        if (measure > 0) {
          vertexQueue.push(measure, point);
        }
        point = point.next;
      }
      while (model.pointCount > 2 && vertexQueue.length() > 0) {
        if (model.pointCount === vertexQueue.length()) {
          const pointToRemove = vertexQueue.pop();
          removePoint(pointToRemove, vertexQueue);
        } else {
          const pointToRemove = vertexQueue.pop();
          if (canRemoveVertex(pointToRemove)) {
            removePoint(pointToRemove, vertexQueue);
          }
        }
      }
      return model.pointCount <= 2;
    }
    publicAPI.triangulate = () => {
      if (!model.firstPoint) {
        return null;
      }
      return earCutTriangulation();
    };
    publicAPI.setPoints = (points) => {
      model.pointCount = points.length;
      model.firstPoint = {
        id: 0,
        point: points[0],
        next: null,
        previous: null
      };
      let currentPoint = model.firstPoint;
      for (let i = 1; i < model.pointCount; i++) {
        currentPoint.next = {
          id: i,
          point: points[i],
          next: null,
          previous: currentPoint
        };
        currentPoint = currentPoint.next;
      }
      model.firstPoint.previous = currentPoint;
      currentPoint.next = model.firstPoint;
    };
    publicAPI.getPointArray = () => model.tris;
  }
  var DEFAULT_VALUES24 = {
    firstPoint: null,
    pointCount: 0,
    tris: []
  };
  function extend25(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES24, initialValues);
    macro.obj(publicAPI, model);
    vtkPolygon(publicAPI, model);
  }
  var newInstance27 = macro.newInstance(extend25, "vtkPolygon");
  var vtkPolygon$1 = {
    newInstance: newInstance27,
    extend: extend25,
    ...STATIC8
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js
  function computeNormalDirection(v1, v2, v3, n) {
    const ax = v3[0] - v2[0];
    const ay = v3[1] - v2[1];
    const az = v3[2] - v2[2];
    const bx = v1[0] - v2[0];
    const by = v1[1] - v2[1];
    const bz = v1[2] - v2[2];
    n[0] = ay * bz - az * by;
    n[1] = az * bx - ax * bz;
    n[2] = ax * by - ay * bx;
  }
  function computeNormal(v1, v2, v3, n) {
    computeNormalDirection(v1, v2, v3, n);
    const length4 = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
    if (length4 !== 0) {
      n[0] /= length4;
      n[1] /= length4;
      n[2] /= length4;
    }
  }
  function interpolationDerivs(derivs) {
    derivs[0] = -1;
    derivs[1] = 1;
    derivs[2] = 0;
    derivs[3] = -1;
    derivs[4] = 0;
    derivs[5] = 1;
  }
  function intersectWithTriangle(p1, q1, r1, p2, q2, r2) {
    let tolerance = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1e-6;
    let coplanar = false;
    const pt1 = [];
    const pt2 = [];
    const surfaceId = [];
    const n1 = [];
    const n2 = [];
    computeNormal(p1, q1, r1, n1);
    computeNormal(p2, q2, r2, n2);
    const s1 = -dot4(n1, p1);
    const s2 = -dot4(n2, p2);
    const dist1 = [dot4(n2, p1) + s2, dot4(n2, q1) + s2, dot4(n2, r1) + s2];
    if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }
    const dist22 = [dot4(n1, p2) + s1, dot4(n1, q2) + s1, dot4(n1, r2) + s1];
    if (dist22[0] * dist22[1] > tolerance && dist22[0] * dist22[2] > tolerance) {
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }
    if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {
      coplanar = true;
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }
    const pts1 = [p1, q1, r1];
    const pts2 = [p2, q2, r2];
    const n1n2 = dot4(n1, n2);
    const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1);
    const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1);
    const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];
    const v = cross3(n1, n2, []);
    normalize4(v);
    let index1 = 0;
    let index2 = 0;
    const t1 = [];
    const t2 = [];
    let ts1 = 50;
    let ts2 = 50;
    for (let i = 0; i < 3; i++) {
      const id1 = i;
      const id2 = (i + 1) % 3;
      const val1 = vtkPlane$1.intersectWithLine(pts1[id1], pts1[id2], p2, n2);
      if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
        if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
          ts1 = index1;
        }
        t1[index1++] = dot4(val1.x, v) - dot4(p, v);
      }
      const val2 = vtkPlane$1.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
      if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
        if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
          ts2 = index2;
        }
        t2[index2++] = dot4(val2.x, v) - dot4(p, v);
      }
    }
    if (index1 > 2) {
      index1--;
      const t12 = t1[2];
      t1[2] = t1[ts1];
      t1[ts1] = t12;
    }
    if (index2 > 2) {
      index2--;
      const t22 = t2[2];
      t2[2] = t2[ts2];
      t2[ts2] = t22;
    }
    if (index1 !== 2 || index2 !== 2) {
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }
    if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }
    if (t1[0] > t1[1]) {
      const t11 = t1[1];
      t1[1] = t1[0];
      t1[0] = t11;
    }
    if (t2[0] > t2[1]) {
      const t21 = t2[1];
      t2[1] = t2[0];
      t2[0] = t21;
    }
    let tt1;
    let tt2;
    if (t1[1] < t2[0] || t2[1] < t1[0]) {
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }
    if (t1[0] < t2[0]) {
      if (t1[1] < t2[1]) {
        surfaceId[0] = 2;
        surfaceId[1] = 1;
        tt1 = t2[0];
        tt2 = t1[1];
      } else {
        surfaceId[0] = 2;
        surfaceId[1] = 2;
        tt1 = t2[0];
        tt2 = t2[1];
      }
    } else if (t1[1] < t2[1]) {
      surfaceId[0] = 1;
      surfaceId[1] = 1;
      tt1 = t1[0];
      tt2 = t1[1];
    } else {
      surfaceId[0] = 1;
      surfaceId[1] = 2;
      tt1 = t1[0];
      tt2 = t2[1];
    }
    multiplyAccumulate(p, v, tt1, pt1);
    multiplyAccumulate(p, v, tt2, pt2);
    return {
      intersect: true,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  var STATIC9 = {
    computeNormalDirection,
    computeNormal,
    interpolationDerivs,
    intersectWithTriangle
  };
  function vtkTriangle(publicAPI, model) {
    model.classHierarchy.push("vtkTriangle");
    publicAPI.getCellDimension = () => 2;
    publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
      const outObj = {
        subId: 0,
        t: Number.MAX_VALUE,
        intersect: 0,
        betweenPoints: false
      };
      pcoords[2] = 0;
      const closestPoint = [];
      const tol2 = tol * tol;
      const pt1 = [];
      const pt2 = [];
      const pt3 = [];
      model.points.getPoint(0, pt1);
      model.points.getPoint(1, pt2);
      model.points.getPoint(2, pt3);
      const n = [];
      const weights = [];
      computeNormal(pt1, pt2, pt3, n);
      if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
        const plane = vtkPlane$1.intersectWithLine(p1, p2, pt1, n);
        outObj.betweenPoints = plane.betweenPoints;
        outObj.t = plane.t;
        x[0] = plane.x[0];
        x[1] = plane.x[1];
        x[2] = plane.x[2];
        if (!plane.intersection) {
          pcoords[0] = 0;
          pcoords[1] = 0;
          outObj.intersect = 0;
          return outObj;
        }
        const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);
        if (inside.evaluation >= 0) {
          if (inside.dist2 <= tol2) {
            outObj.intersect = 1;
            return outObj;
          }
          outObj.intersect = inside.evaluation;
          return outObj;
        }
      }
      const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);
      const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);
      const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);
      if (!model.line) {
        model.line = vtkLine$1.newInstance();
      }
      if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
        model.line.getPoints().setPoint(0, pt1);
        model.line.getPoints().setPoint(1, pt2);
      } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
        model.line.getPoints().setPoint(0, pt2);
        model.line.getPoints().setPoint(1, pt3);
      } else {
        model.line.getPoints().setPoint(0, pt3);
        model.line.getPoints().setPoint(1, pt1);
      }
      const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
      outObj.betweenPoints = intersectLine.betweenPoints;
      outObj.t = intersectLine.t;
      if (intersectLine.intersect) {
        const pt3Pt1 = [];
        const pt3Pt2 = [];
        const pt3X = [];
        for (let i = 0; i < 3; i++) {
          pt3Pt1[i] = pt1[i] - pt3[i];
          pt3Pt2[i] = pt2[i] - pt3[i];
          pt3X[i] = x[i] - pt3[i];
        }
        pcoords[0] = dot4(pt3X, pt3Pt1) / dist2Pt3Pt1;
        pcoords[1] = dot4(pt3X, pt3Pt2) / dist2Pt2Pt3;
        outObj.intersect = 1;
        return outObj;
      }
      pcoords[0] = 0;
      pcoords[1] = 0;
      outObj.intersect = 0;
      return outObj;
    };
    publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {
      const outObj = {
        subId: 0,
        dist2: 0,
        evaluation: -1
      };
      let i;
      let j;
      const pt1 = [];
      const pt2 = [];
      const pt3 = [];
      const n = [];
      let fabsn;
      const rhs = [];
      const c1 = [];
      const c2 = [];
      let det = 0;
      let idx = 0;
      const indices = [];
      let dist2Point;
      let dist2Line1;
      let dist2Line2;
      let closest = [];
      const closestPoint1 = [];
      const closestPoint2 = [];
      const cp = [];
      outObj.subId = 0;
      pcoords[2] = 0;
      model.points.getPoint(1, pt1);
      model.points.getPoint(2, pt2);
      model.points.getPoint(0, pt3);
      computeNormalDirection(pt1, pt2, pt3, n);
      vtkPlane$1.generalizedProjectPoint(x, pt1, n, cp);
      let maxComponent = 0;
      for (i = 0; i < 3; i++) {
        if (n[i] < 0) {
          fabsn = -n[i];
        } else {
          fabsn = n[i];
        }
        if (fabsn > maxComponent) {
          maxComponent = fabsn;
          idx = i;
        }
      }
      for (j = 0, i = 0; i < 3; i++) {
        if (i !== idx) {
          indices[j++] = i;
        }
      }
      for (i = 0; i < 2; i++) {
        rhs[i] = cp[indices[i]] - pt3[indices[i]];
        c1[i] = pt1[indices[i]] - pt3[indices[i]];
        c2[i] = pt2[indices[i]] - pt3[indices[i]];
      }
      det = determinant2x2(c1, c2);
      if (det === 0) {
        pcoords[0] = 0;
        pcoords[1] = 0;
        outObj.evaluation = -1;
        return outObj;
      }
      pcoords[0] = determinant2x2(rhs, c2) / det;
      pcoords[1] = determinant2x2(c1, rhs) / det;
      weights[0] = 1 - (pcoords[0] + pcoords[1]);
      weights[1] = pcoords[0];
      weights[2] = pcoords[1];
      if (weights[0] >= 0 && weights[0] <= 1 && weights[1] >= 0 && weights[1] <= 1 && weights[2] >= 0 && weights[2] <= 1) {
        if (closestPoint) {
          outObj.dist2 = distance2BetweenPoints(cp, x);
          closestPoint[0] = cp[0];
          closestPoint[1] = cp[1];
          closestPoint[2] = cp[2];
        }
        outObj.evaluation = 1;
      } else {
        let t;
        if (closestPoint) {
          if (weights[1] < 0 && weights[2] < 0) {
            dist2Point = distance2BetweenPoints(x, pt3);
            dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
            dist2Line2 = vtkLine$1.distanceToLine(x, pt3, pt2, t, closestPoint2);
            if (dist2Point < dist2Line1) {
              outObj.dist2 = dist2Point;
              closest = pt3;
            } else {
              outObj.dist2 = dist2Line1;
              closest = closestPoint1;
            }
            if (dist2Line2 < outObj.dist2) {
              outObj.dist2 = dist2Line2;
              closest = closestPoint2;
            }
            for (i = 0; i < 3; i++) {
              closestPoint[i] = closest[i];
            }
          } else if (weights[2] < 0 && weights[0] < 0) {
            dist2Point = distance2BetweenPoints(x, pt1);
            dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
            dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
            if (dist2Point < dist2Line1) {
              outObj.dist2 = dist2Point;
              closest = pt1;
            } else {
              outObj.dist2 = dist2Line1;
              closest = closestPoint1;
            }
            if (dist2Line2 < outObj.dist2) {
              outObj.dist2 = dist2Line2;
              closest = closestPoint2;
            }
            for (i = 0; i < 3; i++) {
              closestPoint[i] = closest[i];
            }
          } else if (weights[1] < 0 && weights[0] < 0) {
            dist2Point = distance2BetweenPoints(x, pt2);
            dist2Line1 = vtkLine$1.distanceToLine(x, pt2, pt3, t, closestPoint1);
            dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
            if (dist2Point < dist2Line1) {
              outObj.dist2 = dist2Point;
              closest = pt2;
            } else {
              outObj.dist2 = dist2Line1;
              closest = closestPoint1;
            }
            if (dist2Line2 < outObj.dist2) {
              outObj.dist2 = dist2Line2;
              closest = closestPoint2;
            }
            for (i = 0; i < 3; i++) {
              closestPoint[i] = closest[i];
            }
          } else if (weights[0] < 0) {
            const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt2, closestPoint);
            outObj.dist2 = lineDistance.distance;
          } else if (weights[1] < 0) {
            const lineDistance = vtkLine$1.distanceToLine(x, pt2, pt3, closestPoint);
            outObj.dist2 = lineDistance.distance;
          } else if (weights[2] < 0) {
            const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt3, closestPoint);
            outObj.dist2 = lineDistance.distance;
          }
        }
        outObj.evaluation = 0;
      }
      return outObj;
    };
    publicAPI.evaluateLocation = (pcoords, x, weights) => {
      const p0 = [];
      const p1 = [];
      const p2 = [];
      model.points.getPoint(0, p0);
      model.points.getPoint(1, p1);
      model.points.getPoint(2, p2);
      const u3 = 1 - pcoords[0] - pcoords[1];
      for (let i = 0; i < 3; i++) {
        x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
      }
      weights[0] = u3;
      weights[1] = pcoords[0];
      weights[2] = pcoords[1];
    };
    publicAPI.getParametricDistance = (pcoords) => {
      let pDist;
      let pDistMax = 0;
      const pc = [];
      pc[0] = pcoords[0];
      pc[1] = pcoords[1];
      pc[2] = 1 - pcoords[0] - pcoords[1];
      for (let i = 0; i < 3; i++) {
        if (pc[i] < 0) {
          pDist = -pc[i];
        } else if (pc[i] > 1) {
          pDist = pc[i] - 1;
        } else {
          pDist = 0;
        }
        if (pDist > pDistMax) {
          pDistMax = pDist;
        }
      }
      return pDistMax;
    };
    publicAPI.derivatives = (subId, pcoords, values, dim, derivs) => {
      const x0 = model.points.getPoint(0);
      const x1 = model.points.getPoint(1);
      const x2 = model.points.getPoint(2);
      const n = [];
      const v10 = [];
      const v20 = [];
      const v = [];
      computeNormal(x0, x1, x2, n);
      subtract5(x1, x0, v10);
      subtract5(x2, x0, v);
      cross3(n, v10, v20);
      const lenX = normalize4(v10);
      if (lenX <= 0 || normalize4(v20) <= 0) {
        for (let j = 0; j < dim; j++) {
          for (let i = 0; i < 3; i++) {
            derivs[j * dim + i] = 0;
          }
        }
        return;
      }
      const v0 = [0, 0];
      const v1 = [lenX, 0];
      const v2 = [dot4(v, v10), dot4(v, v20)];
      const functionDerivs = new Array(6);
      interpolationDerivs(functionDerivs);
      const J = [v1[0] - v0[0], v1[1] - v0[1], v2[0] - v0[0], v2[1] - v0[1]];
      const JI = macro.newTypedArray(TYPED_ARRAYS.Float64Array, 4);
      invertMatrix(J, JI, 2);
      for (let j = 0; j < dim; j++) {
        let sum0 = 0;
        let sum1 = 0;
        for (let i = 0; i < 3; i++) {
          sum0 += functionDerivs[i] * values[dim * i + j];
          sum1 += functionDerivs[3 + i] * values[dim * i + j];
        }
        const dBydx = sum0 * JI[0] + sum1 * JI[1];
        const dBydy = sum0 * JI[2] + sum1 * JI[3];
        derivs[3 * j] = dBydx * v10[0] + dBydy * v20[0];
        derivs[3 * j + 1] = dBydx * v10[1] + dBydy * v20[1];
        derivs[3 * j + 2] = dBydx * v10[2] + dBydy * v20[2];
      }
    };
    publicAPI.cellBoundary = (subId, pcoords, pts) => {
      const t1 = pcoords[0] - pcoords[1];
      const t2 = 0.5 * (1 - pcoords[0]) - pcoords[1];
      const t3 = 2 * pcoords[0] + pcoords[1] - 1;
      if (t1 >= 0 && t2 >= 0) {
        pts[0] = model.pointsIds[0];
        pts[1] = model.pointsIds[1];
      } else if (t2 < 0 && t3 >= 0) {
        pts[0] = model.pointsIds[1];
        pts[1] = model.pointsIds[2];
      } else {
        pts[0] = model.pointsIds[2];
        pts[1] = model.pointsIds[0];
      }
      if (pcoords[0] < 0 || pcoords[1] < 0 || pcoords[0] > 1 || pcoords[1] > 1 || 1 - pcoords[0] - pcoords[1] < 0) {
        return false;
      }
      return true;
    };
  }
  var DEFAULT_VALUES25 = {};
  function extend26(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES25, initialValues);
    vtkCell$1.extend(publicAPI, model, initialValues);
    vtkTriangle(publicAPI, model);
  }
  var newInstance28 = macro.newInstance(extend26, "vtkTriangle");
  var vtkTriangle$1 = {
    newInstance: newInstance28,
    extend: extend26,
    ...STATIC9
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/Quad.js
  function intersectionStruct() {
    return {
      intersected: false,
      subId: -1,
      x: [0, 0, 0],
      pCoords: [0, 0, 0],
      t: -1
    };
  }
  function vtkQuad(publicAPI, model) {
    model.classHierarchy.push("vtkQuad");
    publicAPI.getCellDimension = () => 2;
    publicAPI.getCellType = () => CellType.VTK_QUAD;
    publicAPI.getNumberOfEdges = () => 4;
    publicAPI.getNumberOfFaces = () => 0;
    publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
      let outObj = {
        subId: 0,
        t: Number.MAX_VALUE,
        intersect: 0,
        betweenPoints: false
      };
      let diagonalCase;
      const point0 = model.points.getPoint(0, []);
      const point1 = model.points.getPoint(1, []);
      const point2 = model.points.getPoint(2, []);
      const point3 = model.points.getPoint(3, []);
      const d1 = distance2BetweenPoints(point0, point2);
      const d2 = distance2BetweenPoints(point1, point3);
      if (d1 === d2) {
        let id;
        let maxId = 0;
        let maxIdx = 0;
        for (let i = 0; i < 4; i++) {
          id = model.pointsIds[i];
          if (id > maxId) {
            maxId = id;
            maxIdx = i;
          }
        }
        if (maxIdx === 0 || maxIdx === 2) {
          diagonalCase = 0;
        } else {
          diagonalCase = 1;
        }
      } else if (d1 < d2) {
        diagonalCase = 0;
      } else {
        diagonalCase = 1;
      }
      let points = null;
      if (!model.triangle) {
        model.triangle = vtkTriangle$1.newInstance();
        points = vtkPoints$1.newInstance();
        points.setNumberOfPoints(3);
        model.triangle.initialize(points);
      } else {
        points = model.triangle.getPoints();
      }
      let firstIntersect;
      const firstIntersectTmpObj = intersectionStruct();
      let secondIntersect;
      const secondIntersectTmpObj = intersectionStruct();
      let useFirstIntersection;
      let useSecondIntersection;
      switch (diagonalCase) {
        case 0:
          points.setPoint(0, ...point0);
          points.setPoint(1, ...point1);
          points.setPoint(2, ...point2);
          firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);
          points.setPoint(0, ...point2);
          points.setPoint(1, ...point3);
          points.setPoint(2, ...point0);
          secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
          useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
          useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;
          if (useFirstIntersection) {
            outObj = firstIntersect;
            x[0] = firstIntersectTmpObj.x[0];
            x[1] = firstIntersectTmpObj.x[1];
            x[2] = firstIntersectTmpObj.x[2];
            pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];
            pcoords[1] = firstIntersectTmpObj.pCoords[1];
            pcoords[2] = firstIntersectTmpObj.pCoords[2];
          } else if (useSecondIntersection) {
            outObj = secondIntersect;
            x[0] = secondIntersectTmpObj.x[0];
            x[1] = secondIntersectTmpObj.x[1];
            x[2] = secondIntersectTmpObj.x[2];
            pcoords[0] = 1 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);
            pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
            pcoords[2] = secondIntersectTmpObj.pCoords[2];
          }
          break;
        case 1:
          points.setPoint(0, ...point0);
          points.setPoint(1, ...point1);
          points.setPoint(2, ...point3);
          firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);
          points.setPoint(0, ...point2);
          points.setPoint(1, ...point3);
          points.setPoint(2, ...point1);
          secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
          useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
          useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;
          if (useFirstIntersection) {
            outObj = firstIntersect;
            x[0] = firstIntersectTmpObj.x[0];
            x[1] = firstIntersectTmpObj.x[1];
            x[2] = firstIntersectTmpObj.x[2];
            pcoords[0] = firstIntersectTmpObj.pCoords[0];
            pcoords[1] = firstIntersectTmpObj.pCoords[1];
            pcoords[2] = firstIntersectTmpObj.pCoords[2];
          } else if (useSecondIntersection) {
            outObj = secondIntersect;
            x[0] = secondIntersectTmpObj.x[0];
            x[1] = secondIntersectTmpObj.x[1];
            x[2] = secondIntersectTmpObj.x[2];
            pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];
            pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
            pcoords[2] = secondIntersectTmpObj.pCoords[2];
          }
          break;
      }
      return outObj;
    };
    publicAPI.interpolationFunctions = (pcoords, weights) => {
      const rm = 1 - pcoords[0];
      const sm = 1 - pcoords[1];
      weights[0] = rm * sm;
      weights[1] = pcoords[0] * sm;
      weights[2] = pcoords[0] * pcoords[1];
      weights[3] = rm * pcoords[1];
    };
    publicAPI.evaluateLocation = (pcoords, x, weights) => {
      const point = [];
      publicAPI.interpolationFunctions(pcoords, weights);
      x[0] = 0;
      x[1] = 0;
      x[2] = 0;
      for (let i = 0; i < 4; i++) {
        model.points.getPoint(i, point);
        for (let j = 0; j < 3; j++) {
          x[j] += point[j] * weights[i];
        }
      }
    };
  }
  var DEFAULT_VALUES26 = {};
  function extend27(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES26, initialValues);
    vtkCell$1.extend(publicAPI, model, initialValues);
    vtkQuad(publicAPI, model);
  }
  var newInstance29 = macro.newInstance(extend27, "vtkQuad");
  var vtkQuad$1 = {
    newInstance: newInstance29,
    extend: extend27
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/TriangleStrip.js
  var {
    vtkErrorMacro: vtkErrorMacro11
  } = macro;
  function notImplemented4(method) {
    return () => vtkErrorMacro11(`vtkTriangleStrip.${method} - NOT IMPLEMENTED`);
  }
  function decomposeStrip(pts, polys) {
    if (!Array.isArray(pts) || pts.length < 3) {
      vtkErrorMacro11("decomposeStrip - Invalid points array");
      return;
    }
    let p1 = pts[0];
    let p2 = pts[1];
    for (let i = 0; i < pts.length - 2; i++) {
      const p3 = pts[i + 2];
      if (i % 2) {
        polys.insertNextCell([p2, p1, p3]);
      } else {
        polys.insertNextCell([p1, p2, p3]);
      }
      p1 = p2;
      p2 = p3;
    }
  }
  var STATIC10 = {
    decomposeStrip
  };
  function vtkTriangleStrip(publicAPI, model) {
    model.classHierarchy.push("vtkTriangleStrip");
    const superInitialize = publicAPI.initialize;
    publicAPI.initialize = (points, pointsIds) => {
      model.triangle.initialize(points, pointsIds);
      superInitialize(points, pointsIds);
    };
    publicAPI.getCellType = () => CellType.VTK_TRIANGLE_STRIP;
    publicAPI.getCellDimension = () => 2;
    publicAPI.getNumberOfEdges = () => model.pointsIds.length;
    publicAPI.getNumberOfFaces = () => 0;
    publicAPI.evaluatePosition = (x, closestPoint, pcoords, dist22, weights) => {
      const pc = [0, 0, 0];
      let minDist2 = Number.MAX_VALUE;
      let returnStatus = 0;
      const tempWeights = [];
      const activeWeights = [];
      const closest = [];
      pcoords[2] = 0;
      activeWeights[0] = 0;
      activeWeights[1] = 0;
      activeWeights[2] = 0;
      const points = model.triangle.getPoints();
      points.setNumberOfPoints(3);
      const pointsIds = model.triangle.getPointsIds();
      const numPoints = pointsIds.length;
      for (let i = 0; i < numPoints; i++) {
        weights[i] = 0;
      }
      for (let i = 0; i < numPoints - 2; i++) {
        const pt0 = [];
        points.getPoint(i, pt0);
        const pt1 = [];
        points.getPoint(i + 1, pt1);
        const pt2 = [];
        points.getPoint(i + 2, pt2);
        points.setData(Float32Array.from([...pt0, ...pt1, ...pt2]), 3);
        const status = model.triangle.evaluatePosition(x, closest, pc, tempWeights);
        const currentDist2 = status.dist2;
        if (status.evaluation >= 0 && (currentDist2 < minDist2 || currentDist2 === minDist2 && returnStatus === 0)) {
          returnStatus = status;
          if (closestPoint) {
            closestPoint[0] = closest[0];
            closestPoint[1] = closest[1];
            closestPoint[2] = closest[2];
          }
          pcoords[0] = pc[0];
          pcoords[1] = pc[1];
          minDist2 = currentDist2;
          activeWeights[0] = tempWeights[0];
          activeWeights[1] = tempWeights[1];
          activeWeights[2] = tempWeights[2];
        }
      }
      dist22[0] = minDist2;
      weights[0] = activeWeights[0];
      weights[1] = activeWeights[1];
      weights[2] = activeWeights[2];
      return returnStatus;
    };
    publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {
      const idx = [[0, 1, 2], [1, 0, 2]];
      const order = subId % 2;
      const numPoints = model.pointsIds.length;
      for (let i = 0; i < numPoints; i++) {
        weights[i] = 0;
      }
      const u3 = 1 - pcoords[0] - pcoords[1];
      weights[subId] = u3;
      weights[subId + 1] = pcoords[0];
      weights[subId + 2] = pcoords[1];
      const pt1 = [];
      model.points.getPoint(subId + idx[order][0], pt1);
      const pt2 = [];
      model.points.getPoint(subId + idx[order][1], pt2);
      const pt3 = [];
      model.points.getPoint(subId + idx[order][2], pt3);
      for (let i = 0; i < 3; i++) {
        x[i] = pt1[i] * weights[subId] + pt2[i] * weights[subId + 1] + pt3[i] * weights[subId + 2];
      }
    };
    publicAPI.cellBoundary = (subId, pcoords, pts) => {
      const idx = [[0, 1, 2], [1, 0, 2]];
      const order = subId % 2;
      const pointsIds = model.triangle.getPointsIds();
      pointsIds[0] = model.pointsIds[idx[order][0]];
      pointsIds[1] = model.pointsIds[idx[order][1]];
      pointsIds[2] = model.pointsIds[idx[order][2]];
      return model.triangle.cellBoundary(0, pcoords, pts);
    };
    publicAPI.getEdge = (edgeId) => {
      let id1;
      let id2;
      const numPoints = model.pointsIds.length;
      if (edgeId === 0) {
        id1 = 0;
        id2 = 1;
      } else if (edgeId === numPoints - 1) {
        id1 = edgeId - 1;
        id2 = edgeId;
      } else {
        id1 = edgeId - 1;
        id2 = edgeId + 1;
      }
      model.line.getPointsIds()[0] = model.pointsIds[id1];
      model.line.getPointsIds()[1] = model.pointsIds[id2];
      model.line.getPoints().setPoint(0, model.points.getPoint(id1));
      model.line.getPoints().setPoint(1, model.points.getPoint(id2));
      return model.line;
    };
    publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
      const numTris = model.pointsIds.length - 2;
      const points = model.triangle.getPoints();
      points.setNumberOfPoints(3);
      for (let i = 0; i < numTris; i++) {
        const pt0 = [];
        model.points.getPoint(model.pointsIds[i], pt0);
        const pt1 = [];
        model.points.getPoint(model.pointsIds[i + 1], pt1);
        const pt2 = [];
        model.points.getPoint(model.pointsIds[i + 2], pt2);
        points.setData(Float32Array.from([...pt0, ...pt1, ...pt2]), 3);
        const ret = model.triangle.intersectWithLine(p1, p2, tol, x, pcoords);
        if (ret.intersect) {
          return ret;
        }
      }
      return false;
    };
    publicAPI.triangulate = () => {
      const numTris = model.points.getNumberOfPoints() - 2;
      model.tris = new Array(3 * numTris);
      const idx = [[0, 1, 2], [1, 0, 2]];
      for (let subId = 0; subId < numTris; subId++) {
        const order = subId % 2;
        for (let i = 0; i < 3; i++) {
          model.tris[subId * 3 + i] = subId + idx[order][i];
        }
      }
      return true;
    };
    publicAPI.getPointArray = () => model.tris;
    publicAPI.derivatives = (subId, pcoords, values, dim, derivs) => {
      const pt0 = [];
      model.points.getPoint(subId, pt0);
      const pt1 = [];
      model.points.getPoint(subId + 1, pt1);
      const pt2 = [];
      model.points.getPoint(subId + 2, pt2);
      const points = model.triangle.getPoints();
      points.setPoint(0, ...pt0);
      points.setPoint(1, ...pt1);
      points.setPoint(2, ...pt2);
      model.triangle.derivatives(0, pcoords, values, dim, derivs);
    };
    publicAPI.getParametricCenter = (pcoords) => {
      pcoords[0] = 0.333333;
      pcoords[1] = 0.333333;
      pcoords[2] = 0;
      return Math.floor((model.pointsIds.length - 2) / 2);
    };
    publicAPI.contour = (value, cellScalars, locator, verts, lines, polys, inPd, outPd, inCd, cellId, outCd) => notImplemented4("contour")();
    publicAPI.clip = (value, cellScalars, locator, tris, inPd, outPd, inCd, cellId, outCd, insideOut) => notImplemented4("clip")();
  }
  var DEFAULT_VALUES27 = {
    line: null,
    triangle: null,
    tris: null
  };
  function extend28(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES27, initialValues);
    vtkCell$1.extend(publicAPI, model, initialValues);
    if (!model.line) {
      model.line = vtkLine$1.newInstance();
    }
    if (!model.triangle) {
      model.triangle = vtkTriangle$1.newInstance();
    }
    vtkTriangleStrip(publicAPI, model);
  }
  var newInstance30 = macro.newInstance(extend28, "vtkTriangleStrip");
  var vtkTriangleStrip$1 = {
    newInstance: newInstance30,
    extend: extend28,
    ...STATIC10
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
  var POLYDATA_FIELDS = ["verts", "lines", "polys", "strips"];

  // node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js
  var {
    vtkWarningMacro: vtkWarningMacro7
  } = macro;
  var CELL_FACTORY = {
    [CellType.VTK_LINE]: vtkLine$1,
    [CellType.VTK_QUAD]: vtkQuad$1,
    [CellType.VTK_POLY_LINE]: vtkLine$1,
    [CellType.VTK_TRIANGLE]: vtkTriangle$1,
    [CellType.VTK_TRIANGLE_STRIP]: vtkTriangleStrip$1,
    [CellType.VTK_POLY_LINE]: vtkPolyLine$1,
    [CellType.VTK_POLYGON]: vtkPolygon$1
  };
  function vtkPolyData(publicAPI, model) {
    model.classHierarchy.push("vtkPolyData");
    function camelize(str6) {
      return str6.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter) => letter.toUpperCase()).replace(/\s+/g, "");
    }
    POLYDATA_FIELDS.forEach((type) => {
      publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();
      if (!model[type]) {
        model[type] = vtkCellArray$1.newInstance();
      } else {
        model[type] = vtk(model[type]);
      }
    });
    publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);
    const superShallowCopy = publicAPI.shallowCopy;
    publicAPI.shallowCopy = function(other) {
      let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      superShallowCopy(other, debug);
      POLYDATA_FIELDS.forEach((type) => {
        model[type] = vtkCellArray$1.newInstance();
        model[type].shallowCopy(other.getReferenceByName(type));
      });
    };
    const superGetMTime = publicAPI.getMTime;
    publicAPI.getMTime = () => POLYDATA_FIELDS.reduce((mTime, type) => Math.max(mTime, model[type]?.getMTime() ?? mTime), superGetMTime());
    const superInitialize = publicAPI.initialize;
    publicAPI.initialize = () => {
      POLYDATA_FIELDS.forEach((type) => model[type]?.initialize());
      return superInitialize();
    };
    publicAPI.buildCells = () => {
      const nVerts = publicAPI.getNumberOfVerts();
      const nLines = publicAPI.getNumberOfLines();
      const nPolys = publicAPI.getNumberOfPolys();
      const nStrips = publicAPI.getNumberOfStrips();
      const nCells = nVerts + nLines + nPolys + nStrips;
      const types = new Uint8Array(nCells);
      let pTypes = types;
      const locs = new Uint32Array(nCells);
      let pLocs = locs;
      if (nVerts) {
        let nextCellPts = 0;
        model.verts.getCellSizes().forEach((numCellPts, index) => {
          pLocs[index] = nextCellPts;
          pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
          nextCellPts += numCellPts + 1;
        });
        pLocs = pLocs.subarray(nVerts);
        pTypes = pTypes.subarray(nVerts);
      }
      if (nLines) {
        let nextCellPts = 0;
        model.lines.getCellSizes().forEach((numCellPts, index) => {
          pLocs[index] = nextCellPts;
          pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
          if (numCellPts === 1) {
            vtkWarningMacro7("Building VTK_LINE ", index, " with only one point, but VTK_LINE needs at least two points. Check the input.");
          }
          nextCellPts += numCellPts + 1;
        });
        pLocs = pLocs.subarray(nLines);
        pTypes = pTypes.subarray(nLines);
      }
      if (nPolys) {
        let nextCellPts = 0;
        model.polys.getCellSizes().forEach((numCellPts, index) => {
          pLocs[index] = nextCellPts;
          switch (numCellPts) {
            case 3:
              pTypes[index] = CellType.VTK_TRIANGLE;
              break;
            case 4:
              pTypes[index] = CellType.VTK_QUAD;
              break;
            default:
              pTypes[index] = CellType.VTK_POLYGON;
              break;
          }
          if (numCellPts < 3) {
            vtkWarningMacro7("Building VTK_TRIANGLE ", index, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.");
          }
          nextCellPts += numCellPts + 1;
        });
        pLocs += pLocs.subarray(nPolys);
        pTypes += pTypes.subarray(nPolys);
      }
      if (nStrips) {
        let nextCellPts = 0;
        pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
        model.strips.getCellSizes().forEach((numCellPts, index) => {
          pLocs[index] = nextCellPts;
          nextCellPts += numCellPts + 1;
        });
      }
      model.cells = vtkCellTypes$1.newInstance();
      model.cells.setCellTypes(nCells, types, locs);
    };
    publicAPI.buildLinks = function() {
      let initialSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      if (model.cells === void 0) {
        publicAPI.buildCells();
      }
      model.links = vtkCellLinks$1.newInstance();
      if (initialSize > 0) {
        model.links.allocate(initialSize);
      } else {
        model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
      }
      model.links.buildLinks(publicAPI);
    };
    publicAPI.getCellType = (cellId) => model.cells.getCellType(cellId);
    publicAPI.getCellPoints = (cellId) => {
      const cellType = publicAPI.getCellType(cellId);
      let cells = null;
      switch (cellType) {
        case CellType.VTK_VERTEX:
        case CellType.VTK_POLY_VERTEX:
          cells = model.verts;
          break;
        case CellType.VTK_LINE:
        case CellType.VTK_POLY_LINE:
          cells = model.lines;
          break;
        case CellType.VTK_TRIANGLE:
        case CellType.VTK_QUAD:
        case CellType.VTK_POLYGON:
          cells = model.polys;
          break;
        case CellType.VTK_TRIANGLE_STRIP:
          cells = model.strips;
          break;
        default:
          cells = null;
          return {
            type: 0,
            cellPointIds: null
          };
      }
      const loc = model.cells.getCellLocation(cellId);
      const cellPointIds = cells.getCell(loc);
      return {
        cellType,
        cellPointIds
      };
    };
    publicAPI.getPointCells = (ptId) => model.links.getCells(ptId);
    publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
      const link1 = model.links.getLink(point1);
      const link2 = model.links.getLink(point2);
      return link1.cells.filter((cell) => cell !== cellId && link2.cells.indexOf(cell) !== -1);
    };
    publicAPI.getCell = function(cellId) {
      let cellHint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      const cellInfo = publicAPI.getCellPoints(cellId);
      const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
      cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
      return cell;
    };
    publicAPI.getMaxCellSize = () => POLYDATA_FIELDS.reduce((max4, type) => Math.max(max4, model[type]?.getMaxCellSize?.() ?? 0), 0);
  }
  var DEFAULT_VALUES28 = {
    // verts: null,
    // lines: null,
    // polys: null,
    // strips: null,
    // cells: null,
    // links: null,
  };
  function extend29(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES28, initialValues);
    vtkPointSet$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ["cells", "links"]);
    macro.setGet(publicAPI, model, ["verts", "lines", "polys", "strips"]);
    vtkPolyData(publicAPI, model);
  }
  var newInstance31 = macro.newInstance(extend29, "vtkPolyData");
  var vtkPolyData$1 = {
    newInstance: newInstance31,
    extend: extend29
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Prop/Constants.js
  var CoordinateSystem = {
    DISPLAY: 0,
    WORLD: 1
  };
  var Constants6 = {
    CoordinateSystem
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Prop.js
  var {
    CoordinateSystem: CoordinateSystem2
  } = Constants6;
  function notImplemented5(method) {
    return () => macro.vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
  }
  function vtkProp(publicAPI, model) {
    model.classHierarchy.push("vtkProp");
    publicAPI.getMTime = () => {
      let m1 = model.mtime;
      for (let index = 0; index < model.textures.length; ++index) {
        const m2 = model.textures[index].getMTime();
        if (m2 > m1) {
          m1 = m2;
        }
      }
      return m1;
    };
    publicAPI.processSelectorPixelBuffers = (selector, pixeloffsets) => {
    };
    publicAPI.getNestedProps = () => null;
    publicAPI.getActors = () => [];
    publicAPI.getActors2D = () => [];
    publicAPI.getVolumes = () => [];
    publicAPI.pick = notImplemented5("pick");
    publicAPI.hasKey = notImplemented5("hasKey");
    publicAPI.getNestedVisibility = () => model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
    publicAPI.getNestedPickable = () => model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
    publicAPI.getNestedDragable = () => model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
    publicAPI.getRedrawMTime = () => model.mtime;
    publicAPI.setEstimatedRenderTime = (t) => {
      model.estimatedRenderTime = t;
      model.savedEstimatedRenderTime = t;
    };
    publicAPI.restoreEstimatedRenderTime = () => {
      model.estimatedRenderTime = model.savedEstimatedRenderTime;
    };
    publicAPI.addEstimatedRenderTime = (t) => {
      model.estimatedRenderTime += t;
    };
    publicAPI.setAllocatedRenderTime = (t) => {
      model.allocatedRenderTime = t;
      model.savedEstimatedRenderTime = model.estimatedRenderTime;
      model.estimatedRenderTime = 0;
    };
    publicAPI.getSupportsSelection = () => false;
    publicAPI.getTextures = () => model.textures;
    publicAPI.hasTexture = (texture) => model.textures.indexOf(texture) !== -1;
    publicAPI.addTexture = (texture) => {
      if (texture && !publicAPI.hasTexture(texture)) {
        model.textures = model.textures.concat(texture);
        publicAPI.modified();
      }
    };
    publicAPI.removeTexture = (texture) => {
      const newTextureList = model.textures.filter((item) => item !== texture);
      if (model.textures.length !== newTextureList.length) {
        model.textures = newTextureList;
        publicAPI.modified();
      }
    };
    publicAPI.removeAllTextures = () => {
      model.textures = [];
      publicAPI.modified();
    };
    publicAPI.setCoordinateSystemToWorld = () => publicAPI.setCoordinateSystem(CoordinateSystem2.WORLD);
    publicAPI.setCoordinateSystemToDisplay = () => publicAPI.setCoordinateSystem(CoordinateSystem2.DISPLAY);
  }
  var DEFAULT_VALUES29 = {
    // _parentProp: null,
    allocatedRenderTime: 10,
    coordinateSystem: CoordinateSystem2.WORLD,
    dragable: true,
    estimatedRenderTime: 0,
    paths: null,
    pickable: true,
    renderTimeMultiplier: 1,
    savedEstimatedRenderTime: 0,
    textures: [],
    useBounds: true,
    visibility: true
  };
  function extend30(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES29, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["estimatedRenderTime", "allocatedRenderTime"]);
    macro.setGet(publicAPI, model, ["_parentProp", "coordinateSystem", "dragable", "pickable", "renderTimeMultiplier", "useBounds", "visibility"]);
    macro.moveToProtected(publicAPI, model, ["parentProp"]);
    vtkProp(publicAPI, model);
  }
  var newInstance32 = macro.newInstance(extend30, "vtkProp");
  var vtkProp$1 = {
    newInstance: newInstance32,
    extend: extend30,
    ...Constants6
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
  var VTK_EPSILON = 1e-6;
  function vtkProp3D(publicAPI, model) {
    model.classHierarchy.push("vtkProp3D");
    publicAPI.addPosition = (deltaXYZ) => {
      model.position = model.position.map((value, index) => value + deltaXYZ[index]);
      publicAPI.modified();
    };
    publicAPI.getOrientationWXYZ = () => {
      const q = quat_exports.create();
      mat4_exports.getRotation(q, model.rotation);
      const oaxis = new Float64Array(3);
      const w = quat_exports.getAxisAngle(oaxis, q);
      return [degreesFromRadians(w), oaxis[0], oaxis[1], oaxis[2]];
    };
    publicAPI.getOrientationQuaternion = function() {
      let out = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return mat4_exports.getRotation(out, model.rotation);
    };
    publicAPI.rotateX = (val) => {
      if (val === 0) {
        return;
      }
      mat4_exports.rotateX(model.rotation, model.rotation, radiansFromDegrees(val));
      publicAPI.modified();
    };
    publicAPI.rotateY = (val) => {
      if (val === 0) {
        return;
      }
      mat4_exports.rotateY(model.rotation, model.rotation, radiansFromDegrees(val));
      publicAPI.modified();
    };
    publicAPI.rotateZ = (val) => {
      if (val === 0) {
        return;
      }
      mat4_exports.rotateZ(model.rotation, model.rotation, radiansFromDegrees(val));
      publicAPI.modified();
    };
    publicAPI.rotateWXYZ = (degrees, x, y, z) => {
      if (degrees === 0 || x === 0 && y === 0 && z === 0) {
        return;
      }
      const angle2 = radiansFromDegrees(degrees);
      const q = quat_exports.create();
      quat_exports.setAxisAngle(q, [x, y, z], angle2);
      const quatMat = new Float64Array(16);
      mat4_exports.fromQuat(quatMat, q);
      mat4_exports.multiply(model.rotation, model.rotation, quatMat);
      publicAPI.modified();
    };
    publicAPI.rotateQuaternion = (orientationQuaternion) => {
      if (Math.abs(orientationQuaternion[3]) >= 1 - VTK_EPSILON) {
        return;
      }
      const oriQuatMat = mat4_exports.fromQuat(new Float64Array(16), orientationQuaternion);
      mat4_exports.multiply(model.rotation, model.rotation, oriQuatMat);
      publicAPI.modified();
    };
    publicAPI.setOrientation = (x, y, z) => {
      if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
        return false;
      }
      model.orientation = [x, y, z];
      mat4_exports.identity(model.rotation);
      publicAPI.rotateZ(z);
      publicAPI.rotateX(x);
      publicAPI.rotateY(y);
      publicAPI.modified();
      return true;
    };
    publicAPI.setOrientationFromQuaternion = (q) => {
      const rotation = mat4_exports.create();
      mat4_exports.fromQuat(rotation, q);
      if (!areMatricesEqual(rotation, model.rotation)) {
        model.rotation = rotation;
        publicAPI.modified();
        return true;
      }
      return false;
    };
    publicAPI.setUserMatrix = (matrix) => {
      if (areMatricesEqual(model.userMatrix, matrix)) {
        return false;
      }
      mat4_exports.copy(model.userMatrix, matrix);
      publicAPI.modified();
      return true;
    };
    publicAPI.getMatrix = () => {
      publicAPI.computeMatrix();
      return model.matrix;
    };
    publicAPI.computeMatrix = () => {
      if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
        mat4_exports.identity(model.matrix);
        if (model.userMatrix) {
          mat4_exports.multiply(model.matrix, model.matrix, model.userMatrix);
        }
        mat4_exports.translate(model.matrix, model.matrix, model.origin);
        mat4_exports.translate(model.matrix, model.matrix, model.position);
        mat4_exports.multiply(model.matrix, model.matrix, model.rotation);
        mat4_exports.scale(model.matrix, model.matrix, model.scale);
        mat4_exports.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
        mat4_exports.transpose(model.matrix, model.matrix);
        model.isIdentity = true;
        for (let i = 0; i < 4; ++i) {
          for (let j = 0; j < 4; ++j) {
            if ((i === j ? 1 : 0) !== model.matrix[i + j * 4]) {
              model.isIdentity = false;
            }
          }
        }
        model.matrixMTime.modified();
      }
    };
    publicAPI.getBoundsByReference = () => {
      if (model.mapper === null) {
        return model.bounds;
      }
      const bds = model.mapper.getBounds();
      if (!bds || bds.length !== 6) {
        return bds;
      }
      if (bds[0] > bds[1]) {
        model.mapperBounds = bds;
        model.bounds = [...vtkBoundingBox.INIT_BOUNDS];
        model.boundsMTime.modified();
        return bds;
      }
      if (!model.mapperBounds || !bds.every((_, i) => bds[i] === model.mapperBounds[i]) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
        macro.vtkDebugMacro("Recomputing bounds...");
        model.mapperBounds = bds;
        publicAPI.computeMatrix();
        const transposedMatrix = new Float64Array(16);
        mat4_exports.transpose(transposedMatrix, model.matrix);
        vtkBoundingBox.transformBounds(bds, transposedMatrix, model.bounds);
        model.boundsMTime.modified();
      }
      return model.bounds;
    };
    publicAPI.getBounds = () => {
      const bounds = publicAPI.getBoundsByReference();
      try {
        return [...bounds];
      } catch {
        return bounds;
      }
    };
    publicAPI.getCenter = () => vtkBoundingBox.getCenter(model.bounds);
    publicAPI.getLength = () => vtkBoundingBox.getLength(model.bounds);
    publicAPI.getXRange = () => vtkBoundingBox.getXRange(model.bounds);
    publicAPI.getYRange = () => vtkBoundingBox.getYRange(model.bounds);
    publicAPI.getZRange = () => vtkBoundingBox.getZRange(model.bounds);
    publicAPI.getUserMatrix = () => model.userMatrix;
    function updateIdentityFlag() {
      publicAPI.computeMatrix();
    }
    publicAPI.onModified(updateIdentityFlag);
    publicAPI.getProperty = function() {
      let mapperInputPort = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      if (model.properties[mapperInputPort] == null) {
        model.properties[mapperInputPort] = publicAPI.makeProperty?.();
      }
      return model.properties[mapperInputPort];
    };
    publicAPI.getProperties = () => {
      if (model.properties.length === 0) {
        model.properties[0] = publicAPI.makeProperty?.();
      }
      return model.properties;
    };
    publicAPI.setProperty = (firstArg, secondArg) => {
      const useInputPortArgument = Number.isInteger(firstArg);
      const [mapperInputPort, property] = useInputPortArgument ? [firstArg, secondArg] : [0, firstArg];
      if (model.properties[mapperInputPort] === property) {
        return false;
      }
      model.properties[mapperInputPort] = property;
      return true;
    };
    publicAPI.getMTime = () => {
      let mt = model.mtime;
      model.properties.forEach((property) => {
        if (property !== null) {
          const time = property.getMTime();
          mt = time > mt ? time : mt;
        }
      });
      return mt;
    };
  }
  var DEFAULT_VALUES30 = {
    origin: [0, 0, 0],
    position: [0, 0, 0],
    orientation: [0, 0, 0],
    rotation: null,
    scale: [1, 1, 1],
    bounds: [...vtkBoundingBox.INIT_BOUNDS],
    properties: [],
    userMatrix: null,
    userMatrixMTime: null,
    cachedProp3D: null,
    isIdentity: true,
    matrixMTime: null
  };
  function extend31(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES30, initialValues);
    vtkProp$1.extend(publicAPI, model, initialValues);
    model.matrixMTime = {};
    macro.obj(model.matrixMTime);
    macro.get(publicAPI, model, ["isIdentity"]);
    macro.getArray(publicAPI, model, ["orientation"]);
    macro.setGetArray(publicAPI, model, ["origin", "position", "scale"], 3);
    macro.setGet(publicAPI, model, ["properties"]);
    model.matrix = mat4_exports.identity(new Float64Array(16));
    model.rotation = mat4_exports.identity(new Float64Array(16));
    model.userMatrix = mat4_exports.identity(new Float64Array(16));
    model.transform = null;
    vtkProp3D(publicAPI, model);
  }
  var newInstance33 = macro.newInstance(extend31, "vtkProp3D");
  var vtkProp3D$1 = {
    newInstance: newInstance33,
    extend: extend31
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
  var Shading = {
    FLAT: 0,
    GOURAUD: 1,
    PHONG: 2
  };
  var Representation = {
    POINTS: 0,
    WIREFRAME: 1,
    SURFACE: 2
  };
  var Interpolation = Shading;
  var PropertyConst = {
    Shading,
    Representation,
    Interpolation
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Property.js
  var {
    Representation: Representation2,
    Interpolation: Interpolation2
  } = PropertyConst;
  function notImplemented6(method) {
    return () => macro.vtkErrorMacro(`vtkProperty::${method} - NOT IMPLEMENTED`);
  }
  function vtkProperty(publicAPI, model) {
    model.classHierarchy.push("vtkProperty");
    publicAPI.setColor = (r, g, b) => {
      if (Array.isArray(r)) {
        if (model.color[0] !== r[0] || model.color[1] !== r[1] || model.color[2] !== r[2]) {
          model.color[0] = r[0];
          model.color[1] = r[1];
          model.color[2] = r[2];
          publicAPI.modified();
        }
      } else if (model.color[0] !== r || model.color[1] !== g || model.color[2] !== b) {
        model.color[0] = r;
        model.color[1] = g;
        model.color[2] = b;
        publicAPI.modified();
      }
      publicAPI.setDiffuseColor(model.color);
      publicAPI.setAmbientColor(model.color);
      publicAPI.setSpecularColor(model.color);
    };
    publicAPI.computeCompositeColor = notImplemented6("ComputeCompositeColor");
    publicAPI.getColor = () => {
      let norm2 = 0;
      if (model.ambient + model.diffuse + model.specular > 0) {
        norm2 = 1 / (model.ambient + model.diffuse + model.specular);
      }
      for (let i = 0; i < 3; i++) {
        model.color[i] = norm2 * (model.ambient * model.ambientColor[i] + model.diffuse * model.diffuseColor[i] + model.specular * model.specularColor[i]);
      }
      return [].concat(model.color);
    };
    publicAPI.setSpecularPower = (specularPower) => {
      const roughness = 1 / Math.max(1, specularPower);
      if (model.roughness !== roughness || model.specularPower !== specularPower) {
        model.specularPower = specularPower;
        model.roughness = roughness;
        publicAPI.modified();
      }
    };
    publicAPI.addShaderVariable = notImplemented6("AddShaderVariable");
    publicAPI.setInterpolationToFlat = () => publicAPI.setInterpolation(Interpolation2.FLAT);
    publicAPI.setInterpolationToGouraud = () => publicAPI.setInterpolation(Interpolation2.GOURAUD);
    publicAPI.setInterpolationToPhong = () => publicAPI.setInterpolation(Interpolation2.PHONG);
    publicAPI.getInterpolationAsString = () => macro.enumToString(Interpolation2, model.interpolation);
    publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation2.WIREFRAME);
    publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation2.SURFACE);
    publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation2.POINTS);
    publicAPI.getRepresentationAsString = () => macro.enumToString(Representation2, model.representation);
  }
  var DEFAULT_VALUES31 = {
    color: [1, 1, 1],
    ambientColor: [1, 1, 1],
    diffuseColor: [1, 1, 1],
    specularColor: [1, 1, 1],
    edgeColor: [0, 0, 0],
    ambient: 0,
    diffuse: 1,
    metallic: 0,
    roughness: 0.6,
    normalStrength: 1,
    emission: 1,
    baseIOR: 1.45,
    specular: 0,
    specularPower: 1,
    opacity: 1,
    interpolation: Interpolation2.GOURAUD,
    representation: Representation2.SURFACE,
    edgeVisibility: false,
    backfaceCulling: false,
    frontfaceCulling: false,
    pointSize: 1,
    lineWidth: 1,
    lighting: true,
    shading: false,
    materialName: null,
    ORMTexture: null,
    RMTexture: null
  };
  function extend32(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES31, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["lighting", "interpolation", "ambient", "diffuse", "metallic", "roughness", "normalStrength", "emission", "baseIOR", "specular", "specularPower", "opacity", "edgeVisibility", "lineWidth", "pointSize", "backfaceCulling", "frontfaceCulling", "representation", "diffuseTexture", "metallicTexture", "roughnessTexture", "normalTexture", "ambientOcclusionTexture", "emissionTexture", "ORMTexture", "RMTexture"]);
    macro.setGetArray(publicAPI, model, ["ambientColor", "specularColor", "diffuseColor", "edgeColor"], 3);
    vtkProperty(publicAPI, model);
  }
  var newInstance34 = macro.newInstance(extend32, "vtkProperty");
  var vtkProperty$1 = {
    newInstance: newInstance34,
    extend: extend32,
    ...PropertyConst
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
  function vtkActor(publicAPI, model) {
    model.classHierarchy.push("vtkActor");
    const superClass = {
      ...publicAPI
    };
    publicAPI.getActors = () => [publicAPI];
    publicAPI.getIsOpaque = () => {
      if (model.forceOpaque) {
        return true;
      }
      if (model.forceTranslucent) {
        return false;
      }
      if (!model.properties[0]) {
        publicAPI.getProperty();
      }
      let isOpaque = model.properties[0].getOpacity() >= 1;
      isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());
      isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
      return isOpaque;
    };
    publicAPI.hasTranslucentPolygonalGeometry = () => {
      if (model.mapper === null) {
        return false;
      }
      if (!model.properties[0]) {
        publicAPI.getProperty();
      }
      return !publicAPI.getIsOpaque();
    };
    publicAPI.makeProperty = vtkProperty$1.newInstance;
    publicAPI.getMTime = () => {
      let mt = superClass.getMTime();
      if (model.backfaceProperty !== null) {
        const time = model.backfaceProperty.getMTime();
        mt = time > mt ? time : mt;
      }
      return mt;
    };
    publicAPI.getRedrawMTime = () => {
      let mt = model.mtime;
      if (model.mapper !== null) {
        let time = model.mapper.getMTime();
        mt = time > mt ? time : mt;
        if (model.mapper.getInput() !== null) {
          model.mapper.getInputAlgorithm().update();
          time = model.mapper.getInput().getMTime();
          mt = time > mt ? time : mt;
        }
      }
      return mt;
    };
    publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
    publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
      if (model.mapper && model.mapper.processSelectorPixelBuffers) {
        model.mapper.processSelectorPixelBuffers(selector, pixelOffsets);
      }
    };
  }
  var DEFAULT_VALUES32 = {
    mapper: null,
    backfaceProperty: null,
    forceOpaque: false,
    forceTranslucent: false
  };
  function extend33(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES32, initialValues);
    vtkProp3D$1.extend(publicAPI, model, initialValues);
    model.boundsMTime = {};
    macro.obj(model.boundsMTime);
    macro.setGet(publicAPI, model, ["backfaceProperty", "forceOpaque", "forceTranslucent", "mapper"]);
    vtkActor(publicAPI, model);
  }
  var newInstance35 = macro.newInstance(extend33, "vtkActor");
  var vtkActor$1 = {
    newInstance: newInstance35,
    extend: extend33
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper.js
  function vtkAbstractMapper(publicAPI, model) {
    model.classHierarchy.push("vtkAbstractMapper");
    publicAPI.update = () => {
      publicAPI.getInputData();
    };
    publicAPI.addClippingPlane = (plane) => {
      if (!plane.isA("vtkPlane")) {
        return false;
      }
      if (!model.clippingPlanes.includes(plane)) {
        model.clippingPlanes.push(plane);
        publicAPI.modified();
        return true;
      }
      return false;
    };
    publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;
    publicAPI.removeAllClippingPlanes = () => {
      if (model.clippingPlanes.length === 0) {
        return false;
      }
      model.clippingPlanes.length = 0;
      publicAPI.modified();
      return true;
    };
    publicAPI.removeClippingPlane = (clippingPlane) => {
      const i = model.clippingPlanes.indexOf(clippingPlane);
      if (i === -1) {
        return false;
      }
      model.clippingPlanes.splice(i, 1);
      publicAPI.modified();
      return true;
    };
    publicAPI.getClippingPlanes = () => model.clippingPlanes;
    publicAPI.setClippingPlanes = (planes) => {
      if (!planes) {
        return;
      }
      if (!Array.isArray(planes)) {
        publicAPI.addClippingPlane(planes);
      } else {
        const nbPlanes = planes.length;
        for (let i = 0; i < nbPlanes && i < 6; i++) {
          publicAPI.addClippingPlane(planes[i]);
        }
      }
    };
    publicAPI.getClippingPlaneInDataCoords = (propMatrix, i, hnormal) => {
      const clipPlanes = model.clippingPlanes;
      const mat = propMatrix;
      if (clipPlanes) {
        const n = clipPlanes.length;
        if (i >= 0 && i < n) {
          const plane = clipPlanes[i];
          const normal = plane.getNormal();
          const origin = plane.getOrigin();
          const v1 = normal[0];
          const v2 = normal[1];
          const v3 = normal[2];
          const v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);
          hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
          hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
          hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
          hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];
          return;
        }
      }
      macro.vtkErrorMacro(`Clipping plane index ${i} is out of range.`);
    };
  }
  var DEFAULT_VALUES33 = {
    clippingPlanes: []
  };
  function extend34(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES33, initialValues);
    macro.obj(publicAPI, model);
    macro.algo(publicAPI, model, 1, 0);
    if (!model.clippingPlanes) {
      model.clippingPlanes = [];
    }
    vtkAbstractMapper(publicAPI, model);
  }
  var vtkAbstractMapper$1 = {
    extend: extend34
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
  function vtkAbstractMapper3D(publicAPI, model) {
    publicAPI.getBounds = () => {
      macro.vtkErrorMacro(`vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED`);
      return createUninitializedBounds();
    };
    publicAPI.getCenter = () => {
      const bounds = publicAPI.getBounds();
      model.center = vtkBoundingBox.isValid(bounds) ? vtkBoundingBox.getCenter(bounds) : null;
      return model.center?.slice();
    };
    publicAPI.getLength = () => {
      const bounds = publicAPI.getBounds();
      return vtkBoundingBox.getDiagonalLength(bounds);
    };
  }
  var defaultValues2 = (initialValues) => ({
    bounds: [...vtkBoundingBox.INIT_BOUNDS],
    center: [0, 0, 0],
    viewSpecificProperties: {},
    ...initialValues
  });
  function extend35(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, defaultValues2(initialValues));
    vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["viewSpecificProperties"]);
    vtkAbstractMapper3D(publicAPI, model);
  }
  var vtkAbstractMapper3D$1 = {
    extend: extend35
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js
  var StructuredType = {
    UNCHANGED: 0,
    SINGLE_POINT: 1,
    X_LINE: 2,
    Y_LINE: 3,
    Z_LINE: 4,
    XY_PLANE: 5,
    YZ_PLANE: 6,
    XZ_PLANE: 7,
    XYZ_GRID: 8,
    EMPTY: 9
  };
  var Constants7 = {
    StructuredType
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/StructuredData.js
  var {
    StructuredType: StructuredType2
  } = Constants7;
  function getDataDescriptionFromExtent(inExt) {
    let dataDim = 0;
    for (let i = 0; i < 3; ++i) {
      if (inExt[i * 2] < inExt[i * 2 + 1]) {
        dataDim++;
      }
    }
    if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {
      return StructuredType2.EMPTY;
    }
    if (dataDim === 3) {
      return StructuredType2.XYZ_GRID;
    }
    if (dataDim === 2) {
      if (inExt[0] === inExt[1]) {
        return StructuredType2.YZ_PLANE;
      }
      if (inExt[2] === inExt[3]) {
        return StructuredType2.XZ_PLANE;
      }
      return StructuredType2.XY_PLANE;
    }
    if (dataDim === 1) {
      if (inExt[0] < inExt[1]) {
        return StructuredType2.X_LINE;
      }
      if (inExt[2] < inExt[3]) {
        return StructuredType2.Y_LINE;
      }
      return StructuredType2.Z_LINE;
    }
    return StructuredType2.SINGLE_POINT;
  }
  var vtkStructuredData = {
    getDataDescriptionFromExtent,
    ...Constants7
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
  var {
    vtkErrorMacro: vtkErrorMacro12
  } = macro;
  function vtkImageData(publicAPI, model) {
    model.classHierarchy.push("vtkImageData");
    publicAPI.setExtent = function() {
      if (model.deleted) {
        vtkErrorMacro12("instance deleted - cannot call any method");
        return false;
      }
      for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {
        inExtent[_key] = arguments[_key];
      }
      const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;
      if (extentArray.length !== 6) {
        return false;
      }
      const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);
      if (changeDetected) {
        model.extent = extentArray.slice();
        model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);
        publicAPI.modified();
      }
      return changeDetected;
    };
    publicAPI.setDimensions = function() {
      let i;
      let j;
      let k;
      if (model.deleted) {
        vtkErrorMacro12("instance deleted - cannot call any method");
        return;
      }
      if (arguments.length === 1) {
        const array = arguments.length <= 0 ? void 0 : arguments[0];
        i = array[0];
        j = array[1];
        k = array[2];
      } else if (arguments.length === 3) {
        i = arguments.length <= 0 ? void 0 : arguments[0];
        j = arguments.length <= 1 ? void 0 : arguments[1];
        k = arguments.length <= 2 ? void 0 : arguments[2];
      } else {
        vtkErrorMacro12("Bad dimension specification");
        return;
      }
      publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);
    };
    publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];
    publicAPI.getNumberOfCells = () => {
      const dims = publicAPI.getDimensions();
      let nCells = 1;
      for (let i = 0; i < 3; i++) {
        if (dims[i] === 0) {
          return 0;
        }
        if (dims[i] > 1) {
          nCells *= dims[i] - 1;
        }
      }
      return nCells;
    };
    publicAPI.getNumberOfPoints = () => {
      const dims = publicAPI.getDimensions();
      return dims[0] * dims[1] * dims[2];
    };
    publicAPI.getPoint = (index) => {
      const dims = publicAPI.getDimensions();
      if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
        vtkErrorMacro12("Requesting a point from an empty image.");
        return null;
      }
      const ijk = new Float64Array(3);
      switch (model.dataDescription) {
        case StructuredType.EMPTY:
          return null;
        case StructuredType.SINGLE_POINT:
          break;
        case StructuredType.X_LINE:
          ijk[0] = index;
          break;
        case StructuredType.Y_LINE:
          ijk[1] = index;
          break;
        case StructuredType.Z_LINE:
          ijk[2] = index;
          break;
        case StructuredType.XY_PLANE:
          ijk[0] = index % dims[0];
          ijk[1] = index / dims[0];
          break;
        case StructuredType.YZ_PLANE:
          ijk[1] = index % dims[1];
          ijk[2] = index / dims[1];
          break;
        case StructuredType.XZ_PLANE:
          ijk[0] = index % dims[0];
          ijk[2] = index / dims[0];
          break;
        case StructuredType.XYZ_GRID:
          ijk[0] = index % dims[0];
          ijk[1] = index / dims[0] % dims[1];
          ijk[2] = index / (dims[0] * dims[1]);
          break;
        default:
          vtkErrorMacro12("Invalid dataDescription");
          break;
      }
      const coords = [0, 0, 0];
      publicAPI.indexToWorld(ijk, coords);
      return coords;
    };
    publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());
    publicAPI.extentToBounds = (ex) => vtkBoundingBox.transformBounds(ex, model.indexToWorld);
    publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);
    publicAPI.computeTransforms = () => {
      mat4_exports.fromTranslation(model.indexToWorld, model.origin);
      model.indexToWorld[0] = model.direction[0];
      model.indexToWorld[1] = model.direction[1];
      model.indexToWorld[2] = model.direction[2];
      model.indexToWorld[4] = model.direction[3];
      model.indexToWorld[5] = model.direction[4];
      model.indexToWorld[6] = model.direction[5];
      model.indexToWorld[8] = model.direction[6];
      model.indexToWorld[9] = model.direction[7];
      model.indexToWorld[10] = model.direction[8];
      mat4_exports.scale(model.indexToWorld, model.indexToWorld, model.spacing);
      mat4_exports.invert(model.worldToIndex, model.indexToWorld);
    };
    publicAPI.indexToWorld = function(ain) {
      let aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      vec3_exports.transformMat4(aout, ain, model.indexToWorld);
      return aout;
    };
    publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;
    publicAPI.worldToIndex = function(ain) {
      let aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      vec3_exports.transformMat4(aout, ain, model.worldToIndex);
      return aout;
    };
    publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;
    publicAPI.indexToWorldBounds = function(bin) {
      let bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);
    };
    publicAPI.worldToIndexBounds = function(bin) {
      let bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);
    };
    model._onOriginChanged = publicAPI.computeTransforms;
    model._onDirectionChanged = publicAPI.computeTransforms;
    model._onSpacingChanged = publicAPI.computeTransforms;
    publicAPI.computeTransforms();
    publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());
    publicAPI.computeHistogram = function(worldBounds) {
      let voxelFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      const bounds = [0, 0, 0, 0, 0, 0];
      publicAPI.worldToIndexBounds(worldBounds, bounds);
      const point1 = [0, 0, 0];
      const point2 = [0, 0, 0];
      vtkBoundingBox.computeCornerPoints(bounds, point1, point2);
      roundVector(point1, point1);
      roundVector(point2, point2);
      const dimensions = publicAPI.getDimensions();
      clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);
      clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);
      const yStride = dimensions[0];
      const zStride = dimensions[0] * dimensions[1];
      const pixels = publicAPI.getPointData().getScalars().getData();
      let maximum = -Infinity;
      let minimum = Infinity;
      let sumOfSquares = 0;
      let isum = 0;
      let inum = 0;
      for (let z = point1[2]; z <= point2[2]; z++) {
        for (let y = point1[1]; y <= point2[1]; y++) {
          let index = point1[0] + y * yStride + z * zStride;
          for (let x = point1[0]; x <= point2[0]; x++) {
            if (!voxelFunction || voxelFunction([x, y, z], bounds)) {
              const pixel = pixels[index];
              if (pixel > maximum) maximum = pixel;
              if (pixel < minimum) minimum = pixel;
              sumOfSquares += pixel * pixel;
              isum += pixel;
              inum += 1;
            }
            ++index;
          }
        }
      }
      const average = inum > 0 ? isum / inum : 0;
      const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;
      const sigma = Math.sqrt(variance);
      return {
        minimum,
        maximum,
        average,
        variance,
        sigma,
        count: inum
      };
    };
    publicAPI.computeIncrements = function(extent) {
      let numberOfComponents = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const increments = [];
      let incr = numberOfComponents;
      for (let idx = 0; idx < 3; ++idx) {
        increments[idx] = incr;
        incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;
      }
      return increments;
    };
    publicAPI.computeOffsetIndex = (_ref) => {
      let [i, j, k] = _ref;
      const extent = publicAPI.getExtent();
      const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
      const increments = publicAPI.computeIncrements(extent, numberOfComponents);
      return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);
    };
    publicAPI.getOffsetIndexFromWorld = (xyz) => {
      const extent = publicAPI.getExtent();
      const index = publicAPI.worldToIndex(xyz);
      for (let idx = 0; idx < 3; ++idx) {
        if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {
          vtkErrorMacro12(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);
          return NaN;
        }
      }
      return publicAPI.computeOffsetIndex(index);
    };
    publicAPI.getScalarValueFromWorld = function(xyz) {
      let comp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
      if (comp < 0 || comp >= numberOfComponents) {
        vtkErrorMacro12(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);
        return NaN;
      }
      const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
      if (Number.isNaN(offsetIndex)) {
        return offsetIndex;
      }
      return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);
    };
    const superInitialize = publicAPI.initialize;
    publicAPI.initialize = () => {
      publicAPI.set({
        direction: mat3_exports.identity(model.direction),
        spacing: [1, 1, 1],
        origin: [0, 0, 0],
        extent: [0, -1, 0, -1, 0, -1],
        dataDescription: StructuredType.EMPTY
      });
      return superInitialize();
    };
  }
  var DEFAULT_VALUES34 = {
    direction: null,
    // a mat3
    indexToWorld: null,
    // a mat4
    worldToIndex: null,
    // a mat4
    spacing: [1, 1, 1],
    origin: [0, 0, 0],
    extent: [0, -1, 0, -1, 0, -1],
    dataDescription: StructuredType.EMPTY
  };
  function extend36(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES34, initialValues);
    vtkDataSet$1.extend(publicAPI, model, initialValues);
    if (!model.direction) {
      model.direction = mat3_exports.identity(new Float64Array(9));
    } else if (Array.isArray(model.direction)) {
      model.direction = new Float64Array(model.direction.slice(0, 9));
    }
    model.indexToWorld = new Float64Array(16);
    model.worldToIndex = new Float64Array(16);
    macro.get(publicAPI, model, ["indexToWorld", "worldToIndex"]);
    macro.setGetArray(publicAPI, model, ["origin", "spacing"], 3);
    macro.setGetArray(publicAPI, model, ["direction"], 9);
    macro.getArray(publicAPI, model, ["extent"], 6);
    vtkImageData(publicAPI, model);
  }
  var newInstance36 = macro.newInstance(extend36, "vtkImageData");
  var vtkImageData$1 = {
    newInstance: newInstance36,
    extend: extend36
  };

  // node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors/Constants.js
  var VectorMode = {
    MAGNITUDE: 0,
    COMPONENT: 1,
    RGBCOLORS: 2
  };
  var ScalarMappingTarget = {
    LUMINANCE: 1,
    LUMINANCE_ALPHA: 2,
    RGB: 3,
    RGBA: 4
  };
  var Scale = {
    LINEAR: 0,
    LOG10: 1
  };
  var vtkScalarsToColors = {
    VectorMode,
    ScalarMappingTarget,
    Scale
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Constants.js
  var ColorMode = {
    DEFAULT: 0,
    MAP_SCALARS: 1,
    DIRECT_SCALARS: 2
  };
  var ScalarMode = {
    DEFAULT: 0,
    USE_POINT_DATA: 1,
    USE_CELL_DATA: 2,
    USE_POINT_FIELD_DATA: 3,
    USE_CELL_FIELD_DATA: 4,
    USE_FIELD_DATA: 5
  };
  var GetArray = {
    BY_ID: 0,
    BY_NAME: 1
  };
  var Constants8 = {
    ColorMode,
    GetArray,
    ScalarMode
  };

  // node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js
  var {
    ScalarMappingTarget: ScalarMappingTarget2,
    Scale: Scale2,
    VectorMode: VectorMode2
  } = vtkScalarsToColors;
  var {
    VtkDataTypes: VtkDataTypes2
  } = vtkDataArray$1;
  var {
    ColorMode: ColorMode2
  } = Constants8;
  var {
    vtkErrorMacro: vtkErrorMacro13
  } = macro;
  function intColorToUChar(c) {
    return c;
  }
  function floatColorToUChar(c) {
    return Math.floor(c * 255 + 0.5);
  }
  function vtkScalarsToColors2(publicAPI, model) {
    model.classHierarchy.push("vtkScalarsToColors");
    publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode2.MAGNITUDE);
    publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode2.COMPONENT);
    publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode2.RGBCOLORS);
    publicAPI.build = () => {
    };
    publicAPI.isOpaque = () => true;
    publicAPI.setAnnotations = (values, annotations) => {
      if (values && !annotations || !values && annotations) {
        return;
      }
      if (values && annotations && values.length !== annotations.length) {
        vtkErrorMacro13("Values and annotations do not have the same number of tuples so ignoring");
        return;
      }
      model.annotationArray = [];
      if (annotations && values) {
        const num = annotations.length;
        for (let i = 0; i < num; i++) {
          model.annotationArray.push({
            value: values[i],
            annotation: String(annotations[i])
          });
        }
      }
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    };
    publicAPI.setAnnotation = (value, annotation) => {
      let i = publicAPI.checkForAnnotatedValue(value);
      let modified = false;
      if (i >= 0) {
        if (model.annotationArray[i].annotation !== annotation) {
          model.annotationArray[i].annotation = annotation;
          modified = true;
        }
      } else {
        model.annotationArray.push({
          value,
          annotation
        });
        i = model.annotationArray.length - 1;
        modified = true;
      }
      if (modified) {
        publicAPI.updateAnnotatedValueMap();
        publicAPI.modified();
      }
      return i;
    };
    publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;
    publicAPI.getAnnotatedValue = (idx) => {
      if (idx < 0 || idx >= model.annotationArray.length) {
        return null;
      }
      return model.annotationArray[idx].value;
    };
    publicAPI.getAnnotation = (idx) => {
      if (model.annotationArray[idx] === void 0) {
        return null;
      }
      return model.annotationArray[idx].annotation;
    };
    publicAPI.getAnnotatedValueIndex = (val) => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;
    publicAPI.removeAnnotation = (value) => {
      const i = publicAPI.checkForAnnotatedValue(value);
      const needToRemove = i >= 0;
      if (needToRemove) {
        model.annotationArray.splice(i, 1);
        publicAPI.updateAnnotatedValueMap();
        publicAPI.modified();
      }
      return needToRemove;
    };
    publicAPI.resetAnnotations = () => {
      model.annotationArray = [];
      model.annotatedValueMap = [];
      publicAPI.modified();
    };
    publicAPI.getAnnotationColor = (val, rgba2) => {
      if (model.indexedLookup) {
        const i = publicAPI.getAnnotatedValueIndex(val);
        publicAPI.getIndexedColor(i, rgba2);
      } else {
        publicAPI.getColor(parseFloat(val), rgba2);
        rgba2[3] = 1;
      }
    };
    publicAPI.checkForAnnotatedValue = (value) => publicAPI.getAnnotatedValueIndexInternal(value);
    publicAPI.getAnnotatedValueIndexInternal = (value) => {
      if (model.annotatedValueMap[value] !== void 0) {
        const na = model.annotationArray.length;
        return model.annotatedValueMap[value] % na;
      }
      return -1;
    };
    publicAPI.getIndexedColor = (val, rgba2) => {
      rgba2[0] = 0;
      rgba2[1] = 0;
      rgba2[2] = 0;
      rgba2[3] = 0;
    };
    publicAPI.updateAnnotatedValueMap = () => {
      model.annotatedValueMap = [];
      const na = model.annotationArray.length;
      for (let i = 0; i < na; i++) {
        model.annotatedValueMap[model.annotationArray[i].value] = i;
      }
    };
    publicAPI.mapScalars = (scalars, colorMode, componentIn) => {
      const numberOfComponents = scalars.getNumberOfComponents();
      let newColors = null;
      if (colorMode === ColorMode2.DEFAULT && (scalars.getDataType() === VtkDataTypes2.UNSIGNED_CHAR || scalars.getDataType() === VtkDataTypes2.UNSIGNED_CHAR_CLAMPED) || colorMode === ColorMode2.DIRECT_SCALARS && scalars) {
        newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
      } else {
        const newscalars = {
          type: "vtkDataArray",
          name: "temp",
          numberOfComponents: 4,
          dataType: VtkDataTypes2.UNSIGNED_CHAR
        };
        const s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
        newscalars.values = s;
        newscalars.size = s.length;
        newColors = vtkDataArray$1.newInstance(newscalars);
        let component = componentIn;
        if (component < 0 && numberOfComponents > 1) {
          publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, -1, -1);
        } else {
          if (component < 0) {
            component = 0;
          }
          if (component >= numberOfComponents) {
            component = numberOfComponents - 1;
          }
          publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, component);
        }
      }
      return newColors;
    };
    publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {
      const length4 = input.getNumberOfTuples();
      const inIncr = input.getNumberOfComponents();
      const outputV = output.getData();
      const inputV = input.getData();
      for (let i = 0; i < length4; i++) {
        let sum = 0;
        for (let j = 0; j < compsToUse; j++) {
          sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];
        }
        outputV[i] = Math.sqrt(sum);
      }
    };
    publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {
      let vectorMode = publicAPI.getVectorMode();
      let vectorSize = vectorSizeIn;
      let vectorComponent = vectorComponentIn;
      const inComponents = input.getNumberOfComponents();
      if (vectorMode === VectorMode2.COMPONENT) {
        if (vectorComponent === -1) {
          vectorComponent = publicAPI.getVectorComponent();
        }
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
      } else {
        if (vectorSize === -1) {
          vectorSize = publicAPI.getVectorSize();
        }
        if (vectorSize <= 0) {
          vectorComponent = 0;
          vectorSize = inComponents;
        } else {
          if (vectorComponent < 0) {
            vectorComponent = 0;
          }
          if (vectorComponent >= inComponents) {
            vectorComponent = inComponents - 1;
          }
          if (vectorComponent + vectorSize > inComponents) {
            vectorSize = inComponents - vectorComponent;
          }
        }
        if (vectorMode === VectorMode2.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
          vectorMode = VectorMode2.COMPONENT;
        }
      }
      let inputOffset = 0;
      if (vectorComponent > 0) {
        inputOffset = vectorComponent;
      }
      switch (vectorMode) {
        case VectorMode2.COMPONENT: {
          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
          break;
        }
        case VectorMode2.RGBCOLORS: {
          break;
        }
        // MAGNITUDE is considered default
        case VectorMode2.MAGNITUDE:
        default: {
          const magValues = vtkDataArray$1.newInstance({
            numberOfComponents: 1,
            values: new Float32Array(input.getNumberOfTuples())
          });
          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
          break;
        }
      }
    };
    publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {
      const a = convtFun(alpha);
      const values = colors.getData();
      const newValues = newColors.getData();
      const size = values.length;
      const component = 0;
      const tuple = 1;
      let count = 0;
      for (let i = component; i < size; i += tuple) {
        const l = convtFun(values[i]);
        newValues[count * 4] = l;
        newValues[count * 4 + 1] = l;
        newValues[count * 4 + 2] = l;
        newValues[count * 4 + 3] = a;
        count++;
      }
    };
    publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {
      const values = colors.getData();
      const newValues = newColors.getData();
      const size = values.length;
      const component = 0;
      const tuple = 2;
      let count = 0;
      for (let i = component; i < size; i += tuple) {
        const l = convtFun(values[i]);
        newValues[count] = l;
        newValues[count + 1] = l;
        newValues[count + 2] = l;
        newValues[count + 3] = convtFun(values[i + 1]) * alpha;
        count += 4;
      }
    };
    publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {
      const a = floatColorToUChar(alpha);
      const values = colors.getData();
      const newValues = newColors.getData();
      const size = values.length;
      const component = 0;
      const tuple = 3;
      let count = 0;
      for (let i = component; i < size; i += tuple) {
        newValues[count * 4] = convtFun(values[i]);
        newValues[count * 4 + 1] = convtFun(values[i + 1]);
        newValues[count * 4 + 2] = convtFun(values[i + 2]);
        newValues[count * 4 + 3] = a;
        count++;
      }
    };
    publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {
      const values = colors.getData();
      const newValues = newColors.getData();
      const size = values.length;
      const component = 0;
      const tuple = 4;
      let count = 0;
      for (let i = component; i < size; i += tuple) {
        newValues[count * 4] = convtFun(values[i]);
        newValues[count * 4 + 1] = convtFun(values[i + 1]);
        newValues[count * 4 + 2] = convtFun(values[i + 2]);
        newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;
        count++;
      }
    };
    publicAPI.convertToRGBA = (colors, numComp, numTuples) => {
      let {
        alpha
      } = model;
      if (numComp === 4 && alpha >= 1 && colors.getDataType() === VtkDataTypes2.UNSIGNED_CHAR) {
        return colors;
      }
      const newColors = vtkDataArray$1.newInstance({
        numberOfComponents: 4,
        empty: true,
        size: 4 * numTuples,
        dataType: VtkDataTypes2.UNSIGNED_CHAR
      });
      if (numTuples <= 0) {
        return newColors;
      }
      alpha = alpha > 0 ? alpha : 0;
      alpha = alpha < 1 ? alpha : 1;
      let convtFun = intColorToUChar;
      if (colors.getDataType() === VtkDataTypes2.FLOAT || colors.getDataType() === VtkDataTypes2.DOUBLE) {
        convtFun = floatColorToUChar;
      }
      switch (numComp) {
        case 1:
          publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
          break;
        case 2:
          publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
          break;
        case 3:
          publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
          break;
        case 4:
          publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
          break;
        default:
          vtkErrorMacro13("Cannot convert colors");
          return null;
      }
      return newColors;
    };
    publicAPI.usingLogScale = () => false;
    publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;
    publicAPI.setRange = (min4, max4) => publicAPI.setMappingRange(min4, max4);
    publicAPI.getRange = () => publicAPI.getMappingRange();
    publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {
      if (!scalars) {
        return publicAPI.isOpaque();
      }
      const numberOfComponents = scalars.getNumberOfComponents();
      if (colorMode === ColorMode2.DEFAULT && scalars.getDataType() === VtkDataTypes2.UNSIGNED_CHAR || colorMode === ColorMode2.DIRECT_SCALARS) {
        if (numberOfComponents === 3 || numberOfComponents === 1) {
          return model.alpha >= 1;
        }
        const range = scalars.getRange(numberOfComponents - 1);
        return range[0] === 255;
      }
      return true;
    };
  }
  var DEFAULT_VALUES35 = {
    alpha: 1,
    vectorComponent: 0,
    vectorSize: -1,
    vectorMode: VectorMode2.COMPONENT,
    mappingRange: null,
    annotationArray: null,
    annotatedValueMap: null,
    indexedLookup: false,
    scale: Scale2.LINEAR
  };
  function extend37(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES35, initialValues);
    macro.obj(publicAPI, model);
    model.mappingRange = [0, 255];
    model.annotationArray = [];
    model.annotatedValueMap = [];
    macro.setGet(publicAPI, model, ["vectorSize", "vectorComponent", "vectorMode", "alpha", "indexedLookup"]);
    macro.setArray(publicAPI, model, ["mappingRange"], 2);
    macro.getArray(publicAPI, model, ["mappingRange"]);
    vtkScalarsToColors2(publicAPI, model);
  }
  var newInstance37 = macro.newInstance(extend37, "vtkScalarsToColors");
  var vtkScalarsToColors$1 = {
    newInstance: newInstance37,
    extend: extend37,
    ...vtkScalarsToColors
  };

  // node_modules/@kitware/vtk.js/Common/Core/LookupTable.js
  var {
    vtkErrorMacro: vtkErrorMacro14
  } = macro;
  var BELOW_RANGE_COLOR_INDEX = 0;
  var ABOVE_RANGE_COLOR_INDEX = 1;
  var NAN_COLOR_INDEX = 2;
  function vtkLookupTable(publicAPI, model) {
    model.classHierarchy.push("vtkLookupTable");
    publicAPI.isOpaque = () => {
      if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
        let opaque = true;
        if (model.nanColor[3] < 1) {
          opaque = 0;
        }
        if (model.useBelowRangeColor && model.belowRangeColor[3] < 1) {
          opaque = 0;
        }
        if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1) {
          opaque = 0;
        }
        for (let i = 3; i < model.table.length && opaque; i += 4) {
          if (model.table[i] < 255) {
            opaque = false;
          }
        }
        model.opaqueFlag = opaque;
        model.opaqueFlagBuildTime.modified();
      }
      return model.opaqueFlag;
    };
    publicAPI.usingLogScale = () => false;
    publicAPI.getNumberOfAvailableColors = () => model.table.length / 4 - 3;
    publicAPI.linearIndexLookup = (v, p) => {
      let dIndex = 0;
      const nv = Number(v);
      if (nv < p.range[0]) {
        dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
      } else if (nv > p.range[1]) {
        dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
      } else {
        dIndex = (nv + p.shift) * p.scale;
        dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
      }
      return Math.floor(dIndex);
    };
    publicAPI.linearLookup = (v, table, p) => {
      let index = 0;
      if (isNan(v)) {
        index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
      } else {
        index = publicAPI.linearIndexLookup(v, p);
      }
      const offset = 4 * index;
      return table.slice(offset, offset + 4);
    };
    publicAPI.indexedLookupFunction = (v, table, p) => {
      let index = publicAPI.getAnnotatedValueIndexInternal(v);
      if (index === -1) {
        index = model.numberOfColors + NAN_COLOR_INDEX;
      }
      const offset = 4 * index;
      return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
    };
    publicAPI.lookupShiftAndScale = (range, p) => {
      p.shift = -range[0];
      p.scale = Number.MAX_VALUE;
      if (range[1] > range[0]) {
        p.scale = (p.maxIndex + 1) / (range[1] - range[0]);
      }
    };
    publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
      let lookupFunc = publicAPI.linearLookup;
      if (model.indexedLookup) {
        lookupFunc = publicAPI.indexedLookupFunction;
      }
      const trange = publicAPI.getMappingRange();
      const p = {
        maxIndex: publicAPI.getNumberOfColors() - 1,
        range: trange,
        shift: 0,
        scale: 0
      };
      publicAPI.lookupShiftAndScale(trange, p);
      const alpha = publicAPI.getAlpha();
      const length4 = input.getNumberOfTuples();
      const inIncr = input.getNumberOfComponents();
      const outputV = output.getData();
      const inputV = input.getData();
      if (alpha >= 1) {
        if (outFormat === ScalarMappingTarget.RGBA) {
          for (let i = 0; i < length4; i++) {
            const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
            outputV[i * 4] = cptr[0];
            outputV[i * 4 + 1] = cptr[1];
            outputV[i * 4 + 2] = cptr[2];
            outputV[i * 4 + 3] = cptr[3];
          }
        }
      } else {
        if (outFormat === ScalarMappingTarget.RGBA) {
          for (let i = 0; i < length4; i++) {
            const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
            outputV[i * 4] = cptr[0];
            outputV[i * 4 + 1] = cptr[1];
            outputV[i * 4 + 2] = cptr[2];
            outputV[i * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);
          }
        }
      }
    };
    publicAPI.forceBuild = () => {
      let hinc = 0;
      let sinc = 0;
      let vinc = 0;
      let ainc = 0;
      const maxIndex = model.numberOfColors - 1;
      if (maxIndex) {
        hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
        sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
        vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
        ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
      }
      model.table.length = 4 * maxIndex + 16;
      const hsv = [];
      const rgba2 = [];
      for (let i = 0; i <= maxIndex; i++) {
        hsv[0] = model.hueRange[0] + i * hinc;
        hsv[1] = model.saturationRange[0] + i * sinc;
        hsv[2] = model.valueRange[0] + i * vinc;
        hsv2rgb(hsv, rgba2);
        rgba2[3] = model.alphaRange[0] + i * ainc;
        model.table[i * 4] = rgba2[0] * 255 + 0.5;
        model.table[i * 4 + 1] = rgba2[1] * 255 + 0.5;
        model.table[i * 4 + 2] = rgba2[2] * 255 + 0.5;
        model.table[i * 4 + 3] = rgba2[3] * 255 + 0.5;
      }
      publicAPI.buildSpecialColors();
      model.buildTime.modified();
    };
    publicAPI.setTable = (table) => {
      if (Array.isArray(table)) {
        const nbComponents = table[0].length;
        model.numberOfColors = table.length;
        const colorOffset = 4 - nbComponents;
        let offset = 0;
        for (let i = 0; i < model.numberOfColors; i++) {
          model.table[i * 4] = 255;
          model.table[i * 4 + 1] = 255;
          model.table[i * 4 + 2] = 255;
          model.table[i * 4 + 3] = 255;
        }
        for (let i = 0; i < table.length; i++) {
          const color2 = table[i];
          for (let j = 0; j < nbComponents; j++) {
            model.table[offset++] = color2[j];
          }
          offset += colorOffset;
        }
        publicAPI.buildSpecialColors();
        model.insertTime.modified();
        publicAPI.modified();
        return true;
      }
      if (table.getNumberOfComponents() !== 4) {
        vtkErrorMacro14("Expected 4 components for RGBA colors");
        return false;
      }
      if (table.getDataType() !== VtkDataTypes.UNSIGNED_CHAR) {
        vtkErrorMacro14("Expected unsigned char values for RGBA colors");
        return false;
      }
      model.numberOfColors = table.getNumberOfTuples();
      const data = table.getData();
      model.table.length = data.length;
      for (let i = 0; i < data.length; i++) {
        model.table[i] = data[i];
      }
      publicAPI.buildSpecialColors();
      model.insertTime.modified();
      publicAPI.modified();
      return true;
    };
    publicAPI.buildSpecialColors = () => {
      const {
        numberOfColors
      } = model;
      const tptr = model.table;
      let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;
      if (model.useBelowRangeColor || numberOfColors === 0) {
        tptr[base] = model.belowRangeColor[0] * 255 + 0.5;
        tptr[base + 1] = model.belowRangeColor[1] * 255 + 0.5;
        tptr[base + 2] = model.belowRangeColor[2] * 255 + 0.5;
        tptr[base + 3] = model.belowRangeColor[3] * 255 + 0.5;
      } else {
        tptr[base] = tptr[0];
        tptr[base + 1] = tptr[1];
        tptr[base + 2] = tptr[2];
        tptr[base + 3] = tptr[3];
      }
      base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
      if (model.useAboveRangeColor || numberOfColors === 0) {
        tptr[base] = model.aboveRangeColor[0] * 255 + 0.5;
        tptr[base + 1] = model.aboveRangeColor[1] * 255 + 0.5;
        tptr[base + 2] = model.aboveRangeColor[2] * 255 + 0.5;
        tptr[base + 3] = model.aboveRangeColor[3] * 255 + 0.5;
      } else {
        tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
        tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
        tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
        tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
      }
      base = (numberOfColors + NAN_COLOR_INDEX) * 4;
      tptr[base] = model.nanColor[0] * 255 + 0.5;
      tptr[base + 1] = model.nanColor[1] * 255 + 0.5;
      tptr[base + 2] = model.nanColor[2] * 255 + 0.5;
      tptr[base + 3] = model.nanColor[3] * 255 + 0.5;
    };
    publicAPI.build = () => {
      if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
        publicAPI.forceBuild();
      }
    };
    if (model.table.length > 0) {
      publicAPI.buildSpecialColors();
      model.insertTime.modified();
    }
  }
  var DEFAULT_VALUES36 = {
    numberOfColors: 256,
    // table: null,
    hueRange: [0, 0.66667],
    saturationRange: [1, 1],
    valueRange: [1, 1],
    alphaRange: [1, 1],
    nanColor: [0.5, 0, 0, 1],
    belowRangeColor: [0, 0, 0, 1],
    aboveRangeColor: [1, 1, 1, 1],
    useAboveRangeColor: false,
    useBelowRangeColor: false,
    alpha: 1
    // buildTime: null,
    // opaqueFlagBuildTime: null,
    // insertTime: null,
  };
  function extend38(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES36, initialValues);
    vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
    if (!model.table) {
      model.table = [];
    }
    model.buildTime = {};
    macro.obj(model.buildTime);
    model.opaqueFlagBuildTime = {};
    macro.obj(model.opaqueFlagBuildTime, {
      mtime: 0
    });
    model.insertTime = {};
    macro.obj(model.insertTime, {
      mtime: 0
    });
    macro.get(publicAPI, model, ["buildTime"]);
    macro.setGet(publicAPI, model, ["numberOfColors", "useAboveRangeColor", "useBelowRangeColor"]);
    macro.setArray(publicAPI, model, ["alphaRange", "hueRange", "saturationRange", "valueRange"], 2);
    macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
    macro.getArray(publicAPI, model, ["hueRange", "saturationRange", "valueRange", "alphaRange", "nanColor", "belowRangeColor", "aboveRangeColor"]);
    vtkLookupTable(publicAPI, model);
  }
  var newInstance38 = macro.newInstance(extend38, "vtkLookupTable");
  var vtkLookupTable$1 = {
    newInstance: newInstance38,
    extend: extend38
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
  var Resolve = {
    Off: 0,
    PolygonOffset: 1
  };
  var resolveCoincidentTopologyPolygonOffsetFaces = Resolve.PolygonOffset;
  var resolveCoincidentTopology = Resolve.Off;
  var RESOLVE_COINCIDENT_TOPOLOGY_MODE = ["VTK_RESOLVE_OFF", "VTK_RESOLVE_POLYGON_OFFSET"];
  function getResolveCoincidentTopologyPolygonOffsetFaces() {
    return resolveCoincidentTopologyPolygonOffsetFaces;
  }
  function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
    const changed = resolveCoincidentTopologyPolygonOffsetFaces === value;
    resolveCoincidentTopologyPolygonOffsetFaces = value;
    return changed;
  }
  function getResolveCoincidentTopology() {
    return resolveCoincidentTopology;
  }
  function setResolveCoincidentTopology() {
    let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    const changed = resolveCoincidentTopology === mode;
    resolveCoincidentTopology = mode;
    return changed;
  }
  function setResolveCoincidentTopologyToDefault() {
    return setResolveCoincidentTopology(Resolve.Off);
  }
  function setResolveCoincidentTopologyToOff() {
    return setResolveCoincidentTopology(Resolve.Off);
  }
  function setResolveCoincidentTopologyToPolygonOffset() {
    return setResolveCoincidentTopology(Resolve.PolygonOffset);
  }
  function getResolveCoincidentTopologyAsString() {
    return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
  }
  var otherStaticMethods = {
    Resolve,
    getResolveCoincidentTopologyAsString,
    getResolveCoincidentTopologyPolygonOffsetFaces,
    getResolveCoincidentTopology,
    setResolveCoincidentTopology,
    setResolveCoincidentTopologyPolygonOffsetFaces,
    setResolveCoincidentTopologyToDefault,
    setResolveCoincidentTopologyToOff,
    setResolveCoincidentTopologyToPolygonOffset
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
  function addCoincidentTopologyMethods(publicAPI, model, nameList) {
    nameList.forEach((item) => {
      publicAPI[`get${item.method}`] = () => model[item.key];
      publicAPI[`set${item.method}`] = macro.objectSetterMap.object(publicAPI, model, {
        name: item.key,
        params: ["factor", "offset"]
      });
    });
  }
  var CATEGORIES = ["Polygon", "Line", "Point"];
  var staticOffsetModel = {
    Polygon: {
      factor: 2,
      offset: 0
    },
    Line: {
      factor: 1,
      offset: -1
    },
    Point: {
      factor: 0,
      offset: -2
    }
  };
  var noOp2 = () => void 0;
  var staticOffsetAPI = {
    modified: noOp2
  };
  addCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map((key) => ({
    key,
    method: `ResolveCoincidentTopology${key}OffsetParameters`
  })));
  function implementCoincidentTopologyMethods(publicAPI, model) {
    if (model.resolveCoincidentTopology === void 0) {
      model.resolveCoincidentTopology = false;
    }
    macro.setGet(publicAPI, model, ["resolveCoincidentTopology"]);
    model.topologyOffset = {
      Polygon: {
        factor: 0,
        offset: 0
      },
      Line: {
        factor: 0,
        offset: 0
      },
      Point: {
        factor: 0,
        offset: 0
      }
    };
    Object.keys(otherStaticMethods).forEach((methodName) => {
      publicAPI[methodName] = otherStaticMethods[methodName];
    });
    Object.keys(staticOffsetAPI).filter((methodName) => methodName !== "modified").forEach((methodName) => {
      publicAPI[methodName] = staticOffsetAPI[methodName];
    });
    addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map((key) => ({
      key,
      method: `RelativeCoincidentTopology${key}OffsetParameters`
    })));
    publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {
      const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
      const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
      return {
        factor: globalValue.factor + localValue.factor,
        offset: globalValue.offset + localValue.offset
      };
    };
    publicAPI.getCoincidentTopologyLineOffsetParameters = () => {
      const globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
      const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
      return {
        factor: globalValue.factor + localValue.factor,
        offset: globalValue.offset + localValue.offset
      };
    };
    publicAPI.getCoincidentTopologyPointOffsetParameter = () => {
      const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
      const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
      return {
        factor: globalValue.factor + localValue.factor,
        offset: globalValue.offset + localValue.offset
      };
    };
  }
  var CoincidentTopologyHelper = {
    implementCoincidentTopologyMethods,
    staticOffsetAPI,
    otherStaticMethods,
    CATEGORIES,
    Resolve
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js
  var PassTypes = {
    MIN_KNOWN_PASS: 0,
    ACTOR_PASS: 0,
    COMPOSITE_INDEX_PASS: 1,
    ID_LOW24: 2,
    ID_HIGH24: 3,
    MAX_KNOWN_PASS: 3
  };
  var Constants9 = {
    PassTypes
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
  var {
    FieldAssociations: FieldAssociations2
  } = vtkDataSet$1;
  var {
    staticOffsetAPI: staticOffsetAPI2,
    otherStaticMethods: otherStaticMethods2
  } = CoincidentTopologyHelper;
  var {
    ColorMode: ColorMode3,
    ScalarMode: ScalarMode2,
    GetArray: GetArray2
  } = Constants8;
  var {
    VectorMode: VectorMode3
  } = vtkScalarsToColors;
  var {
    VtkDataTypes: VtkDataTypes3
  } = vtkDataArray$1;
  function notImplemented7(method) {
    return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);
  }
  function updateZigzaggingCoordinates(coordinates, dimensions) {
    const directionX = coordinates[1] % 2 === 0 ? 1 : -1;
    coordinates[0] += directionX;
    if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {
      const directionY = coordinates[2] % 2 === 0 ? 1 : -1;
      coordinates[0] -= directionX;
      coordinates[1] += directionY;
      if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {
        coordinates[1] -= directionY;
        coordinates[2]++;
      }
    }
  }
  function getIndexFromCoordinates(coordinates, dimensions) {
    return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);
  }
  function getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {
    const intTexelIndex = Math.floor(texelIndexPosition);
    const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);
    let xDirection;
    let xEndFlag;
    if (xCoordBeforeWrap < dimensions[0]) {
      textureCoordinate[0] = xCoordBeforeWrap;
      xDirection = 1;
      xEndFlag = textureCoordinate[0] === dimensions[0] - 1;
    } else {
      textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;
      xDirection = -1;
      xEndFlag = textureCoordinate[0] === 0;
    }
    const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);
    const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);
    let yDirection;
    let yEndFlag;
    if (yCoordBeforeWrap < dimensions[1]) {
      textureCoordinate[1] = yCoordBeforeWrap;
      yDirection = 1;
      yEndFlag = textureCoordinate[1] === dimensions[1] - 1;
    } else {
      textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;
      yDirection = -1;
      yEndFlag = textureCoordinate[1] === 0;
    }
    textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);
    const remainder = texelIndexPosition - intTexelIndex;
    if (xEndFlag) {
      if (yEndFlag) {
        textureCoordinate[2] += remainder;
      } else {
        textureCoordinate[1] += yDirection * remainder;
      }
    } else {
      textureCoordinate[0] += xDirection * remainder;
    }
    textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];
    textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];
    textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];
  }
  var colorTextureCoordinatesCache = /* @__PURE__ */ new WeakMap();
  function getOrCreateColorTextureCoordinates(input, component, range, useLogScale, numberOfColorsInRange, dimensions, useZigzagPattern) {
    const argStrings = new Array(arguments.length);
    for (let argIndex = 0; argIndex < arguments.length; ++argIndex) {
      const arg = arguments[argIndex];
      argStrings[argIndex] = arg.getMTime?.() ?? arg;
    }
    const stringHash = argStrings.join("/");
    const cachedResult = colorTextureCoordinatesCache.get(input);
    if (cachedResult && cachedResult.stringHash === stringHash) {
      return cachedResult.textureCoordinates;
    }
    const scalarTexelWidth = (range[1] - range[0]) / (numberOfColorsInRange - 1);
    const [paddedRangeMin, paddedRangeMax] = [range[0] - scalarTexelWidth, range[1] + scalarTexelWidth];
    const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;
    const textureSCoeff = 1 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);
    const texelIndexOrigin = paddedRangeMin;
    const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);
    const inputV = input.getData();
    const numScalars = input.getNumberOfTuples();
    const numComps = input.getNumberOfComponents();
    const useMagnitude = component < 0 || component >= numComps;
    const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;
    const output = vtkDataArray$1.newInstance({
      numberOfComponents: numberOfOutputComponents,
      values: new Float32Array(numScalars * numberOfOutputComponents)
    });
    const outputV = output.getData();
    const nanTextureCoordinate = [0, 0, 0];
    getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);
    let inputIdx = 0;
    let outputIdx = 0;
    const textureCoordinate = [0.5, 0.5, 0.5];
    for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
      let scalarValue;
      if (useMagnitude) {
        let sum = 0;
        for (let compIdx = 0; compIdx < numComps; ++compIdx) {
          const compValue = Number(inputV[inputIdx + compIdx]);
          sum += compValue * compValue;
        }
        scalarValue = Math.sqrt(sum);
      } else {
        scalarValue = Number(inputV[inputIdx + component]);
      }
      if (useLogScale) {
        scalarValue = Math.log10(scalarValue);
      }
      inputIdx += numComps;
      if (isNan(scalarValue)) {
        textureCoordinate[0] = nanTextureCoordinate[0];
        textureCoordinate[1] = nanTextureCoordinate[1];
        textureCoordinate[2] = nanTextureCoordinate[2];
      } else if (useZigzagPattern) {
        let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;
        if (texelIndexPosition < 1) {
          texelIndexPosition = 0;
        } else if (texelIndexPosition > numberOfColorsInRange) {
          texelIndexPosition = numberOfColorsInRange + 1;
        }
        getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);
      } else {
        textureCoordinate[1] = 0.49;
        const textureS = (scalarValue - textureSOrigin) * textureSCoeff;
        if (textureS > 1e3) {
          textureCoordinate[0] = 1e3;
        } else if (textureS < -1e3) {
          textureCoordinate[0] = -1e3;
        } else {
          textureCoordinate[0] = textureS;
        }
      }
      for (let i = 0; i < numberOfOutputComponents; ++i) {
        outputV[outputIdx++] = textureCoordinate[i];
      }
    }
    colorTextureCoordinatesCache.set(input, {
      stringHash,
      textureCoordinates: output
    });
    return output;
  }
  function vtkMapper(publicAPI, model) {
    model.classHierarchy.push("vtkMapper");
    publicAPI.getBounds = () => {
      const input = publicAPI.getInputData();
      if (!input) {
        model.bounds = createUninitializedBounds();
      } else {
        if (!model.static) {
          publicAPI.update();
        }
        model.bounds = input.getBounds();
      }
      return model.bounds;
    };
    publicAPI.setForceCompileOnly = (v) => {
      model.forceCompileOnly = v;
    };
    publicAPI.setSelectionWebGLIdsToVTKIds = (selectionWebGLIdsToVTKIds) => {
      model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;
    };
    publicAPI.createDefaultLookupTable = () => {
      model.lookupTable = vtkLookupTable$1.newInstance();
    };
    publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode3, model.colorMode);
    publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
    publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
    publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
    publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode2, model.scalarMode);
    publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
    publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
    publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
    publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
    publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
    publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
    publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
      if (!input || !model.scalarVisibility) {
        return {
          scalars: null,
          cellFlag: false
        };
      }
      let scalars = null;
      let cellFlag = false;
      if (scalarMode === ScalarMode2.DEFAULT) {
        scalars = input.getPointData().getScalars();
        if (!scalars) {
          scalars = input.getCellData().getScalars();
          cellFlag = true;
        }
      } else if (scalarMode === ScalarMode2.USE_POINT_DATA) {
        scalars = input.getPointData().getScalars();
      } else if (scalarMode === ScalarMode2.USE_CELL_DATA) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      } else if (scalarMode === ScalarMode2.USE_POINT_FIELD_DATA) {
        const pd = input.getPointData();
        if (arrayAccessMode === GetArray2.BY_ID) {
          scalars = pd.getArrayByIndex(arrayId);
        } else {
          scalars = pd.getArrayByName(arrayName);
        }
      } else if (scalarMode === ScalarMode2.USE_CELL_FIELD_DATA) {
        const cd = input.getCellData();
        cellFlag = true;
        if (arrayAccessMode === GetArray2.BY_ID) {
          scalars = cd.getArrayByIndex(arrayId);
        } else {
          scalars = cd.getArrayByName(arrayName);
        }
      } else if (scalarMode === ScalarMode2.USE_FIELD_DATA) {
        const fd = input.getFieldData();
        if (arrayAccessMode === GetArray2.BY_ID) {
          scalars = fd.getArrayByIndex(arrayId);
        } else {
          scalars = fd.getArrayByName(arrayName);
        }
      }
      return {
        scalars,
        cellFlag
      };
    };
    publicAPI.mapScalars = (input, alpha) => {
      const {
        scalars,
        cellFlag
      } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
      model.areScalarsMappedFromCells = cellFlag;
      if (!scalars) {
        model.colorCoordinates = null;
        model.colorTextureMap = null;
        model.colorMapColors = null;
        return;
      }
      const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
      if (model.colorBuildString === toString) return;
      if (!model.useLookupTableScalarRange) {
        publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
      }
      if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {
        model.mapScalarsToTexture(scalars, cellFlag, alpha);
      } else {
        model.colorCoordinates = null;
        model.colorTextureMap = null;
        const lut = publicAPI.getLookupTable();
        if (lut) {
          lut.build();
          model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
        }
      }
      model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    };
    model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {
      const range = model.lookupTable.getRange();
      const useLogScale = model.lookupTable.usingLogScale();
      const origAlpha = model.lookupTable.getAlpha();
      const scaledRange = useLogScale ? [Math.log10(range[0]), Math.log10(range[1])] : range;
      model.colorMapColors = null;
      if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
        model.lookupTable.setAlpha(alpha);
        model.colorTextureMap = null;
        model.lookupTable.build();
        const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();
        const maxTextureWidthForCells = 2048;
        const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3;
        const maxTextureWidthForPoints = 4096;
        const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2;
        const minColorsInRange = 2;
        const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;
        model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);
        const numberOfColorsForCells = model.numberOfColorsInRange + 3;
        const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2;
        const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];
        const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];
        const scalarsArray = new Float64Array(textureSize);
        scalarsArray.fill(NaN);
        const numberOfNonSpecialColors = model.numberOfColorsInRange;
        const numberOfNonNaNColors = numberOfNonSpecialColors + 2;
        const textureCoordinates = [0, 0, 0];
        const rangeMin = scaledRange[0];
        const rangeDifference = scaledRange[1] - scaledRange[0];
        for (let i = 0; i < numberOfNonNaNColors; ++i) {
          const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);
          const intermediateValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);
          const scalarValue = useLogScale ? 10 ** intermediateValue : intermediateValue;
          scalarsArray[scalarsArrayIndex] = scalarValue;
          updateZigzaggingCoordinates(textureCoordinates, textureDimensions);
        }
        const scalarsDataArray = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: scalarsArray
        });
        const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);
        model.colorTextureMap = vtkImageData$1.newInstance();
        model.colorTextureMap.setDimensions(textureDimensions);
        model.colorTextureMap.getPointData().setScalars(colorsDataArray);
        model.lookupTable.setAlpha(origAlpha);
      }
      const scalarComponent = model.lookupTable.getVectorMode() === VectorMode3.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();
      model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, scaledRange, useLogScale, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), cellFlag);
    };
    publicAPI.getIsOpaque = () => {
      const input = publicAPI.getInputData();
      const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
      const scalars = gasResult.scalars;
      if (!model.scalarVisibility || scalars == null) {
        return true;
      }
      const lut = publicAPI.getLookupTable();
      if (lut) {
        lut.build();
        return lut.areScalarsOpaque(scalars, model.colorMode, -1);
      }
      return true;
    };
    publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {
      if (cellFlag && !(model.colorMode === ColorMode3.DIRECT_SCALARS)) {
        return true;
      }
      if (!model.interpolateScalarsBeforeMapping) {
        return false;
      }
      if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
        return false;
      }
      if (!scalars) {
        return false;
      }
      if (model.colorMode === ColorMode3.DEFAULT && scalars.getDataType() === VtkDataTypes3.UNSIGNED_CHAR || model.colorMode === ColorMode3.DIRECT_SCALARS) {
        return false;
      }
      return true;
    };
    publicAPI.clearColorArrays = () => {
      model.colorMapColors = null;
      model.colorCoordinates = null;
      model.colorTextureMap = null;
    };
    publicAPI.getLookupTable = () => {
      if (!model.lookupTable) {
        publicAPI.createDefaultLookupTable();
      }
      return model.lookupTable;
    };
    publicAPI.getMTime = () => {
      let mt = model.mtime;
      if (model.lookupTable !== null) {
        const time = model.lookupTable.getMTime();
        mt = time > mt ? time : mt;
      }
      return mt;
    };
    publicAPI.getPrimitiveCount = () => {
      const input = publicAPI.getInputData();
      const pcount = {
        points: input.getPoints().getNumberOfValues() / 3,
        verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
        lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
        triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
      };
      return pcount;
    };
    publicAPI.acquireInvertibleLookupTable = notImplemented7("AcquireInvertibleLookupTable");
    publicAPI.valueToColor = notImplemented7("ValueToColor");
    publicAPI.colorToValue = notImplemented7("ColorToValue");
    publicAPI.useInvertibleColorFor = notImplemented7("UseInvertibleColorFor");
    publicAPI.clearInvertibleColor = notImplemented7("ClearInvertibleColor");
    publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
      if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {
        return;
      }
      const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);
      const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);
      const currentPass = selector.getCurrentPass();
      const fieldAssociation = selector.getFieldAssociation();
      let idMap = null;
      if (fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_POINTS) {
        idMap = model.selectionWebGLIdsToVTKIds.points;
      } else if (fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_CELLS) {
        idMap = model.selectionWebGLIdsToVTKIds.cells;
      }
      if (!idMap) {
        return;
      }
      pixelOffsets.forEach((pos) => {
        if (currentPass === PassTypes.ID_LOW24) {
          let inValue = 0;
          if (rawHighData) {
            inValue += rawHighData[pos];
            inValue *= 256;
          }
          inValue += rawLowData[pos + 2];
          inValue *= 256;
          inValue += rawLowData[pos + 1];
          inValue *= 256;
          inValue += rawLowData[pos];
          const outValue = idMap[inValue];
          const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);
          lowData[pos] = outValue & 255;
          lowData[pos + 1] = (outValue & 65280) >> 8;
          lowData[pos + 2] = (outValue & 16711680) >> 16;
        } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {
          let inValue = 0;
          inValue += rawHighData[pos];
          inValue *= 256;
          inValue += rawLowData[pos + 2];
          inValue *= 256;
          inValue += rawLowData[pos + 1];
          inValue *= 256;
          inValue += rawLowData[pos];
          const outValue = idMap[inValue];
          const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);
          highData[pos] = (outValue & 4278190080) >> 24;
        }
      });
    };
  }
  var DEFAULT_VALUES37 = {
    colorMapColors: null,
    // Same as this->Colors
    areScalarsMappedFromCells: false,
    static: false,
    lookupTable: null,
    scalarVisibility: true,
    scalarRange: [0, 1],
    useLookupTableScalarRange: false,
    colorMode: 0,
    scalarMode: 0,
    arrayAccessMode: 1,
    // By_NAME
    renderTime: 0,
    colorByArrayName: null,
    fieldDataTupleId: -1,
    populateSelectionSettings: true,
    selectionWebGLIdsToVTKIds: null,
    interpolateScalarsBeforeMapping: false,
    colorCoordinates: null,
    colorTextureMap: null,
    numberOfColorsInRange: 0,
    forceCompileOnly: 0,
    useInvertibleColors: false,
    invertibleScalars: null,
    customShaderAttributes: []
  };
  function extend39(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES37, initialValues);
    vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ["areScalarsMappedFromCells", "colorCoordinates", "colorMapColors", "colorTextureMap", "numberOfColorsInRange", "selectionWebGLIdsToVTKIds"]);
    macro.setGet(publicAPI, model, [
      "colorByArrayName",
      "arrayAccessMode",
      "colorMode",
      "fieldDataTupleId",
      "interpolateScalarsBeforeMapping",
      "lookupTable",
      "populateSelectionSettings",
      "renderTime",
      "scalarMode",
      "scalarVisibility",
      "static",
      "useLookupTableScalarRange",
      "customShaderAttributes"
      // point data array names that will be transferred to the VBO
    ]);
    macro.setGetArray(publicAPI, model, ["scalarRange"], 2);
    CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
    vtkMapper(publicAPI, model);
  }
  var newInstance39 = macro.newInstance(extend39, "vtkMapper");
  var vtkMapper$1 = {
    newInstance: newInstance39,
    extend: extend39,
    ...staticOffsetAPI2,
    ...otherStaticMethods2,
    ...Constants8
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
  var import_fast_deep_equal2 = __toESM(require_fast_deep_equal(), 1);

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
  var Wrap = {
    CLAMP_TO_EDGE: 0,
    REPEAT: 1,
    MIRRORED_REPEAT: 2
  };
  var Filter = {
    NEAREST: 0,
    LINEAR: 1,
    NEAREST_MIPMAP_NEAREST: 2,
    NEAREST_MIPMAP_LINEAR: 3,
    LINEAR_MIPMAP_NEAREST: 4,
    LINEAR_MIPMAP_LINEAR: 5
  };
  var Constants10 = {
    Wrap,
    Filter
  };

  // node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js
  var floatView = new Float32Array(1);
  var int32View = new Int32Array(floatView.buffer);
  function toHalf(val) {
    floatView[0] = val;
    const x = int32View[0];
    let bits = x >> 16 & 32768;
    let m = x >> 12 & 2047;
    const e = x >> 23 & 255;
    if (e < 103) {
      return bits;
    }
    if (e > 142) {
      bits |= 31744;
      bits |= (e === 255 ? 0 : 1) && x & 8388607;
      return bits;
    }
    if (e < 113) {
      m |= 2048;
      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }
    bits |= e - 112 << 10 | m >> 1;
    bits += m & 1;
    return bits;
  }
  function fromHalf(h) {
    const s = (h & 32768) >> 15;
    const e = (h & 31744) >> 10;
    const f = h & 1023;
    if (e === 0) {
      return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);
    }
    if (e === 31) {
      return f ? NaN : (s ? -1 : 1) * Infinity;
    }
    return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);
  }
  var HalfFloat = {
    fromHalf,
    toHalf
  };

  // node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
  var {
    vtkErrorMacro: vtkErrorMacro15
  } = macro;
  var PASS_TYPES = ["Build", "Render"];
  function vtkViewNode(publicAPI, model) {
    model.classHierarchy.push("vtkViewNode");
    publicAPI.build = (prepass) => {
    };
    publicAPI.render = (prepass) => {
    };
    publicAPI.traverse = (renderPass) => {
      const passTraversal = renderPass.getTraverseOperation();
      const fn = publicAPI[passTraversal];
      if (fn) {
        fn(renderPass);
        return;
      }
      publicAPI.apply(renderPass, true);
      for (let index = 0; index < model.children.length; index++) {
        model.children[index].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };
    publicAPI.apply = (renderPass, prepass) => {
      const customRenderPass = publicAPI[renderPass.getOperation()];
      if (customRenderPass) {
        customRenderPass(prepass, renderPass);
      }
    };
    publicAPI.getViewNodeFor = (dataObject) => {
      if (model.renderable === dataObject) {
        return publicAPI;
      }
      for (let index = 0; index < model.children.length; ++index) {
        const child = model.children[index];
        const vn = child.getViewNodeFor(dataObject);
        if (vn) {
          return vn;
        }
      }
      return void 0;
    };
    publicAPI.getFirstAncestorOfType = (type) => {
      if (!model._parent) {
        return null;
      }
      if (model._parent.isA(type)) {
        return model._parent;
      }
      return model._parent.getFirstAncestorOfType(type);
    };
    publicAPI.getLastAncestorOfType = (type) => {
      if (!model._parent) {
        return null;
      }
      const lastAncestor = model._parent.getLastAncestorOfType(type);
      if (lastAncestor) {
        return lastAncestor;
      }
      if (model._parent.isA(type)) {
        return model._parent;
      }
      return null;
    };
    publicAPI.addMissingNode = (dobj) => {
      if (!dobj) {
        return void 0;
      }
      const result = model._renderableChildMap.get(dobj);
      if (result !== void 0) {
        result.setVisited(true);
        return result;
      }
      const newNode = publicAPI.createViewNode(dobj);
      if (newNode) {
        newNode.setParent(publicAPI);
        newNode.setVisited(true);
        model._renderableChildMap.set(dobj, newNode);
        model.children.push(newNode);
        return newNode;
      }
      return void 0;
    };
    publicAPI.addMissingNodes = function(dataObjs) {
      let enforceOrder = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!dataObjs || !dataObjs.length) {
        return;
      }
      for (let index = 0; index < dataObjs.length; ++index) {
        const dobj = dataObjs[index];
        const node = publicAPI.addMissingNode(dobj);
        if (enforceOrder && node !== void 0 && model.children[index] !== node) {
          for (let i = index + 1; i < model.children.length; ++i) {
            if (model.children[i] === node) {
              model.children.splice(i, 1);
              model.children.splice(index, 0, node);
              break;
            }
          }
        }
      }
    };
    publicAPI.addMissingChildren = (children) => {
      if (!children || !children.length) {
        return;
      }
      for (let index = 0; index < children.length; ++index) {
        const child = children[index];
        const cindex = model.children.indexOf(child);
        if (cindex === -1) {
          child.setParent(publicAPI);
          model.children.push(child);
          const childRenderable = child.getRenderable();
          if (childRenderable) {
            model._renderableChildMap.set(childRenderable, child);
          }
        }
        child.setVisited(true);
      }
    };
    publicAPI.removeNode = (child) => {
      const childIdx = model.children.findIndex((x) => x === child);
      if (childIdx < 0) {
        return false;
      }
      const renderable = child.getRenderable();
      if (renderable) {
        model._renderableChildMap.delete(renderable);
      }
      child.delete();
      model.children.splice(childIdx, 1);
      return true;
    };
    publicAPI.prepareNodes = () => {
      for (let index = 0; index < model.children.length; ++index) {
        model.children[index].setVisited(false);
      }
    };
    publicAPI.setVisited = (val) => {
      model.visited = val;
    };
    publicAPI.removeUnusedNodes = () => {
      let visitedCount = 0;
      for (let index = 0; index < model.children.length; ++index) {
        const child = model.children[index];
        const visited = child.getVisited();
        if (visited) {
          model.children[visitedCount++] = child;
          child.setVisited(false);
        } else {
          const renderable = child.getRenderable();
          if (renderable) {
            model._renderableChildMap.delete(renderable);
          }
          child.delete();
        }
      }
      model.children.length = visitedCount;
    };
    publicAPI.createViewNode = (dataObj) => {
      if (!model.myFactory) {
        vtkErrorMacro15("Cannot create view nodes without my own factory");
        return null;
      }
      const ret = model.myFactory.createNode(dataObj);
      if (ret) {
        ret.setRenderable(dataObj);
      }
      return ret;
    };
    const parentDelete = publicAPI.delete;
    publicAPI.delete = () => {
      for (let i = 0; i < model.children.length; i++) {
        model.children[i].delete();
      }
      parentDelete();
    };
  }
  var DEFAULT_VALUES38 = {
    // _parent: null,
    renderable: null,
    myFactory: null,
    children: [],
    visited: false
  };
  function extend40(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES38, initialValues);
    macro.obj(publicAPI, model);
    macro.event(publicAPI, model, "event");
    model._renderableChildMap = /* @__PURE__ */ new Map();
    macro.get(publicAPI, model, ["visited"]);
    macro.setGet(publicAPI, model, ["_parent", "renderable", "myFactory"]);
    macro.getArray(publicAPI, model, ["children"]);
    macro.moveToProtected(publicAPI, model, ["parent"]);
    vtkViewNode(publicAPI, model);
  }
  var newInstance40 = macro.newInstance(extend40, "vtkViewNode");
  var vtkViewNode$1 = {
    newInstance: newInstance40,
    extend: extend40,
    PASS_TYPES
  };

  // node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js
  function vtkViewNodeFactory(publicAPI, model) {
    if (!model.overrides) {
      model.overrides = {};
    }
    model.classHierarchy.push("vtkViewNodeFactory");
    publicAPI.createNode = (dataObject) => {
      if (dataObject.isDeleted()) {
        return null;
      }
      let cpt = 0;
      let className = dataObject.getClassName(cpt++);
      let isObject = false;
      const keys = Object.keys(model.overrides);
      while (className && !isObject) {
        if (keys.indexOf(className) !== -1) {
          isObject = true;
        } else {
          className = dataObject.getClassName(cpt++);
        }
      }
      if (!isObject) {
        return null;
      }
      const vn = model.overrides[className]();
      vn.setMyFactory(publicAPI);
      return vn;
    };
  }
  var DEFAULT_VALUES39 = {
    // overrides: {},
  };
  function extend41(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES39, initialValues);
    macro.obj(publicAPI, model);
    vtkViewNodeFactory(publicAPI, model);
  }
  var newInstance41 = macro.newInstance(extend41, "vtkViewNodeFactory");
  var vtkViewNodeFactory$1 = {
    newInstance: newInstance41,
    extend: extend41
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
  var CLASS_MAPPING = /* @__PURE__ */ Object.create(null);
  function registerOverride(className, fn) {
    CLASS_MAPPING[className] = fn;
  }
  function vtkOpenGLViewNodeFactory(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLViewNodeFactory");
  }
  var DEFAULT_VALUES40 = {};
  function extend42(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES40, initialValues);
    model.overrides = CLASS_MAPPING;
    vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
    vtkOpenGLViewNodeFactory(publicAPI, model);
  }
  var newInstance42 = macro.newInstance(extend42, "vtkOpenGLViewNodeFactory");
  var vtkViewNodeFactory2 = {
    newInstance: newInstance42,
    extend: extend42
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/supportsNorm16Linear.js
  function supportsNorm16Linear() {
    try {
      const canvasSize = 4;
      const texWidth = 2;
      const texHeight = 1;
      const texData = new Int16Array([0, 2 ** 15 - 1]);
      const pixelToCheck = [1, 1];
      const canvas = document.createElement("canvas");
      canvas.width = canvasSize;
      canvas.height = canvasSize;
      const gl = canvas.getContext("webgl2");
      if (!gl) {
        return false;
      }
      const ext = gl.getExtension("EXT_texture_norm16");
      if (!ext) {
        return false;
      }
      const vs = `#version 300 es
    void main() {
      gl_PointSize = ${canvasSize.toFixed(1)};
      gl_Position = vec4(0, 0, 0, 1);
    }
  `;
      const fs = `#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    uniform sampler2D u_image;

    out vec4 color;

    void main() {
        vec4 intColor = texture(u_image, gl_PointCoord.xy);
        color = vec4(vec3(intColor.rrr), 1);
    }
    `;
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vs);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        return false;
      }
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fs);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        return false;
      }
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        return false;
      }
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, ext.R16_SNORM_EXT, texWidth, texHeight, 0, gl.RED, gl.SHORT, texData);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.useProgram(program);
      gl.drawArrays(gl.POINTS, 0, 1);
      const pixel = new Uint8Array(4);
      gl.readPixels(pixelToCheck[0], pixelToCheck[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
      const [r, g, b] = pixel;
      const webglLoseContext = gl.getExtension("WEBGL_lose_context");
      if (webglLoseContext) {
        webglLoseContext.loseContext();
      }
      return r === g && g === b && r !== 0;
    } catch (e) {
      return false;
    }
  }
  var supportsNorm16LinearCache;
  function supportsNorm16LinearCached() {
    if (supportsNorm16LinearCache === void 0) {
      supportsNorm16LinearCache = supportsNorm16Linear();
    }
    return supportsNorm16LinearCache;
  }

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
  var {
    Wrap: Wrap2,
    Filter: Filter2
  } = Constants10;
  var {
    VtkDataTypes: VtkDataTypes4
  } = vtkDataArray$1;
  var {
    vtkDebugMacro: vtkDebugMacro4,
    vtkErrorMacro: vtkErrorMacro16,
    vtkWarningMacro: vtkWarningMacro8,
    requiredParam: requiredParam2
  } = macro$1;
  var {
    toHalf: toHalf2
  } = HalfFloat;
  function vtkOpenGLTexture(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLTexture");
    function getTexParams() {
      return {
        internalFormat: model.internalFormat,
        format: model.format,
        openGLDataType: model.openGLDataType,
        width: model.width,
        height: model.height
      };
    }
    publicAPI.render = function() {
      let renWin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (renWin) {
        model._openGLRenderWindow = renWin;
      } else {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
        model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      }
      model.context = model._openGLRenderWindow.getContext();
      if (model.renderable.getInterpolate()) {
        if (model.generateMipmap) {
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        } else {
          publicAPI.setMinificationFilter(Filter2.LINEAR);
        }
        publicAPI.setMagnificationFilter(Filter2.LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter2.NEAREST);
        publicAPI.setMagnificationFilter(Filter2.NEAREST);
      }
      if (model.renderable.getRepeat()) {
        publicAPI.setWrapR(Wrap2.REPEAT);
        publicAPI.setWrapS(Wrap2.REPEAT);
        publicAPI.setWrapT(Wrap2.REPEAT);
      }
      if (model.renderable.getInputData()) {
        model.renderable.setImage(null);
      }
      if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
        if (model.renderable.getImageBitmap() !== null) {
          if (model.renderable.getInterpolate()) {
            model.generateMipmap = true;
            publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
          }
          if (model.renderable.getImageBitmap() && model.renderable.getImageLoaded()) {
            publicAPI.create2DFromImageBitmap(model.renderable.getImageBitmap());
            publicAPI.activate();
            publicAPI.sendParameters();
            model.textureBuildTime.modified();
          }
        }
        if (model.renderable.getImage() !== null) {
          if (model.renderable.getInterpolate()) {
            model.generateMipmap = true;
            publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
          }
          if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
            publicAPI.create2DFromImage(model.renderable.getImage());
            publicAPI.activate();
            publicAPI.sendParameters();
            model.textureBuildTime.modified();
          }
        }
        if (model.renderable.getCanvas() !== null) {
          if (model.renderable.getInterpolate()) {
            model.generateMipmap = true;
            publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
          }
          const canvas = model.renderable.getCanvas();
          publicAPI.create2DFromRaw({
            width: canvas.width,
            height: canvas.height,
            numComps: 4,
            dataType: VtkDataTypes4.UNSIGNED_CHAR,
            data: canvas,
            flip: true
          });
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
        if (model.renderable.getJsImageData() !== null) {
          const jsid = model.renderable.getJsImageData();
          if (model.renderable.getInterpolate()) {
            model.generateMipmap = true;
            publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
          }
          publicAPI.create2DFromRaw({
            width: jsid.width,
            height: jsid.height,
            numComps: 4,
            dataType: VtkDataTypes4.UNSIGNED_CHAR,
            data: jsid.data,
            flip: true
          });
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
        const input = model.renderable.getInputData(0);
        if (input && input.getPointData().getScalars()) {
          const ext = input.getExtent();
          const inScalars = input.getPointData().getScalars();
          const data = [];
          for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {
            const indata = model.renderable.getInputData(i);
            const scalars = indata ? indata.getPointData().getScalars().getData() : null;
            if (scalars) {
              data.push(scalars);
            }
          }
          if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
            model.generateMipmap = true;
            publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
          }
          if (data.length % 6 === 0) {
            publicAPI.createCubeFromRaw({
              width: ext[1] - ext[0] + 1,
              height: ext[3] - ext[2] + 1,
              numComps: inScalars.getNumberOfComponents(),
              dataType: inScalars.getDataType(),
              data
            });
          } else {
            publicAPI.create2DFromRaw({
              width: ext[1] - ext[0] + 1,
              height: ext[3] - ext[2] + 1,
              numComps: inScalars.getNumberOfComponents(),
              dataType: inScalars.getDataType(),
              data: inScalars.getData()
            });
          }
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      if (model.handle) {
        publicAPI.activate();
      }
    };
    const getNorm16Ext = () => {
      if ((model.minificationFilter === Filter2.LINEAR || model.magnificationFilter === Filter2.LINEAR) && !supportsNorm16LinearCached()) {
        return void 0;
      }
      return model.oglNorm16Ext;
    };
    publicAPI.destroyTexture = () => {
      publicAPI.deactivate();
      if (model.context && model.handle) {
        model.context.deleteTexture(model.handle);
      }
      model._prevTexParams = null;
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
      publicAPI.resetFormatAndType();
    };
    publicAPI.createTexture = () => {
      if (!model.handle) {
        model.handle = model.context.createTexture();
        if (model.target) {
          model.context.bindTexture(model.target, model.handle);
          model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
          model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
          if (model._openGLRenderWindow.getWebgl2()) {
            model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
          }
          model.context.bindTexture(model.target, null);
        }
      }
    };
    publicAPI.getTextureUnit = () => {
      if (model._openGLRenderWindow) {
        return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
      }
      return -1;
    };
    publicAPI.activate = () => {
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.bind();
    };
    publicAPI.deactivate = () => {
      if (model._openGLRenderWindow) {
        model._openGLRenderWindow.deactivateTexture(publicAPI);
      }
    };
    publicAPI.releaseGraphicsResources = (rwin) => {
      if (rwin && model.handle) {
        rwin.activateTexture(publicAPI);
        rwin.deactivateTexture(publicAPI);
        model.context.deleteTexture(model.handle);
        model._prevTexParams = null;
        model.handle = 0;
        model.numberOfDimensions = 0;
        model.target = 0;
        model.internalFormat = 0;
        model.format = 0;
        model.openGLDataType = 0;
        model.components = 0;
        model.width = 0;
        model.height = 0;
        model.depth = 0;
        model.allocatedGPUMemoryInBytes = 0;
      }
      if (model.shaderProgram) {
        model.shaderProgram.releaseGraphicsResources(rwin);
        model.shaderProgram = null;
      }
    };
    publicAPI.bind = () => {
      model.context.bindTexture(model.target, model.handle);
      if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
        publicAPI.sendParameters();
      }
    };
    publicAPI.isBound = () => {
      let result = false;
      if (model.context && model.handle) {
        let target = 0;
        switch (model.target) {
          case model.context.TEXTURE_2D:
            target = model.context.TEXTURE_BINDING_2D;
            break;
          default:
            vtkWarningMacro8("impossible case");
            break;
        }
        const oid = model.context.getIntegerv(target);
        result = oid === model.handle;
      }
      return result;
    };
    publicAPI.sendParameters = () => {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
      if (model._openGLRenderWindow.getWebgl2()) {
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
      }
      model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
      model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
      if (model._openGLRenderWindow.getWebgl2()) {
        model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
        model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
      }
      model.sendParametersTime.modified();
    };
    publicAPI.getInternalFormat = (vtktype, numComps) => {
      if (!model._forceInternalFormat) {
        model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
      }
      if (!model.internalFormat) {
        vtkDebugMacro4(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
      }
      if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension("OES_texture_float_linear")) {
        vtkWarningMacro8("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.");
      }
      return model.internalFormat;
    };
    publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {
      let result = 0;
      result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, getNorm16Ext(), publicAPI.useHalfFloat());
      if (result) {
        return result;
      }
      if (!result) {
        vtkDebugMacro4("Unsupported internal texture type!");
        vtkDebugMacro4(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
      }
      return result;
    };
    publicAPI.useHalfFloat = () => model.enableUseHalfFloat && model.canUseHalfFloat;
    publicAPI.setInternalFormat = (iFormat) => {
      model._forceInternalFormat = true;
      if (iFormat !== model.internalFormat) {
        model.internalFormat = iFormat;
        publicAPI.modified();
      }
    };
    publicAPI.getFormat = (vtktype, numComps) => {
      model.format = publicAPI.getDefaultFormat(vtktype, numComps);
      return model.format;
    };
    publicAPI.getDefaultFormat = (vtktype, numComps) => {
      if (model._openGLRenderWindow.getWebgl2()) {
        switch (numComps) {
          case 1:
            return model.context.RED;
          case 2:
            return model.context.RG;
          case 3:
            return model.context.RGB;
          case 4:
            return model.context.RGBA;
          default:
            return model.context.RGB;
        }
      } else {
        switch (numComps) {
          case 1:
            return model.context.LUMINANCE;
          case 2:
            return model.context.LUMINANCE_ALPHA;
          case 3:
            return model.context.RGB;
          case 4:
            return model.context.RGBA;
          default:
            return model.context.RGB;
        }
      }
    };
    publicAPI.resetFormatAndType = () => {
      model._prevTexParams = null;
      model.format = 0;
      model.internalFormat = 0;
      model._forceInternalFormat = false;
      model.openGLDataType = 0;
    };
    publicAPI.getDefaultDataType = (vtkScalarType) => {
      const useHalfFloat = publicAPI.useHalfFloat();
      if (model._openGLRenderWindow.getWebgl2()) {
        switch (vtkScalarType) {
          // case VtkDataTypes.SIGNED_CHAR:
          //   return model.context.BYTE;
          case VtkDataTypes4.UNSIGNED_CHAR:
            return model.context.UNSIGNED_BYTE;
          // prefer norm16 since that is accurate compared to
          // half float which is not
          case (getNorm16Ext() && !useHalfFloat && VtkDataTypes4.SHORT):
            return model.context.SHORT;
          case (getNorm16Ext() && !useHalfFloat && VtkDataTypes4.UNSIGNED_SHORT):
            return model.context.UNSIGNED_SHORT;
          // use half float type
          case (useHalfFloat && VtkDataTypes4.SHORT):
            return model.context.HALF_FLOAT;
          case (useHalfFloat && VtkDataTypes4.UNSIGNED_SHORT):
            return model.context.HALF_FLOAT;
          // case VtkDataTypes.INT:
          //   return model.context.INT;
          // case VtkDataTypes.UNSIGNED_INT:
          //   return model.context.UNSIGNED_INT;
          case VtkDataTypes4.FLOAT:
          case VtkDataTypes4.VOID:
          // used for depth component textures.
          default:
            return model.context.FLOAT;
        }
      }
      switch (vtkScalarType) {
        // case VtkDataTypes.SIGNED_CHAR:
        //   return model.context.BYTE;
        case VtkDataTypes4.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        // case VtkDataTypes.SHORT:
        //   return model.context.SHORT;
        // case VtkDataTypes.UNSIGNED_SHORT:
        //   return model.context.UNSIGNED_SHORT;
        // case VtkDataTypes.INT:
        //   return model.context.INT;
        // case VtkDataTypes.UNSIGNED_INT:
        //   return model.context.UNSIGNED_INT;
        case VtkDataTypes4.FLOAT:
        case VtkDataTypes4.VOID:
        // used for depth component textures.
        default:
          if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
            return model.context.FLOAT;
          }
          {
            const halfFloat = model.context.getExtension("OES_texture_half_float");
            if (halfFloat && model.context.getExtension("OES_texture_half_float_linear")) {
              return halfFloat.HALF_FLOAT_OES;
            }
          }
          return model.context.UNSIGNED_BYTE;
      }
    };
    publicAPI.getOpenGLDataType = function(vtkScalarType) {
      let forceUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!model.openGLDataType || forceUpdate) {
        model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);
      }
      return model.openGLDataType;
    };
    publicAPI.getShiftAndScale = () => {
      let shift = 0;
      let scale7 = 1;
      switch (model.openGLDataType) {
        case model.context.BYTE:
          scale7 = 127.5;
          shift = scale7 - 128;
          break;
        case model.context.UNSIGNED_BYTE:
          scale7 = 255;
          shift = 0;
          break;
        case model.context.SHORT:
          scale7 = 32767.5;
          shift = scale7 - 32768;
          break;
        case model.context.UNSIGNED_SHORT:
          scale7 = 65536;
          shift = 0;
          break;
        case model.context.INT:
          scale7 = 21474836475e-1;
          shift = scale7 - 2147483648;
          break;
        case model.context.UNSIGNED_INT:
          scale7 = 4294967295;
          shift = 0;
          break;
        case model.context.FLOAT:
      }
      return {
        shift,
        scale: scale7
      };
    };
    publicAPI.getOpenGLFilterMode = (emode) => {
      switch (emode) {
        case Filter2.NEAREST:
          return model.context.NEAREST;
        case Filter2.LINEAR:
          return model.context.LINEAR;
        case Filter2.NEAREST_MIPMAP_NEAREST:
          return model.context.NEAREST_MIPMAP_NEAREST;
        case Filter2.NEAREST_MIPMAP_LINEAR:
          return model.context.NEAREST_MIPMAP_LINEAR;
        case Filter2.LINEAR_MIPMAP_NEAREST:
          return model.context.LINEAR_MIPMAP_NEAREST;
        case Filter2.LINEAR_MIPMAP_LINEAR:
          return model.context.LINEAR_MIPMAP_LINEAR;
        default:
          return model.context.NEAREST;
      }
    };
    publicAPI.getOpenGLWrapMode = (vtktype) => {
      switch (vtktype) {
        case Wrap2.CLAMP_TO_EDGE:
          return model.context.CLAMP_TO_EDGE;
        case Wrap2.REPEAT:
          return model.context.REPEAT;
        case Wrap2.MIRRORED_REPEAT:
          return model.context.MIRRORED_REPEAT;
        default:
          return model.context.CLAMP_TO_EDGE;
      }
    };
    function getExtentSize(extent) {
      const [xmin, xmax, ymin, ymax, zmin, zmax] = extent;
      return [xmax - xmin + 1, ymax - ymin + 1, zmax - zmin + 1];
    }
    function getExtentPixelCount(extent) {
      const [sx, sy, sz] = getExtentSize(extent);
      return sx * sy * sz;
    }
    function readExtentIntoArray(data, dataDims, extent, outArray, outOffset) {
      const [xmin, xmax, ymin, ymax, zmin, zmax] = extent;
      const [dx, dy] = dataDims;
      const sxy = dx * dy;
      let writeOffset = outOffset;
      for (let zi = zmin; zi <= zmax; zi++) {
        const zOffset = zi * sxy;
        for (let yi = ymin; yi <= ymax; yi++) {
          const zyOffset = zOffset + yi * dx;
          for (let readOffset = zyOffset + xmin, end = zyOffset + xmax; readOffset <= end; readOffset++, writeOffset++) {
            outArray[writeOffset] = data[readOffset];
          }
        }
      }
    }
    function readExtents(data, extents) {
      let typedArrayConstructor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      const constructor = typedArrayConstructor || data.constructor;
      const numPixels = extents.reduce((count, extent) => count + getExtentPixelCount(extent), 0);
      const extentPixels = new constructor(numPixels);
      const dataDims = [model.width, model.height, model.depth];
      let writeOffset = 0;
      extents.forEach((extent) => {
        readExtentIntoArray(data, dataDims, extent, extentPixels, writeOffset);
        writeOffset += getExtentPixelCount(extent);
      });
      return extentPixels;
    }
    publicAPI.updateArrayDataTypeForGL = function(dataType, data) {
      let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let imageExtents = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      const pixData = [];
      let pixCount = model.width * model.height * model.components;
      if (depth) {
        pixCount *= model.depth;
      }
      const onlyUpdateExtents = !!imageExtents.length;
      if (dataType !== VtkDataTypes4.FLOAT && model.openGLDataType === model.context.FLOAT) {
        for (let idx = 0; idx < data.length; idx++) {
          if (data[idx]) {
            if (onlyUpdateExtents) {
              pixData.push(readExtents(data[idx], imageExtents, Float32Array));
            } else {
              const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
              pixData.push(new Float32Array(dataArrayToCopy));
            }
          } else {
            pixData.push(null);
          }
        }
      }
      if (dataType !== VtkDataTypes4.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
        for (let idx = 0; idx < data.length; idx++) {
          if (data[idx]) {
            if (onlyUpdateExtents) {
              pixData.push(readExtents(data[idx], imageExtents, Uint8Array));
            } else {
              const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
              pixData.push(new Uint8Array(dataArrayToCopy));
            }
          } else {
            pixData.push(null);
          }
        }
      }
      let halfFloat = false;
      if (model._openGLRenderWindow.getWebgl2()) {
        halfFloat = model.openGLDataType === model.context.HALF_FLOAT;
      } else {
        const halfFloatExt = model.context.getExtension("OES_texture_half_float");
        halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
      }
      if (halfFloat) {
        for (let idx = 0; idx < data.length; idx++) {
          if (data[idx]) {
            const src = onlyUpdateExtents ? readExtents(data[idx], imageExtents) : data[idx];
            const newArray = new Uint16Array(onlyUpdateExtents ? src.length : pixCount);
            const newArrayLen = newArray.length;
            for (let i = 0; i < newArrayLen; i++) {
              newArray[i] = toHalf2(src[i]);
            }
            pixData.push(newArray);
          } else {
            pixData.push(null);
          }
        }
      }
      if (pixData.length === 0) {
        for (let i = 0; i < data.length; i++) {
          pixData.push(onlyUpdateExtents && data[i] ? readExtents(data[i], imageExtents) : data[i]);
        }
      }
      return pixData;
    };
    function scaleTextureToHighestPowerOfTwo(data) {
      if (model._openGLRenderWindow.getWebgl2()) {
        return data;
      }
      const pixData = [];
      const width = model.width;
      const height = model.height;
      const numComps = model.components;
      if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
        const halfFloat = model.context.getExtension("OES_texture_half_float");
        const newWidth = nearestPowerOfTwo(width);
        const newHeight = nearestPowerOfTwo(height);
        const pixCount = newWidth * newHeight * model.components;
        for (let idx = 0; idx < data.length; idx++) {
          if (data[idx] !== null) {
            let newArray = null;
            const jFactor = height / newHeight;
            const iFactor = width / newWidth;
            let usingHalf = false;
            if (model.openGLDataType === model.context.FLOAT) {
              newArray = new Float32Array(pixCount);
            } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
              newArray = new Uint16Array(pixCount);
              usingHalf = true;
            } else {
              newArray = new Uint8Array(pixCount);
            }
            for (let j = 0; j < newHeight; j++) {
              const joff = j * newWidth * numComps;
              const jidx = j * jFactor;
              let jlow = Math.floor(jidx);
              let jhi = Math.ceil(jidx);
              if (jhi >= height) {
                jhi = height - 1;
              }
              const jmix = jidx - jlow;
              const jmix1 = 1 - jmix;
              jlow = jlow * width * numComps;
              jhi = jhi * width * numComps;
              for (let i = 0; i < newWidth; i++) {
                const ioff = i * numComps;
                const iidx = i * iFactor;
                let ilow = Math.floor(iidx);
                let ihi = Math.ceil(iidx);
                if (ihi >= width) {
                  ihi = width - 1;
                }
                const imix = iidx - ilow;
                ilow *= numComps;
                ihi *= numComps;
                for (let c = 0; c < numComps; c++) {
                  if (usingHalf) {
                    newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);
                  } else {
                    newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1 - imix) + data[idx][jhi + ihi + c] * jmix * imix;
                  }
                }
              }
            }
            pixData.push(newArray);
            model.width = newWidth;
            model.height = newHeight;
          } else {
            pixData.push(null);
          }
        }
      }
      if (pixData.length === 0) {
        for (let i = 0; i < data.length; i++) {
          pixData.push(data[i]);
        }
      }
      return pixData;
    }
    function useTexStorage(dataType) {
      if (model._openGLRenderWindow) {
        if (model.resizable || model.renderable?.getResizable()) {
          return false;
        }
        if (model._openGLRenderWindow.getWebgl2()) {
          const webGLInfo = model._openGLRenderWindow.getGLInformations();
          if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && getNorm16Ext() && (dataType === VtkDataTypes4.UNSIGNED_SHORT || dataType === VtkDataTypes4.SHORT)) {
            return false;
          }
          return true;
        }
        return false;
      }
      return false;
    }
    publicAPI.create2DFromRaw = function() {
      let {
        width = requiredParam2("width"),
        height = requiredParam2("height"),
        numComps = requiredParam2("numComps"),
        dataType = requiredParam2("dataType"),
        data = requiredParam2("data"),
        flip = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      publicAPI.getOpenGLDataType(dataType, true);
      publicAPI.getInternalFormat(dataType, numComps);
      publicAPI.getFormat(dataType, numComps);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro16("Failed to determine texture parameters.");
        return false;
      }
      model.target = model.context.TEXTURE_2D;
      model.components = numComps;
      model.width = width;
      model.height = height;
      model.depth = 1;
      model.numberOfDimensions = 2;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();
      const dataArray = [data];
      const pixData = publicAPI.updateArrayDataTypeForGL(dataType, dataArray);
      const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (useTexStorage(dataType)) {
        model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
        if (scaledData[0] != null) {
          model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);
        }
      } else {
        model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
      }
      if (model.generateMipmap) {
        model.context.generateMipmap(model.target);
      }
      if (flip) {
        model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
      publicAPI.deactivate();
      return true;
    };
    publicAPI.createCubeFromRaw = function() {
      let {
        width = requiredParam2("width"),
        height = requiredParam2("height"),
        numComps = requiredParam2("numComps"),
        dataType = requiredParam2("dataType"),
        data = requiredParam2("data")
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      publicAPI.getOpenGLDataType(dataType);
      publicAPI.getInternalFormat(dataType, numComps);
      publicAPI.getFormat(dataType, numComps);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro16("Failed to determine texture parameters.");
        return false;
      }
      model.target = model.context.TEXTURE_CUBE_MAP;
      model.components = numComps;
      model.width = width;
      model.height = height;
      model.depth = 1;
      model.numberOfDimensions = 2;
      model._openGLRenderWindow.activateTexture(publicAPI);
      model.maxLevel = data.length / 6 - 1;
      publicAPI.createTexture();
      publicAPI.bind();
      const pixData = publicAPI.updateArrayDataTypeForGL(dataType, data);
      const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
      const invertedData = [];
      let widthLevel = model.width;
      let heightLevel = model.height;
      for (let i = 0; i < scaledData.length; i++) {
        if (i % 6 === 0 && i !== 0) {
          widthLevel /= 2;
          heightLevel /= 2;
        }
        invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);
        for (let y = 0; y < heightLevel; ++y) {
          const row1 = y * widthLevel * model.components;
          const row2 = (heightLevel - y - 1) * widthLevel * model.components;
          invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);
        }
      }
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (useTexStorage(dataType)) {
        model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);
      }
      for (let i = 0; i < 6; i++) {
        let j = 0;
        let w = model.width;
        let h = model.height;
        while (w >= 1 && h >= 1) {
          let tempData = null;
          if (j <= model.maxLevel) {
            tempData = invertedData[6 * j + i];
          }
          if (useTexStorage(dataType)) {
            if (tempData != null) {
              model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);
            }
          } else {
            model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);
          }
          j++;
          w /= 2;
          h /= 2;
        }
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
      publicAPI.deactivate();
      return true;
    };
    publicAPI.createDepthFromRaw = function() {
      let {
        width = requiredParam2("width"),
        height = requiredParam2("height"),
        dataType = requiredParam2("dataType"),
        data = requiredParam2("data")
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      publicAPI.getOpenGLDataType(dataType);
      model.format = model.context.DEPTH_COMPONENT;
      if (model._openGLRenderWindow.getWebgl2()) {
        if (dataType === VtkDataTypes4.FLOAT) {
          model.internalFormat = model.context.DEPTH_COMPONENT32F;
        } else {
          model.internalFormat = model.context.DEPTH_COMPONENT16;
        }
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT;
      }
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro16("Failed to determine texture parameters.");
        return false;
      }
      model.target = model.context.TEXTURE_2D;
      model.components = 1;
      model.width = width;
      model.height = height;
      model.depth = 1;
      model.numberOfDimensions = 2;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (useTexStorage(dataType)) {
        model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
        if (data != null) {
          model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);
        }
      } else {
        model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
      }
      if (model.generateMipmap) {
        model.context.generateMipmap(model.target);
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
      publicAPI.deactivate();
      return true;
    };
    publicAPI.create2DFromImage = (image) => {
      publicAPI.getOpenGLDataType(VtkDataTypes4.UNSIGNED_CHAR);
      publicAPI.getInternalFormat(VtkDataTypes4.UNSIGNED_CHAR, 4);
      publicAPI.getFormat(VtkDataTypes4.UNSIGNED_CHAR, 4);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro16("Failed to determine texture parameters.");
        return false;
      }
      model.target = model.context.TEXTURE_2D;
      model.components = 4;
      model.depth = 1;
      model.numberOfDimensions = 2;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();
      const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));
      let textureSource = image;
      let targetWidth = image.width;
      let targetHeight = image.height;
      let flipY = true;
      const isChrome = window.chrome;
      if (needNearestPowerOfTwo || isChrome) {
        const canvas = new OffscreenCanvas(nearestPowerOfTwo(image.width), nearestPowerOfTwo(image.height));
        targetWidth = canvas.width;
        targetHeight = canvas.height;
        const ctx = canvas.getContext("2d");
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);
        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
        textureSource = canvas;
        flipY = false;
      }
      model.width = targetWidth;
      model.height = targetHeight;
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flipY);
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (useTexStorage(VtkDataTypes4.UNSIGNED_CHAR)) {
        model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, textureSource);
      } else {
        model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, textureSource);
      }
      if (model.generateMipmap) {
        model.context.generateMipmap(model.target);
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes4.UNSIGNED_CHAR, getNorm16Ext(), publicAPI.useHalfFloat());
      publicAPI.deactivate();
      return true;
    };
    publicAPI.create2DFromImageBitmap = (imageBitmap) => {
      publicAPI.getOpenGLDataType(VtkDataTypes4.UNSIGNED_CHAR);
      publicAPI.getInternalFormat(VtkDataTypes4.UNSIGNED_CHAR, 4);
      publicAPI.getFormat(VtkDataTypes4.UNSIGNED_CHAR, 4);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro16("Failed to determine texture parameters.");
        return false;
      }
      model.target = model.context.TEXTURE_2D;
      model.components = 4;
      model.depth = 1;
      model.numberOfDimensions = 2;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      model.width = imageBitmap.width;
      model.height = imageBitmap.height;
      if (useTexStorage(VtkDataTypes4.UNSIGNED_CHAR)) {
        model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, imageBitmap);
      } else {
        model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, imageBitmap);
      }
      if (model.generateMipmap) {
        model.context.generateMipmap(model.target);
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes4.UNSIGNED_CHAR, getNorm16Ext(), publicAPI.useHalfFloat());
      publicAPI.deactivate();
      return true;
    };
    function computeScaleOffsets(min4, max4, numComps) {
      const offset = new Array(numComps);
      const scale7 = new Array(numComps);
      for (let c = 0; c < numComps; ++c) {
        offset[c] = min4[c];
        scale7[c] = max4[c] - min4[c] || 1;
      }
      return {
        scale: scale7,
        offset
      };
    }
    function hasExactHalfFloat(offset, scale7) {
      for (let c = 0; c < offset.length; c++) {
        const min4 = offset[c];
        const max4 = scale7[c] + min4;
        if (min4 < -2048 || min4 > 2048 || max4 < -2048 || max4 > 2048) {
          return false;
        }
      }
      return true;
    }
    function setCanUseHalfFloat(dataType, offset, scale7, preferSizeOverAccuracy) {
      publicAPI.getOpenGLDataType(dataType);
      const isExactHalfFloat = hasExactHalfFloat(offset, scale7) || preferSizeOverAccuracy;
      let useHalfFloat = false;
      if (model._openGLRenderWindow.getWebgl2()) {
        const forceHalfFloat = model.openGLDataType === model.context.FLOAT && model.context.getExtension("OES_texture_float_linear") === null && isExactHalfFloat;
        useHalfFloat = forceHalfFloat || model.openGLDataType === model.context.HALF_FLOAT;
      } else {
        const halfFloatExt = model.context.getExtension("OES_texture_half_float");
        useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
      }
      model.canUseHalfFloat = useHalfFloat && isExactHalfFloat;
    }
    function processDataArray(dataArray, preferSizeOverAccuracy) {
      const numComps = dataArray.getNumberOfComponents();
      const dataType = dataArray.getDataType();
      const data = dataArray.getData();
      const minArray = new Array(numComps);
      const maxArray = new Array(numComps);
      for (let c = 0; c < numComps; ++c) {
        const [min4, max4] = dataArray.getRange(c);
        minArray[c] = min4;
        maxArray[c] = max4;
      }
      const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);
      setCanUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);
      if (!publicAPI.useHalfFloat()) {
        publicAPI.getOpenGLDataType(dataType, true);
      }
      return {
        numComps,
        dataType,
        data,
        scaleOffsets
      };
    }
    publicAPI.create2DFilterableFromRaw = function() {
      let {
        width = requiredParam2("width"),
        height = requiredParam2("height"),
        numComps = requiredParam2("numComps"),
        dataType = requiredParam2("dataType"),
        data = requiredParam2("data"),
        preferSizeOverAccuracy = false,
        ranges = void 0
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return publicAPI.create2DFilterableFromDataArray({
        width,
        height,
        dataArray: vtkDataArray$1.newInstance({
          numComps,
          dataType,
          values: data,
          ranges
        }),
        preferSizeOverAccuracy
      });
    };
    publicAPI.create2DFilterableFromDataArray = function() {
      let {
        width = requiredParam2("width"),
        height = requiredParam2("height"),
        dataArray = requiredParam2("dataArray"),
        preferSizeOverAccuracy = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        numComps,
        dataType,
        data
      } = processDataArray(dataArray, preferSizeOverAccuracy);
      publicAPI.create2DFromRaw({
        width,
        height,
        numComps,
        dataType,
        data
      });
    };
    publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {
      let isScalingApplied = false;
      const useHalfFloat = publicAPI.useHalfFloat();
      if (!model.volumeInfo?.scale || !model.volumeInfo?.offset) {
        model.volumeInfo = {
          scale: new Array(numComps),
          offset: new Array(numComps)
        };
      }
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 1;
        model.volumeInfo.offset[c] = 0;
      }
      if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes4.SHORT) {
        for (let c = 0; c < numComps; ++c) {
          model.volumeInfo.scale[c] = 32767;
        }
        isScalingApplied = true;
      }
      if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes4.UNSIGNED_SHORT) {
        for (let c = 0; c < numComps; ++c) {
          model.volumeInfo.scale[c] = 65535;
        }
        isScalingApplied = true;
      }
      if (dataType === VtkDataTypes4.UNSIGNED_CHAR) {
        for (let c = 0; c < numComps; ++c) {
          model.volumeInfo.scale[c] = 255;
        }
        isScalingApplied = true;
      }
      if (dataType === VtkDataTypes4.FLOAT || useHalfFloat && (dataType === VtkDataTypes4.SHORT || dataType === VtkDataTypes4.UNSIGNED_SHORT)) {
        isScalingApplied = true;
      }
      return isScalingApplied;
    };
    publicAPI.create3DFromRaw = function() {
      let {
        width = requiredParam2("width"),
        height = requiredParam2("height"),
        depth = requiredParam2("depth"),
        numComps = requiredParam2("numComps"),
        dataType = requiredParam2("dataType"),
        data = requiredParam2("data"),
        updatedExtents = []
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let dataTypeToUse = dataType;
      let dataToUse = data;
      if (!publicAPI.updateVolumeInfoForGL(dataTypeToUse, numComps) && dataToUse) {
        const numPixelsIn = width * height * depth;
        const scaleOffsetsCopy = structuredClone(model.volumeInfo);
        const newArray = new Float32Array(numPixelsIn * numComps);
        model.volumeInfo.offset = scaleOffsetsCopy.offset;
        model.volumeInfo.scale = scaleOffsetsCopy.scale;
        let count = 0;
        const scaleInverse = scaleOffsetsCopy.scale.map((s) => 1 / s);
        for (let i = 0; i < numPixelsIn; i++) {
          for (let nc = 0; nc < numComps; nc++) {
            newArray[count] = (dataToUse[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];
            count++;
          }
        }
        dataTypeToUse = VtkDataTypes4.FLOAT;
        dataToUse = newArray;
      }
      publicAPI.getOpenGLDataType(dataTypeToUse);
      publicAPI.getInternalFormat(dataTypeToUse, numComps);
      publicAPI.getFormat(dataTypeToUse, numComps);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro16("Failed to determine texture parameters.");
        return false;
      }
      model.target = model.context.TEXTURE_3D;
      model.components = numComps;
      model.width = width;
      model.height = height;
      model.depth = depth;
      model.numberOfDimensions = 3;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();
      const hasUpdatedExtents = updatedExtents.length > 0;
      const rebuildEntireTexture = !hasUpdatedExtents || !(0, import_fast_deep_equal2.default)(model._prevTexParams, getTexParams());
      const dataArray = [dataToUse];
      const is3DArray = true;
      const pixData = publicAPI.updateArrayDataTypeForGL(dataTypeToUse, dataArray, is3DArray, rebuildEntireTexture ? [] : updatedExtents);
      const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (rebuildEntireTexture) {
        if (useTexStorage(dataTypeToUse)) {
          model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);
          if (scaledData[0] != null) {
            model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);
          }
        } else {
          model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
        }
        model._prevTexParams = getTexParams();
      } else if (hasUpdatedExtents) {
        const extentPixels = scaledData[0];
        let readOffset = 0;
        for (let i = 0; i < updatedExtents.length; i++) {
          const extent = updatedExtents[i];
          const extentSize = getExtentSize(extent);
          const extentPixelCount = getExtentPixelCount(extent);
          const textureData = new extentPixels.constructor(extentPixels.buffer, readOffset, extentPixelCount);
          readOffset += textureData.byteLength;
          model.context.texSubImage3D(model.target, 0, extent[0], extent[2], extent[4], extentSize[0], extentSize[1], extentSize[2], model.format, model.openGLDataType, textureData);
        }
      }
      if (model.generateMipmap) {
        model.context.generateMipmap(model.target);
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataTypeToUse, getNorm16Ext(), publicAPI.useHalfFloat());
      publicAPI.deactivate();
      return true;
    };
    publicAPI.create3DFilterableFromRaw = function() {
      let {
        width = requiredParam2("width"),
        height = requiredParam2("height"),
        depth = requiredParam2("depth"),
        numComps = requiredParam2("numComps"),
        dataType = requiredParam2("dataType"),
        data = requiredParam2("data"),
        preferSizeOverAccuracy = false,
        ranges = void 0,
        updatedExtents = []
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return publicAPI.create3DFilterableFromDataArray({
        width,
        height,
        depth,
        dataArray: vtkDataArray$1.newInstance({
          numComps,
          dataType,
          values: data,
          ranges
        }),
        preferSizeOverAccuracy,
        updatedExtents
      });
    };
    publicAPI.create3DFilterableFromDataArray = function() {
      let {
        width = requiredParam2("width"),
        height = requiredParam2("height"),
        depth = requiredParam2("depth"),
        dataArray = requiredParam2("dataArray"),
        preferSizeOverAccuracy = false,
        updatedExtents = []
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        numComps,
        dataType,
        data,
        scaleOffsets
      } = processDataArray(dataArray, preferSizeOverAccuracy);
      const offset = [];
      const scale7 = [];
      for (let c = 0; c < numComps; ++c) {
        offset[c] = 0;
        scale7[c] = 1;
      }
      model.volumeInfo = {
        scale: scale7,
        offset,
        dataComputedScale: scaleOffsets.scale,
        dataComputedOffset: scaleOffsets.offset,
        width,
        height,
        depth
      };
      if (model._openGLRenderWindow.getWebgl2()) {
        return publicAPI.create3DFromRaw({
          width,
          height,
          depth,
          numComps,
          dataType,
          data,
          updatedExtents
        });
      }
      const numPixelsIn = width * height * depth;
      const scaleOffsetsCopy = structuredClone(scaleOffsets);
      let volCopyData = (outArray, outIdx2, inValue, smin, smax) => {
        outArray[outIdx2] = inValue;
      };
      let dataTypeToUse = VtkDataTypes4.UNSIGNED_CHAR;
      if (dataType === VtkDataTypes4.UNSIGNED_CHAR) {
        for (let c = 0; c < numComps; ++c) {
          scaleOffsetsCopy.offset[c] = 0;
          scaleOffsetsCopy.scale[c] = 255;
        }
      } else if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
        dataTypeToUse = VtkDataTypes4.FLOAT;
        volCopyData = (outArray, outIdx2, inValue, soffset, sscale) => {
          outArray[outIdx2] = (inValue - soffset) / sscale;
        };
      } else {
        dataTypeToUse = VtkDataTypes4.UNSIGNED_CHAR;
        volCopyData = (outArray, outIdx2, inValue, soffset, sscale) => {
          outArray[outIdx2] = 255 * (inValue - soffset) / sscale;
        };
      }
      publicAPI.getOpenGLDataType(dataTypeToUse);
      publicAPI.getInternalFormat(dataTypeToUse, numComps);
      publicAPI.getFormat(dataTypeToUse, numComps);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro16("Failed to determine texture parameters.");
        return false;
      }
      model.target = model.context.TEXTURE_2D;
      model.components = numComps;
      model.depth = 1;
      model.numberOfDimensions = 2;
      let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes4.FLOAT || numComps >= 3)) {
        maxTexDim = 4096;
      }
      let xstride = 1;
      let ystride = 1;
      if (numPixelsIn > maxTexDim * maxTexDim) {
        xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
        ystride = xstride;
      }
      let targetWidth = Math.sqrt(numPixelsIn) / xstride;
      targetWidth = nearestPowerOfTwo(targetWidth);
      const xreps = Math.floor(targetWidth * xstride / width);
      const yreps = Math.ceil(depth / xreps);
      const targetHeight = nearestPowerOfTwo(height * yreps / ystride);
      model.width = targetWidth;
      model.height = targetHeight;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();
      model.volumeInfo.xreps = xreps;
      model.volumeInfo.yreps = yreps;
      model.volumeInfo.xstride = xstride;
      model.volumeInfo.ystride = ystride;
      model.volumeInfo.offset = scaleOffsetsCopy.offset;
      model.volumeInfo.scale = scaleOffsetsCopy.scale;
      let newArray;
      const pixCount = targetWidth * targetHeight * numComps;
      if (dataTypeToUse === VtkDataTypes4.FLOAT) {
        newArray = new Float32Array(pixCount);
      } else {
        newArray = new Uint8Array(pixCount);
      }
      let outIdx = 0;
      const tileWidth = Math.floor(width / xstride);
      const tileHeight = Math.floor(height / ystride);
      for (let yRep = 0; yRep < yreps; yRep++) {
        const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
        const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
        for (let tileY = 0; tileY < tileHeight; tileY++) {
          for (let xRep = 0; xRep < xrepsThisRow; xRep++) {
            const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
            for (let tileX = 0; tileX < tileWidth; tileX++) {
              for (let nc = 0; nc < numComps; nc++) {
                volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);
                outIdx++;
              }
            }
          }
          outIdx += outXContIncr;
        }
      }
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (useTexStorage(dataTypeToUse)) {
        model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
        if (newArray != null) {
          model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);
        }
      } else {
        model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
      }
      publicAPI.deactivate();
      return true;
    };
    publicAPI.setOpenGLRenderWindow = (rw) => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };
    publicAPI.getMaximumTextureSize = (ctx) => {
      if (ctx && ctx.isCurrent()) {
        return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
      }
      return -1;
    };
    publicAPI.enableUseHalfFloat = (use) => {
      model.enableUseHalfFloat = use;
    };
  }
  var DEFAULT_VALUES41 = {
    _openGLRenderWindow: null,
    _forceInternalFormat: false,
    _prevTexParams: null,
    context: null,
    handle: 0,
    sendParametersTime: null,
    textureBuildTime: null,
    numberOfDimensions: 0,
    target: 0,
    format: 0,
    openGLDataType: 0,
    components: 0,
    width: 0,
    height: 0,
    depth: 0,
    autoParameters: true,
    wrapS: Wrap2.CLAMP_TO_EDGE,
    wrapT: Wrap2.CLAMP_TO_EDGE,
    wrapR: Wrap2.CLAMP_TO_EDGE,
    minificationFilter: Filter2.NEAREST,
    magnificationFilter: Filter2.NEAREST,
    minLOD: -1e3,
    maxLOD: 1e3,
    baseLevel: 0,
    maxLevel: 1e3,
    generateMipmap: false,
    oglNorm16Ext: null,
    allocatedGPUMemoryInBytes: 0,
    // by default it is enabled
    enableUseHalfFloat: true,
    // but by default we don't know if we can use half float base on the data range
    canUseHalfFloat: false
  };
  function extend43(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES41, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.sendParametersTime = {};
    obj(model.sendParametersTime, {
      mtime: 0
    });
    model.textureBuildTime = {};
    obj(model.textureBuildTime, {
      mtime: 0
    });
    set(publicAPI, model, ["format", "openGLDataType"]);
    setGet(publicAPI, model, ["keyMatrixTime", "minificationFilter", "magnificationFilter", "wrapS", "wrapT", "wrapR", "generateMipmap", "oglNorm16Ext"]);
    get(publicAPI, model, ["width", "height", "volumeInfo", "components", "handle", "target", "allocatedGPUMemoryInBytes"]);
    moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
    vtkOpenGLTexture(publicAPI, model);
  }
  var newInstance43 = newInstance(extend43, "vtkOpenGLTexture");
  var vtkOpenGLTexture$1 = {
    newInstance: newInstance43,
    extend: extend43,
    ...Constants10
  };
  registerOverride("vtkTexture", newInstance43);

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js
  function vtkFramebuffer(publicAPI, model) {
    model.classHierarchy.push("vtkFramebuffer");
    publicAPI.getBothMode = () => model.context.FRAMEBUFFER;
    publicAPI.saveCurrentBindingsAndBuffers = (modeIn) => {
      const mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
      publicAPI.saveCurrentBindings(mode);
      publicAPI.saveCurrentBuffers(mode);
    };
    publicAPI.saveCurrentBindings = (modeIn) => {
      if (!model.context) {
        vtkErrorMacro2("you must set the OpenGLRenderWindow before calling saveCurrentBindings");
        return;
      }
      const gl = model.context;
      model.previousDrawBinding = gl.getParameter(model.context.FRAMEBUFFER_BINDING);
      model.previousActiveFramebuffer = model._openGLRenderWindow.getActiveFramebuffer();
    };
    publicAPI.saveCurrentBuffers = (modeIn) => {
    };
    publicAPI.restorePreviousBindingsAndBuffers = (modeIn) => {
      const mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
      publicAPI.restorePreviousBindings(mode);
      publicAPI.restorePreviousBuffers(mode);
    };
    publicAPI.restorePreviousBindings = (modeIn) => {
      if (!model.context) {
        vtkErrorMacro2("you must set the OpenGLRenderWindow before calling restorePreviousBindings");
        return;
      }
      const gl = model.context;
      gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
      model._openGLRenderWindow.setActiveFramebuffer(model.previousActiveFramebuffer);
    };
    publicAPI.restorePreviousBuffers = (modeIn) => {
    };
    publicAPI.bind = function() {
      let modeArg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let mode = modeArg;
      if (mode === null) {
        mode = model.context.FRAMEBUFFER;
      }
      model.context.bindFramebuffer(mode, model.glFramebuffer);
      for (let i = 0; i < model.colorBuffers.length; i++) {
        model.colorBuffers[i].bind();
      }
      model._openGLRenderWindow.setActiveFramebuffer(publicAPI);
    };
    publicAPI.create = (width, height) => {
      if (!model.context) {
        vtkErrorMacro2("you must set the OpenGLRenderWindow before calling create");
        return;
      }
      model.glFramebuffer = model.context.createFramebuffer();
      model.glFramebuffer.width = width;
      model.glFramebuffer.height = height;
    };
    publicAPI.setColorBuffer = function(texture) {
      let attachment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      const gl = model.context;
      if (!gl) {
        vtkErrorMacro2("you must set the OpenGLRenderWindow before calling setColorBuffer");
        return;
      }
      let glAttachment = gl.COLOR_ATTACHMENT0;
      if (attachment > 0) {
        if (model._openGLRenderWindow.getWebgl2()) {
          glAttachment += attachment;
        } else {
          vtkErrorMacro2("Using multiple framebuffer attachments requires WebGL 2");
          return;
        }
      }
      model.colorBuffers[attachment] = texture;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, texture.getHandle(), 0);
    };
    publicAPI.removeColorBuffer = function() {
      let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      const gl = model.context;
      if (!gl) {
        vtkErrorMacro2("you must set the OpenGLRenderWindow before calling removeColorBuffer");
        return;
      }
      let glAttachment = gl.COLOR_ATTACHMENT0;
      if (attachment > 0) {
        if (model._openGLRenderWindow.getWebgl2()) {
          glAttachment += attachment;
        } else {
          vtkErrorMacro2("Using multiple framebuffer attachments requires WebGL 2");
          return;
        }
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, null, 0);
      model.colorBuffers = model.colorBuffers.splice(attachment, 1);
    };
    publicAPI.setDepthBuffer = (texture) => {
      if (!model.context) {
        vtkErrorMacro2("you must set the OpenGLRenderWindow before calling setDepthBuffer");
        return;
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        const gl = model.context;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, texture.getHandle(), 0);
      } else {
        vtkErrorMacro2("Attaching depth buffer textures to fbo requires WebGL 2");
      }
    };
    publicAPI.removeDepthBuffer = () => {
      if (!model.context) {
        vtkErrorMacro2("you must set the OpenGLRenderWindow before calling removeDepthBuffer");
        return;
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        const gl = model.context;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
      } else {
        vtkErrorMacro2("Attaching depth buffer textures to framebuffers requires WebGL 2");
      }
    };
    publicAPI.getGLFramebuffer = () => model.glFramebuffer;
    publicAPI.setOpenGLRenderWindow = (rw) => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };
    publicAPI.releaseGraphicsResources = () => {
      if (model.glFramebuffer) {
        model.context.deleteFramebuffer(model.glFramebuffer);
      }
    };
    publicAPI.getSize = () => {
      if (model.glFramebuffer == null) return null;
      return [model.glFramebuffer.width, model.glFramebuffer.height];
    };
    publicAPI.populateFramebuffer = () => {
      if (!model.context) {
        vtkErrorMacro2("you must set the OpenGLRenderWindow before calling populateFrameBuffer");
        return;
      }
      publicAPI.bind();
      const gl = model.context;
      const texture = vtkOpenGLTexture$1.newInstance();
      texture.setOpenGLRenderWindow(model._openGLRenderWindow);
      texture.setMinificationFilter(Filter.LINEAR);
      texture.setMagnificationFilter(Filter.LINEAR);
      texture.create2DFromRaw({
        width: model.glFramebuffer.width,
        height: model.glFramebuffer.height,
        numComps: 4,
        dataType: VtkDataTypes.UNSIGNED_CHAR,
        data: null
      });
      publicAPI.setColorBuffer(texture);
      model.depthTexture = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, model.glFramebuffer.width, model.glFramebuffer.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, model.depthTexture);
    };
    publicAPI.getColorTexture = () => model.colorBuffers[0];
  }
  var DEFAULT_VALUES42 = {
    // _openGLRenderWindow: null,
    glFramebuffer: null,
    colorBuffers: null,
    depthTexture: null,
    previousDrawBinding: 0,
    previousReadBinding: 0,
    previousDrawBuffer: 0,
    previousReadBuffer: 0,
    previousActiveFramebuffer: null
  };
  function extend44(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES42, initialValues);
    obj(publicAPI, model);
    if (model.colorBuffers) {
      vtkErrorMacro2("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.");
    }
    model.colorBuffers = [];
    getArray(publicAPI, model, ["colorBuffers"]);
    vtkFramebuffer(publicAPI, model);
  }
  var newInstance44 = newInstance(extend44, "vtkFramebuffer");
  var vtkOpenGLFramebuffer = {
    newInstance: newInstance44,
    extend: extend44
  };

  // node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderPass.js
  function vtkRenderPass(publicAPI, model) {
    model.classHierarchy.push("vtkRenderPass");
    publicAPI.getOperation = () => model.currentOperation;
    publicAPI.setCurrentOperation = (val) => {
      model.currentOperation = val;
      model.currentTraverseOperation = `traverse${macro.capitalize(model.currentOperation)}`;
    };
    publicAPI.getTraverseOperation = () => model.currentTraverseOperation;
    publicAPI.traverse = function(viewNode) {
      let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (model.deleted) {
        return;
      }
      model._currentParent = parent;
      model.preDelegateOperations.forEach((val) => {
        publicAPI.setCurrentOperation(val);
        viewNode.traverse(publicAPI);
      });
      model.delegates.forEach((val) => {
        val.traverse(viewNode, publicAPI);
      });
      model.postDelegateOperations.forEach((val) => {
        publicAPI.setCurrentOperation(val);
        viewNode.traverse(publicAPI);
      });
    };
  }
  var DEFAULT_VALUES43 = {
    delegates: [],
    currentOperation: null,
    preDelegateOperations: [],
    postDelegateOperations: [],
    currentParent: null
  };
  function extend45(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES43, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["currentOperation"]);
    macro.setGet(publicAPI, model, ["delegates", "_currentParent", "preDelegateOperations", "postDelegateOperations"]);
    macro.moveToProtected(publicAPI, model, ["currentParent"]);
    vtkRenderPass(publicAPI, model);
  }
  var newInstance45 = macro.newInstance(extend45, "vtkRenderPass");
  var vtkRenderPass$1 = {
    newInstance: newInstance45,
    extend: extend45
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
  var ObjectType = {
    ARRAY_BUFFER: 0,
    ELEMENT_ARRAY_BUFFER: 1,
    TEXTURE_BUFFER: 2
  };
  var Constants11 = {
    ObjectType
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
  var {
    ObjectType: ObjectType2
  } = Constants11;
  var STATIC11 = {};
  function vtkOpenGLBufferObject(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLBufferObject");
    function convertType(type) {
      switch (type) {
        case ObjectType2.ELEMENT_ARRAY_BUFFER:
          return model.context.ELEMENT_ARRAY_BUFFER;
        case ObjectType2.TEXTURE_BUFFER:
          if ("TEXTURE_BUFFER" in model.context) {
            return model.context.TEXTURE_BUFFER;
          }
        /* eslint-disable no-fallthrough */
        // Intentional fallthrough in case there is no TEXTURE_BUFFER in WebGL
        case ObjectType2.ARRAY_BUFFER:
        default:
          return model.context.ARRAY_BUFFER;
      }
    }
    let internalType = null;
    let internalHandle = null;
    let dirty = true;
    let error = "";
    publicAPI.getType = () => internalType;
    publicAPI.setType = (value) => {
      internalType = value;
    };
    publicAPI.getHandle = () => internalHandle;
    publicAPI.isReady = () => dirty === false;
    publicAPI.generateBuffer = (type) => {
      const objectTypeGL = convertType(type);
      if (internalHandle === null) {
        internalHandle = model.context.createBuffer();
        internalType = type;
      }
      return convertType(internalType) === objectTypeGL;
    };
    publicAPI.upload = (data, type) => {
      const alreadyGenerated = publicAPI.generateBuffer(type);
      if (!alreadyGenerated) {
        error = "Trying to upload array buffer to incompatible buffer.";
        return false;
      }
      model.context.bindBuffer(convertType(internalType), internalHandle);
      model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
      model.allocatedGPUMemoryInBytes = data.length * data.BYTES_PER_ELEMENT;
      dirty = false;
      return true;
    };
    publicAPI.bind = () => {
      if (!internalHandle) {
        return false;
      }
      model.context.bindBuffer(convertType(internalType), internalHandle);
      return true;
    };
    publicAPI.release = () => {
      if (!internalHandle) {
        return false;
      }
      model.context.bindBuffer(convertType(internalType), null);
      return true;
    };
    publicAPI.releaseGraphicsResources = () => {
      if (internalHandle !== null) {
        model.context.bindBuffer(convertType(internalType), null);
        model.context.deleteBuffer(internalHandle);
        internalHandle = null;
        model.allocatedGPUMemoryInBytes = 0;
      }
    };
    publicAPI.setOpenGLRenderWindow = (rw) => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };
    publicAPI.getError = () => error;
  }
  var DEFAULT_VALUES44 = {
    objectType: ObjectType2.ARRAY_BUFFER,
    // _openGLRenderWindow: null,
    context: null,
    allocatedGPUMemoryInBytes: 0
  };
  function extend46(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES44, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["_openGLRenderWindow", "allocatedGPUMemoryInBytes"]);
    macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
    vtkOpenGLBufferObject(publicAPI, model);
  }
  var newInstance46 = macro.newInstance(extend46);
  var vtkBufferObject = {
    newInstance: newInstance46,
    extend: extend46,
    ...STATIC11,
    ...Constants11
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject/helpers.js
  function computeCoordShiftAndScale(points) {
    let diagSq = 0;
    let distSq = 0;
    for (let i = 0; i < 3; ++i) {
      const range = points.getRange(i);
      const delta = range[1] - range[0];
      diagSq += delta * delta;
      const distShift = 0.5 * (range[1] + range[0]);
      distSq += distShift * distShift;
    }
    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1e6 || // If data is far from the origin relative to its size
    Math.abs(Math.log10(diagSq)) > 3 || // If the size is huge when not far from the origin
    diagSq === 0 && distSq > 1e6);
    if (useShiftAndScale) {
      const coordShift = new Float64Array(3);
      const coordScale = new Float64Array(3);
      for (let i = 0; i < 3; ++i) {
        const range = points.getRange(i);
        const delta = range[1] - range[0];
        coordShift[i] = 0.5 * (range[1] + range[0]);
        coordScale[i] = delta > 0 ? 1 / delta : 1;
      }
      return {
        useShiftAndScale,
        coordShift,
        coordScale
      };
    }
    return {
      useShiftAndScale,
      coordShift: new Float32Array([0, 0, 0]),
      coordScale: new Float32Array([1, 1, 1])
    };
  }

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js
  var {
    vtkErrorMacro: vtkErrorMacro17
  } = macro;
  function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
    const inverseScale = new Float64Array(3);
    vec3_exports.inverse(inverseScale, coordScale);
    const matrix = new Float64Array(16);
    mat4_exports.fromRotationTranslationScale(matrix, quat_exports.create(), coordShift, inverseScale);
    return matrix;
  }
  function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
    if (coordShift === null || coordScale === null) {
      return false;
    }
    return !(vec3_exports.exactEquals(coordShift, [0, 0, 0]) && vec3_exports.exactEquals(coordScale, [1, 1, 1]));
  }
  function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLCellArrayBufferObject");
    publicAPI.setType(ObjectType.ARRAY_BUFFER);
    publicAPI.createVBO = function(cellArray, inRep, outRep, options) {
      let selectionMaps = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      if (!cellArray.getData() || !cellArray.getData().length) {
        model.elementCount = 0;
        return 0;
      }
      model.blockSize = 3;
      model.vertexOffset = 0;
      model.normalOffset = 0;
      model.tCoordOffset = 0;
      model.tCoordComponents = 0;
      model.colorComponents = 0;
      model.colorOffset = 0;
      model.customData = [];
      const pointData = options.points.getData();
      let normalData = null;
      let tcoordData = null;
      let colorData = null;
      const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
      const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;
      if (options.normals) {
        model.normalOffset = 4 * model.blockSize;
        model.blockSize += 3;
        normalData = options.normals.getData();
      }
      if (options.customAttributes) {
        options.customAttributes.forEach((a) => {
          if (a) {
            model.customData.push({
              data: a.getData(),
              offset: 4 * model.blockSize,
              components: a.getNumberOfComponents(),
              name: a.getName()
            });
            model.blockSize += a.getNumberOfComponents();
          }
        });
      }
      if (options.tcoords) {
        model.tCoordOffset = 4 * model.blockSize;
        model.tCoordComponents = textureComponents;
        model.blockSize += textureComponents;
        tcoordData = options.tcoords.getData();
      }
      if (options.colors) {
        model.colorComponents = options.colors.getNumberOfComponents();
        model.colorOffset = 0;
        colorData = options.colors.getData();
        if (!model.colorBO) {
          model.colorBO = vtkBufferObject.newInstance();
        }
        model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
      } else {
        model.colorBO = null;
      }
      model.stride = 4 * model.blockSize;
      let pointIdx = 0;
      let normalIdx = 0;
      let tcoordIdx = 0;
      let colorIdx = 0;
      let custIdx = 0;
      let cellCount = 0;
      let addAPoint;
      const cellBuilders = {
        // easy, every input point becomes an output point
        anythingToPoints(numPoints, cellPts, offset, cellId) {
          for (let i = 0; i < numPoints; ++i) {
            addAPoint(cellPts[offset + i], cellId);
          }
        },
        linesToWireframe(numPoints, cellPts, offset, cellIdx) {
          for (let i = 0; i < numPoints - 1; ++i) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 1], cellIdx);
          }
        },
        polysToWireframe(numPoints, cellPts, offset, cellIdx) {
          if (numPoints > 2) {
            for (let i = 0; i < numPoints; ++i) {
              addAPoint(cellPts[offset + i], cellIdx);
              addAPoint(cellPts[offset + (i + 1) % numPoints], cellIdx);
            }
          }
        },
        stripsToWireframe(numPoints, cellPts, offset, cellIdx) {
          if (numPoints > 2) {
            for (let i = 0; i < numPoints - 1; ++i) {
              addAPoint(cellPts[offset + i], cellIdx);
              addAPoint(cellPts[offset + i + 1], cellIdx);
            }
            for (let i = 0; i < numPoints - 2; i++) {
              addAPoint(cellPts[offset + i], cellIdx);
              addAPoint(cellPts[offset + i + 2], cellIdx);
            }
          }
        },
        polysToSurface(npts, cellPts, offset, cellIdx) {
          for (let i = 0; i < npts - 2; i++) {
            addAPoint(cellPts[offset + 0], cellIdx);
            addAPoint(cellPts[offset + i + 1], cellIdx);
            addAPoint(cellPts[offset + i + 2], cellIdx);
          }
        },
        stripsToSurface(npts, cellPts, offset, cellIdx) {
          for (let i = 0; i < npts - 2; i++) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 1 + i % 2], cellIdx);
            addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellIdx);
          }
        }
      };
      const cellCounters = {
        // easy, every input point becomes an output point
        anythingToPoints(numPoints, cellPts) {
          return numPoints;
        },
        linesToWireframe(numPoints, cellPts) {
          if (numPoints > 1) {
            return (numPoints - 1) * 2;
          }
          return 0;
        },
        polysToWireframe(numPoints, cellPts) {
          if (numPoints > 2) {
            return numPoints * 2;
          }
          return 0;
        },
        stripsToWireframe(numPoints, cellPts) {
          if (numPoints > 2) {
            return numPoints * 4 - 6;
          }
          return 0;
        },
        polysToSurface(npts, cellPts) {
          if (npts > 2) {
            return (npts - 2) * 3;
          }
          return 0;
        },
        stripsToSurface(npts, cellPts, offset) {
          if (npts > 2) {
            return (npts - 2) * 3;
          }
          return 0;
        }
      };
      let func = null;
      let countFunc = null;
      if (outRep === Representation.POINTS || inRep === "verts") {
        func = cellBuilders.anythingToPoints;
        countFunc = cellCounters.anythingToPoints;
      } else if (outRep === Representation.WIREFRAME || inRep === "lines") {
        func = cellBuilders[`${inRep}ToWireframe`];
        countFunc = cellCounters[`${inRep}ToWireframe`];
      } else {
        func = cellBuilders[`${inRep}ToSurface`];
        countFunc = cellCounters[`${inRep}ToSurface`];
      }
      const array = cellArray.getData();
      const size = array.length;
      let caboCount = 0;
      for (let index = 0; index < size; ) {
        caboCount += countFunc(array[index], array);
        index += array[index] + 1;
      }
      let packedUCVBO = null;
      const packedVBO = new Float32Array(caboCount * model.blockSize);
      if (colorData) {
        packedUCVBO = new Uint8Array(caboCount * 4);
      }
      let vboidx = 0;
      let ucidx = 0;
      const {
        useShiftAndScale,
        coordShift,
        coordScale
      } = computeCoordShiftAndScale(options.points);
      if (useShiftAndScale) {
        publicAPI.setCoordShiftAndScale(coordShift, coordScale);
      } else if (model.coordShiftAndScaleEnabled === true) {
        publicAPI.setCoordShiftAndScale(null, null);
      }
      if (selectionMaps) {
        if (!selectionMaps.points && !selectionMaps.cells) {
          selectionMaps.points = new Int32Array(caboCount);
          selectionMaps.cells = new Int32Array(caboCount);
        } else {
          const newPoints = new Int32Array(caboCount + selectionMaps.points.length);
          newPoints.set(selectionMaps.points);
          selectionMaps.points = newPoints;
          const newCells = new Int32Array(caboCount + selectionMaps.cells.length);
          newCells.set(selectionMaps.cells);
          selectionMaps.cells = newCells;
        }
      }
      let pointCount = options.vertexOffset;
      addAPoint = function addAPointFunc(pointId, cellId) {
        if (selectionMaps) {
          selectionMaps.points[pointCount] = pointId;
          selectionMaps.cells[pointCount] = cellCount + options.cellOffset;
        }
        ++pointCount;
        pointIdx = pointId * 3;
        if (!model.coordShiftAndScaleEnabled) {
          packedVBO[vboidx++] = pointData[pointIdx++];
          packedVBO[vboidx++] = pointData[pointIdx++];
          packedVBO[vboidx++] = pointData[pointIdx++];
        } else {
          packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
          packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
          packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
        }
        if (normalData !== null) {
          if (options.haveCellNormals) {
            normalIdx = (cellCount + options.cellOffset) * 3;
          } else {
            normalIdx = pointId * 3;
          }
          packedVBO[vboidx++] = normalData[normalIdx++];
          packedVBO[vboidx++] = normalData[normalIdx++];
          packedVBO[vboidx++] = normalData[normalIdx++];
        }
        model.customData.forEach((attr) => {
          custIdx = pointId * attr.components;
          for (let j = 0; j < attr.components; ++j) {
            packedVBO[vboidx++] = attr.data[custIdx++];
          }
        });
        if (tcoordData !== null) {
          if (options.useTCoordsPerCell) {
            tcoordIdx = cellId * textureComponents;
          } else {
            tcoordIdx = pointId * textureComponents;
          }
          for (let j = 0; j < textureComponents; ++j) {
            packedVBO[vboidx++] = tcoordData[tcoordIdx++];
          }
        }
        if (colorData !== null) {
          if (options.haveCellScalars) {
            colorIdx = (cellCount + options.cellOffset) * colorComponents;
          } else {
            colorIdx = pointId * colorComponents;
          }
          packedUCVBO[ucidx++] = colorData[colorIdx++];
          packedUCVBO[ucidx++] = colorData[colorIdx++];
          packedUCVBO[ucidx++] = colorData[colorIdx++];
          packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
        }
      };
      for (let index = 0; index < size; index += array[index] + 1, cellCount++) {
        func(array[index], array, index + 1, cellCount + options.cellOffset);
      }
      model.elementCount = caboCount;
      publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);
      if (model.colorBO) {
        model.colorBOStride = 4;
        model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
      }
      return cellCount;
    };
    publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {
      if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
        vtkErrorMacro17("Wrong type for coordShift, expected vec3 or null");
        return;
      }
      if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
        vtkErrorMacro17("Wrong type for coordScale, expected vec3 or null");
        return;
      }
      if (model.coordShift === null || coordShift === null || !vec3_exports.equals(coordShift, model.coordShift)) {
        model.coordShift = coordShift;
      }
      if (model.coordScale === null || coordScale === null || !vec3_exports.equals(coordScale, model.coordScale)) {
        model.coordScale = coordScale;
      }
      model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
      if (model.coordShiftAndScaleEnabled) {
        model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
      } else {
        model.inverseShiftAndScaleMatrix = null;
      }
    };
  }
  var DEFAULT_VALUES45 = {
    elementCount: 0,
    stride: 0,
    colorBOStride: 0,
    vertexOffset: 0,
    normalOffset: 0,
    tCoordOffset: 0,
    tCoordComponents: 0,
    colorOffset: 0,
    colorComponents: 0,
    tcoordBO: null,
    customData: [],
    coordShift: null,
    coordScale: null,
    coordShiftAndScaleEnabled: false,
    inverseShiftAndScaleMatrix: null
  };
  function extend47(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES45, initialValues);
    vtkBufferObject.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["colorBO", "elementCount", "stride", "colorBOStride", "vertexOffset", "normalOffset", "tCoordOffset", "tCoordComponents", "colorOffset", "colorComponents", "customData"]);
    macro.get(publicAPI, model, ["coordShift", "coordScale", "coordShiftAndScaleEnabled", "inverseShiftAndScaleMatrix"]);
    vtkOpenGLCellArrayBufferObject(publicAPI, model);
  }
  var newInstance47 = macro.newInstance(extend47);
  var vtkCellArrayBufferObject = {
    newInstance: newInstance47,
    extend: extend47
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Shader.js
  var {
    vtkErrorMacro: vtkErrorMacro18
  } = macro;
  function vtkShader(publicAPI, model) {
    model.classHierarchy.push("vtkShader");
    publicAPI.compile = () => {
      let stype = model.context.VERTEX_SHADER;
      if (!model.source || !model.source.length || model.shaderType === "Unknown") {
        return false;
      }
      if (model.handle !== 0) {
        model.context.deleteShader(model.handle);
        model.handle = 0;
      }
      switch (model.shaderType) {
        // case vtkShader::Geometry:
        //   type = GL_GEOMETRY_SHADER;
        //   break;
        case "Fragment":
          stype = model.context.FRAGMENT_SHADER;
          break;
        case "Vertex":
        default:
          stype = model.context.VERTEX_SHADER;
          break;
      }
      model.handle = model.context.createShader(stype);
      model.context.shaderSource(model.handle, model.source);
      model.context.compileShader(model.handle);
      const isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
      if (!isCompiled) {
        const lastError = model.context.getShaderInfoLog(model.handle);
        vtkErrorMacro18(`Error compiling shader '${model.source}': ${lastError}`);
        model.context.deleteShader(model.handle);
        model.handle = 0;
        return false;
      }
      return true;
    };
    publicAPI.cleanup = () => {
      if (model.shaderType === "Unknown" || model.handle === 0) {
        return;
      }
      model.context.deleteShader(model.handle);
      model.handle = 0;
      model.dirty = true;
    };
  }
  var DEFAULT_VALUES46 = {
    shaderType: "Unknown",
    source: "",
    error: "",
    handle: 0,
    dirty: false,
    context: null
  };
  function extend48(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES46, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["shaderType", "source", "error", "handle", "context"]);
    vtkShader(publicAPI, model);
  }
  var newInstance48 = macro.newInstance(extend48, "vtkShader");
  var vtkShader$1 = {
    newInstance: newInstance48,
    extend: extend48
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js
  var {
    vtkErrorMacro: vtkErrorMacro19
  } = macro;
  function substitute(source, search, replace, all) {
    const replaceStr = typeof replace === "string" ? replace : replace.join("\n");
    const replaceSearch = all === false ? search : new RegExp(search, "g");
    const resultstr = source.replace(replaceSearch, replaceStr);
    return {
      // If the result is different than the input, we did perform a replacement
      replace: resultstr !== replaceStr,
      result: resultstr
    };
  }
  function vtkShaderProgram(publicAPI, model) {
    model.classHierarchy.push("vtkShaderProgram");
    publicAPI.compileShader = () => {
      if (!model.vertexShader.compile()) {
        vtkErrorMacro19(model.vertexShader.getSource().split("\n").map((line, index) => `${index}: ${line}`).join("\n"));
        vtkErrorMacro19(model.vertexShader.getError());
        return 0;
      }
      if (!model.fragmentShader.compile()) {
        vtkErrorMacro19(model.fragmentShader.getSource().split("\n").map((line, index) => `${index}: ${line}`).join("\n"));
        vtkErrorMacro19(model.fragmentShader.getError());
        return 0;
      }
      if (!publicAPI.attachShader(model.vertexShader)) {
        vtkErrorMacro19(model.error);
        return 0;
      }
      if (!publicAPI.attachShader(model.fragmentShader)) {
        vtkErrorMacro19(model.error);
        return 0;
      }
      if (!publicAPI.link()) {
        vtkErrorMacro19(`Links failed: ${model.error}`);
        return 0;
      }
      publicAPI.setCompiled(true);
      return 1;
    };
    publicAPI.cleanup = () => {
      if (model.shaderType === "Unknown" || model.handle === 0) {
        return;
      }
      publicAPI.release();
      if (model.vertexShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.vertexShaderHandle);
        model.vertexShaderHandle = 0;
      }
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
        model.fragmentShaderHandle = 0;
      }
      model.context.deleteProgram(model.handle);
      model.handle = 0;
      publicAPI.setCompiled(false);
    };
    publicAPI.bind = () => {
      if (!model.linked && !publicAPI.link()) {
        return false;
      }
      model.context.useProgram(model.handle);
      publicAPI.setBound(true);
      return true;
    };
    publicAPI.isBound = () => !!model.bound;
    publicAPI.release = () => {
      model.context.useProgram(null);
      publicAPI.setBound(false);
    };
    publicAPI.setContext = (ctx) => {
      model.vertexShader.setContext(ctx);
      model.fragmentShader.setContext(ctx);
      model.geometryShader.setContext(ctx);
    };
    publicAPI.link = () => {
      if (model.linked) {
        return true;
      }
      if (model.handle === 0) {
        model.error = "Program has not been initialized, and/or does not have shaders.";
        return false;
      }
      model.uniformLocs = {};
      model.context.linkProgram(model.handle);
      const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
      if (!isCompiled) {
        const lastError = model.context.getProgramInfoLog(model.handle);
        vtkErrorMacro19(`Error linking shader ${lastError}`);
        model.handle = 0;
        return false;
      }
      publicAPI.setLinked(true);
      model.attributeLocs = {};
      return true;
    };
    publicAPI.setUniformMatrix = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      const f32 = new Float32Array(v);
      model.context.uniformMatrix4fv(location, false, f32);
      return true;
    };
    publicAPI.setUniformMatrix3x3 = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      const f32 = new Float32Array(v);
      model.context.uniformMatrix3fv(location, false, f32);
      return true;
    };
    publicAPI.setUniformf = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform1f(location, v);
      return true;
    };
    publicAPI.setUniformfv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform1fv(location, v);
      return true;
    };
    publicAPI.setUniformi = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform1i(location, v);
      return true;
    };
    publicAPI.setUniformiv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform1iv(location, v);
      return true;
    };
    publicAPI.setUniform2f = (name, v1, v2) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      if (v2 === void 0) {
        throw new RangeError("Invalid number of values for array");
      }
      model.context.uniform2f(location, v1, v2);
      return true;
    };
    publicAPI.setUniform2fv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform2fv(location, v);
      return true;
    };
    publicAPI.setUniform2i = (name, v1, v2) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      if (v2 === void 0) {
        throw new RangeError("Invalid number of values for array");
      }
      model.context.uniform2i(location, v1, v2);
      return true;
    };
    publicAPI.setUniform2iv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform2iv(location, v);
      return true;
    };
    publicAPI.setUniform3f = (name, a1, a2, a3) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      if (a3 === void 0) {
        throw new RangeError("Invalid number of values for array");
      }
      model.context.uniform3f(location, a1, a2, a3);
      return true;
    };
    publicAPI.setUniform3fArray = (name, a) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      if (!Array.isArray(a) || a.length !== 3) {
        throw new RangeError("Invalid number of values for array");
      }
      model.context.uniform3f(location, a[0], a[1], a[2]);
      return true;
    };
    publicAPI.setUniform3fv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform3fv(location, v);
      return true;
    };
    publicAPI.setUniform3i = function(name) {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      let array = args;
      if (array.length === 1 && Array.isArray(array[0])) {
        array = array[0];
      }
      if (array.length !== 3) {
        throw new RangeError("Invalid number of values for array");
      }
      model.context.uniform3i(location, array[0], array[1], array[2]);
      return true;
    };
    publicAPI.setUniform3iv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform3iv(location, v);
      return true;
    };
    publicAPI.setUniform4f = function(name) {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      let array = args;
      if (array.length === 1 && Array.isArray(array[0])) {
        array = array[0];
      }
      if (array.length !== 4) {
        throw new RangeError("Invalid number of values for array");
      }
      model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
      return true;
    };
    publicAPI.setUniform4fv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform4fv(location, v);
      return true;
    };
    publicAPI.setUniform4i = function(name) {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      let array = args;
      if (array.length === 1 && Array.isArray(array[0])) {
        array = array[0];
      }
      if (array.length !== 4) {
        throw new RangeError("Invalid number of values for array");
      }
      model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
      return true;
    };
    publicAPI.setUniform4iv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform4iv(location, v);
      return true;
    };
    publicAPI.findUniform = (name) => {
      if (!name || !model.linked) {
        return -1;
      }
      let loc = model.uniformLocs[name];
      if (loc !== void 0) {
        return loc;
      }
      loc = model.context.getUniformLocation(model.handle, name);
      if (loc === null) {
        model.error = `Uniform ${name} not found in current shader program.`;
        model.uniformLocs[name] = -1;
        return -1;
      }
      model.uniformLocs[name] = loc;
      return loc;
    };
    publicAPI.isUniformUsed = (name) => {
      if (!name) {
        return false;
      }
      let loc = model.uniformLocs[name];
      if (loc !== void 0) {
        return loc !== null;
      }
      if (!model.linked) {
        vtkErrorMacro19("attempt to find uniform when the shader program is not linked");
        return false;
      }
      loc = model.context.getUniformLocation(model.handle, name);
      model.uniformLocs[name] = loc;
      if (loc === null) {
        return false;
      }
      return true;
    };
    publicAPI.isAttributeUsed = (name) => {
      if (!name) {
        return false;
      }
      if (name in model.attributeLocs) {
        return true;
      }
      if (!model.linked) {
        vtkErrorMacro19("attempt to find uniform when the shader program is not linked");
        return false;
      }
      const loc = model.context.getAttribLocation(model.handle, name);
      if (loc === -1) {
        return false;
      }
      model.attributeLocs[name] = loc;
      return true;
    };
    publicAPI.attachShader = (shader) => {
      if (shader.getHandle() === 0) {
        model.error = "Shader object was not initialized, cannot attach it.";
        return false;
      }
      if (shader.getShaderType() === "Unknown") {
        model.error = "Shader object is of type Unknown and cannot be used.";
        return false;
      }
      if (model.handle === 0) {
        const thandle = model.context.createProgram();
        if (thandle === 0) {
          model.error = "Could not create shader program.";
          return false;
        }
        model.handle = thandle;
        model.linked = false;
      }
      if (shader.getShaderType() === "Vertex") {
        if (model.vertexShaderHandle !== 0) {
          model.context.detachShader(model.handle, model.vertexShaderHandle);
        }
        model.vertexShaderHandle = shader.getHandle();
      }
      if (shader.getShaderType() === "Fragment") {
        if (model.fragmentShaderHandle !== 0) {
          model.context.detachShader(model.handle, model.fragmentShaderHandle);
        }
        model.fragmentShaderHandle = shader.getHandle();
      }
      model.context.attachShader(model.handle, shader.getHandle());
      publicAPI.setLinked(false);
      return true;
    };
    publicAPI.detachShader = (shader) => {
      if (shader.getHandle() === 0) {
        model.error = "shader object was not initialized, cannot attach it.";
        return false;
      }
      if (shader.getShaderType() === "Unknown") {
        model.error = "Shader object is of type Unknown and cannot be used.";
        return false;
      }
      if (model.handle === 0) {
        model.error = "This shader program has not been initialized yet.";
      }
      switch (shader.getShaderType()) {
        case "Vertex":
          if (model.vertexShaderHandle !== shader.getHandle()) {
            model.error = "The supplied shader was not attached to this program.";
            return false;
          }
          model.context.detachShader(model.handle, shader.getHandle());
          model.vertexShaderHandle = 0;
          model.linked = false;
          return true;
        case "Fragment":
          if (model.fragmentShaderHandle !== shader.getHandle()) {
            model.error = "The supplied shader was not attached to this program.";
            return false;
          }
          model.context.detachShader(model.handle, shader.getHandle());
          model.fragmentShaderHandle = 0;
          model.linked = false;
          return true;
        default:
          return false;
      }
    };
    publicAPI.setContext = (ctx) => {
      model.context = ctx;
      model.vertexShader.setContext(ctx);
      model.fragmentShader.setContext(ctx);
      model.geometryShader.setContext(ctx);
    };
    publicAPI.setLastCameraMTime = (mtime) => {
      model.lastCameraMTime = mtime;
    };
  }
  var DEFAULT_VALUES47 = {
    vertexShaderHandle: 0,
    fragmentShaderHandle: 0,
    geometryShaderHandle: 0,
    vertexShader: null,
    fragmentShader: null,
    geometryShader: null,
    linked: false,
    bound: false,
    compiled: false,
    error: "",
    handle: 0,
    numberOfOutputs: 0,
    attributesLocs: null,
    uniformLocs: null,
    md5Hash: 0,
    context: null,
    lastCameraMTime: null
  };
  function extend49(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES47, initialValues);
    model.attributesLocs = {};
    model.uniformLocs = {};
    model.vertexShader = vtkShader$1.newInstance();
    model.vertexShader.setShaderType("Vertex");
    model.fragmentShader = vtkShader$1.newInstance();
    model.fragmentShader.setShaderType("Fragment");
    model.geometryShader = vtkShader$1.newInstance();
    model.geometryShader.setShaderType("Geometry");
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["lastCameraMTime"]);
    macro.setGet(publicAPI, model, ["error", "handle", "compiled", "bound", "md5Hash", "vertexShader", "fragmentShader", "geometryShader", "linked"]);
    vtkShaderProgram(publicAPI, model);
  }
  var newInstance49 = macro.newInstance(extend49, "vtkShaderProgram");
  var vtkShaderProgram$1 = {
    newInstance: newInstance49,
    extend: extend49,
    substitute
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
  function vtkOpenGLVertexArrayObject(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLVertexArrayObject");
    publicAPI.exposedMethod = () => {
    };
    publicAPI.initialize = () => {
      model.instancingExtension = null;
      if (!model._openGLRenderWindow.getWebgl2()) {
        model.instancingExtension = model.context.getExtension("ANGLE_instanced_arrays");
      }
      if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
        model.extension = null;
        model.supported = true;
        model.handleVAO = model.context.createVertexArray();
      } else {
        model.extension = model.context.getExtension("OES_vertex_array_object");
        if (!model.forceEmulation && model.extension) {
          model.supported = true;
          model.handleVAO = model.extension.createVertexArrayOES();
        } else {
          model.supported = false;
        }
      }
    };
    publicAPI.isReady = () => (
      // We either probed and allocated a VAO, or are falling back as the current
      // hardware does not support VAOs.
      model.handleVAO !== 0 || model.supported === false
    );
    publicAPI.bind = () => {
      if (!publicAPI.isReady()) {
        publicAPI.initialize();
      }
      if (publicAPI.isReady() && model.supported) {
        if (model.extension) {
          model.extension.bindVertexArrayOES(model.handleVAO);
        } else {
          model.context.bindVertexArray(model.handleVAO);
        }
      } else if (publicAPI.isReady()) {
        const gl = model.context;
        for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
          const buff = model.buffers[ibuff];
          model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
            for (let i = 0; i < matrixCount; ++i) {
              gl.enableVertexAttribArray(attrIt.index + i);
              gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
              if (attrIt.divisor > 0) {
                if (model.instancingExtension) {
                  model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);
                } else {
                  gl.vertexAttribDivisor(attrIt.index + i, 1);
                }
              }
            }
          }
        }
      }
    };
    publicAPI.release = () => {
      if (publicAPI.isReady() && model.supported) {
        if (model.extension) {
          model.extension.bindVertexArrayOES(null);
        } else {
          model.context.bindVertexArray(null);
        }
      } else if (publicAPI.isReady()) {
        const gl = model.context;
        for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
          const buff = model.buffers[ibuff];
          model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
            for (let i = 0; i < matrixCount; ++i) {
              gl.enableVertexAttribArray(attrIt.index + i);
              gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
              if (attrIt.divisor > 0) {
                if (model.instancingExtension) {
                  model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);
                } else {
                  gl.vertexAttribDivisor(attrIt.index + i, 0);
                }
              }
              gl.disableVertexAttribArray(attrIt.index + i);
            }
          }
        }
      }
    };
    publicAPI.shaderProgramChanged = () => {
      publicAPI.release();
      if (model.handleVAO) {
        if (model.extension) {
          model.extension.deleteVertexArrayOES(model.handleVAO);
        } else {
          model.context.deleteVertexArray(model.handleVAO);
        }
      }
      model.handleVAO = 0;
      model.handleProgram = 0;
    };
    publicAPI.releaseGraphicsResources = () => {
      publicAPI.shaderProgramChanged();
      if (model.handleVAO) {
        if (model.extension) {
          model.extension.deleteVertexArrayOES(model.handleVAO);
        } else {
          model.context.deleteVertexArray(model.handleVAO);
        }
      }
      model.handleVAO = 0;
      model.supported = true;
      model.handleProgram = 0;
    };
    publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, 0, false);
    publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, divisor, isMatrix) => {
      if (!program) {
        return false;
      }
      if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {
        return false;
      }
      if (model.handleProgram === 0) {
        model.handleProgram = program.getHandle();
      }
      if (!publicAPI.isReady()) {
        publicAPI.initialize();
      }
      if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
        return false;
      }
      const gl = model.context;
      const attribs = {};
      attribs.name = name;
      attribs.index = gl.getAttribLocation(model.handleProgram, name);
      attribs.offset = offset;
      attribs.stride = stride;
      attribs.type = elementType;
      attribs.size = elementTupleSize;
      attribs.normalize = normalize6;
      attribs.isMatrix = isMatrix;
      attribs.divisor = divisor;
      if (attribs.Index === -1) {
        return false;
      }
      buffer.bind();
      gl.enableVertexAttribArray(attribs.index);
      gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
        } else {
          gl.vertexAttribDivisor(attribs.index, 1);
        }
      }
      attribs.buffer = buffer.getHandle();
      if (!model.supported) {
        let buffFound = false;
        for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
          const buff = model.buffers[ibuff];
          if (buff.buffer === attribs.buffer) {
            buffFound = true;
            let found = false;
            for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
              const attrIt = buff.attributes[iatt];
              if (attrIt.name === name) {
                found = true;
                buff.attributes[iatt] = attribs;
              }
            }
            if (!found) {
              buff.attributes.push(attribs);
            }
          }
        }
        if (!buffFound) {
          model.buffers.push({
            buffer: attribs.buffer,
            attributes: [attribs]
          });
        }
      }
      return true;
    };
    publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, divisor) => {
      const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, divisor, true);
      if (!result) {
        return result;
      }
      const gl = model.context;
      const index = gl.getAttribLocation(model.handleProgram, name);
      for (let i = 1; i < elementTupleSize; i++) {
        gl.enableVertexAttribArray(index + i);
        gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize6, stride, offset + stride * i / elementTupleSize);
        if (divisor > 0) {
          if (model.instancingExtension) {
            model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);
          } else {
            gl.vertexAttribDivisor(index + i, 1);
          }
        }
      }
      return true;
    };
    publicAPI.removeAttributeArray = (name) => {
      if (!publicAPI.isReady() || model.handleProgram === 0) {
        return false;
      }
      if (!model.supported) {
        for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
          const buff = model.buffers[ibuff];
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              buff.attributes.splice(iatt, 1);
              if (!buff.attributes.length) {
                model.buffers.splice(ibuff, 1);
              }
              return true;
            }
          }
        }
      }
      return true;
    };
    publicAPI.setOpenGLRenderWindow = (rw) => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };
  }
  var DEFAULT_VALUES48 = {
    forceEmulation: false,
    handleVAO: 0,
    handleProgram: 0,
    supported: true,
    buffers: null,
    context: null
    // _openGLRenderWindow: null,
  };
  function extend50(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES48, initialValues);
    model.buffers = [];
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["supported"]);
    macro.setGet(publicAPI, model, ["forceEmulation"]);
    vtkOpenGLVertexArrayObject(publicAPI, model);
  }
  var newInstance50 = macro.newInstance(extend50, "vtkOpenGLVertexArrayObject");
  var vtkVertexArrayObject = {
    newInstance: newInstance50,
    extend: extend50
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js
  var primTypes = {
    Start: 0,
    Points: 0,
    Lines: 1,
    Tris: 2,
    TriStrips: 3,
    TrisEdges: 4,
    TriStripsEdges: 5,
    End: 6
  };
  function vtkOpenGLHelper(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLHelper");
    publicAPI.setOpenGLRenderWindow = (win) => {
      model.context = win.getContext();
      model.program.setContext(model.context);
      model.VAO.setOpenGLRenderWindow(win);
      model.CABO.setOpenGLRenderWindow(win);
    };
    publicAPI.releaseGraphicsResources = (oglwin) => {
      model.VAO.releaseGraphicsResources();
      model.CABO.releaseGraphicsResources();
      model.CABO.setElementCount(0);
    };
    publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {
      if (model.CABO.getElementCount()) {
        const mode = publicAPI.getOpenGLMode(rep);
        const wideLines = publicAPI.haveWideLines(ren, actor);
        const gl = model.context;
        const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
        if (model.pointPicking) {
          gl.depthMask(false);
        }
        const drawingLines = mode === gl.LINES;
        if (drawingLines && wideLines) {
          publicAPI.updateShaders(ren, actor, oglMapper);
          gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));
        } else {
          gl.lineWidth(actor.getProperty().getLineWidth());
          publicAPI.updateShaders(ren, actor, oglMapper);
          gl.drawArrays(mode, 0, model.CABO.getElementCount());
          gl.lineWidth(1);
        }
        const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
        if (model.pointPicking) {
          gl.depthMask(depthMask);
        }
        return model.CABO.getElementCount() / stride;
      }
      return 0;
    };
    publicAPI.getOpenGLMode = (rep) => {
      if (model.pointPicking) {
        return model.context.POINTS;
      }
      const type = model.primitiveType;
      if (rep === Representation.POINTS || type === primTypes.Points) {
        return model.context.POINTS;
      }
      if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {
        return model.context.LINES;
      }
      return model.context.TRIANGLES;
    };
    publicAPI.haveWideLines = (ren, actor) => {
      if (actor.getProperty().getLineWidth() > 1) {
        if (model.CABO.getOpenGLRenderWindow()) {
          if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {
      if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {
        return true;
      }
      return false;
    };
    publicAPI.updateShaders = (ren, actor, oglMapper) => {
      if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {
        const shaders = {
          Vertex: null,
          Fragment: null,
          Geometry: null
        };
        oglMapper.buildShaders(shaders, ren, actor);
        const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
        if (newShader !== publicAPI.getProgram()) {
          publicAPI.setProgram(newShader);
          publicAPI.getVAO().releaseGraphicsResources();
        }
        publicAPI.getShaderSourceTime().modified();
      } else {
        model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());
      }
      publicAPI.getVAO().bind();
      oglMapper.setMapperShaderParameters(publicAPI, ren, actor);
      oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);
      oglMapper.setCameraShaderParameters(publicAPI, ren, actor);
      oglMapper.setLightingShaderParameters(publicAPI, ren, actor);
      oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);
    };
    publicAPI.setMapperShaderParameters = (ren, actor, size) => {
      if (publicAPI.haveWideLines(ren, actor)) {
        publicAPI.getProgram().setUniform2f("viewportSize", size.usize, size.vsize);
        const lineWidth = parseFloat(actor.getProperty().getLineWidth());
        const halfLineWidth = lineWidth / 2;
        publicAPI.getProgram().setUniformf("lineWidthStepSize", lineWidth / Math.ceil(lineWidth));
        publicAPI.getProgram().setUniformf("halfLineWidth", halfLineWidth);
      }
      if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {
        publicAPI.getProgram().setUniformf("pointSize", actor.getProperty().getPointSize());
      } else if (model.pointPicking) {
        publicAPI.getProgram().setUniformf("pointSize", publicAPI.getPointPickingPrimitiveSize());
      }
    };
    publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
      let VSSource = shaders.Vertex;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform float pointSize;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", "  gl_PointSize = pointSize;"], false).result;
      if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform vec2 viewportSize;", "uniform float lineWidthStepSize;", "uniform float halfLineWidth;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", " if (halfLineWidth > 0.0)", "   {", "   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;", "   vec4 tmpPos = gl_Position;", "   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;", "   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];", "   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];", "   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);", "   }"]).result;
      }
      shaders.Vertex = VSSource;
    };
    publicAPI.getPointPickingPrimitiveSize = () => {
      if (model.primitiveType === primTypes.Points) {
        return 2;
      }
      if (model.primitiveType === primTypes.Lines) {
        return 4;
      }
      return 6;
    };
    publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();
  }
  var DEFAULT_VALUES49 = {
    context: null,
    program: null,
    shaderSourceTime: null,
    VAO: null,
    attributeUpdateTime: null,
    CABO: null,
    primitiveType: 0,
    pointPicking: false
  };
  function extend51(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES49, initialValues);
    macro.obj(publicAPI, model);
    model.shaderSourceTime = {};
    macro.obj(model.shaderSourceTime);
    model.attributeUpdateTime = {};
    macro.obj(model.attributeUpdateTime);
    macro.setGet(publicAPI, model, ["program", "shaderSourceTime", "VAO", "attributeUpdateTime", "CABO", "primitiveType", "pointPicking"]);
    model.program = vtkShaderProgram$1.newInstance();
    model.VAO = vtkVertexArrayObject.newInstance();
    model.CABO = vtkCellArrayBufferObject.newInstance();
    vtkOpenGLHelper(publicAPI, model);
  }
  var newInstance51 = macro.newInstance(extend51);
  var vtkHelper = {
    newInstance: newInstance51,
    extend: extend51,
    primTypes
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/OrderIndependentTranslucentPass.js
  var {
    Representation: Representation3
  } = vtkProperty$1;
  var {
    vtkErrorMacro: vtkErrorMacro20
  } = macro;
  function translucentShaderReplacement(shaders) {
    const substituteRes = vtkShaderProgram$1.substitute(shaders.Fragment, "//VTK::RenderPassFragmentShader::Impl", `
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `, false);
    shaders.Fragment = substituteRes.result;
  }
  var oitpFragTemplate = `//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;
  function vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass");
    publicAPI.createVertexBuffer = () => {
      const ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);
      const tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
      const cellArray = new Uint16Array([4, 0, 1, 3, 2]);
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName("tcoords");
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation3.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
    };
    publicAPI.createFramebuffer = (viewNode) => {
      const size = viewNode.getSize();
      const gl = viewNode.getContext();
      model.framebuffer = vtkOpenGLFramebuffer.newInstance();
      model.framebuffer.setOpenGLRenderWindow(viewNode);
      model.framebuffer.create(...size);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.bind();
      model.translucentRGBATexture = vtkOpenGLTexture$1.newInstance();
      model.translucentRGBATexture.setInternalFormat(gl.RGBA16F);
      model.translucentRGBATexture.setFormat(gl.RGBA);
      model.translucentRGBATexture.setOpenGLDataType(gl.HALF_FLOAT);
      model.translucentRGBATexture.setOpenGLRenderWindow(viewNode);
      model.translucentRGBATexture.create2DFromRaw({
        width: size[0],
        height: size[1],
        numComps: 4,
        dataType: "Float32Array",
        data: null
      });
      model.translucentRTexture = vtkOpenGLTexture$1.newInstance();
      model.translucentRTexture.setInternalFormat(gl.R16F);
      model.translucentRTexture.setFormat(gl.RED);
      model.translucentRTexture.setOpenGLDataType(gl.HALF_FLOAT);
      model.translucentRTexture.setOpenGLRenderWindow(viewNode);
      model.translucentRTexture.create2DFromRaw({
        width: size[0],
        height: size[1],
        numComps: 1,
        dataType: "Float32Array",
        data: null
      });
      model.translucentZTexture = vtkOpenGLTexture$1.newInstance();
      model.translucentZTexture.setOpenGLRenderWindow(viewNode);
      model.translucentZTexture.createDepthFromRaw({
        width: size[0],
        height: size[1],
        dataType: "Float32Array",
        data: null
      });
      model.framebuffer.setColorBuffer(model.translucentRGBATexture, 0);
      model.framebuffer.setColorBuffer(model.translucentRTexture, 1);
      model.framebuffer.setDepthBuffer(model.translucentZTexture);
    };
    publicAPI.createCopyShader = (viewNode) => {
      model.copyShader = viewNode.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "attribute vec2 tcoordTC;", "varying vec2 tcoord;", "void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"), oitpFragTemplate, "");
    };
    publicAPI.createVBO = (viewNode) => {
      const gl = viewNode.getContext();
      model.tris.setOpenGLRenderWindow(viewNode);
      publicAPI.createVertexBuffer();
      const program = model.copyShader;
      model.tris.getCABO().bind();
      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
        vtkErrorMacro20("Error setting vertexDC in copy shader VAO.");
      }
      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "tcoordTC", model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
        vtkErrorMacro20("Error setting vertexDC in copy shader VAO.");
      }
    };
    publicAPI.traverse = (viewNode, renNode, forwardPass) => {
      if (model.deleted) {
        return;
      }
      const size = viewNode.getSize();
      const gl = viewNode.getContext();
      model._supported = false;
      if (renNode.getSelector() || !gl || !viewNode.getWebgl2() || !gl.getExtension("EXT_color_buffer_half_float") && !gl.getExtension("EXT_color_buffer_float")) {
        publicAPI.setCurrentOperation("translucentPass");
        renNode.traverse(publicAPI);
        return;
      }
      model._supported = true;
      if (model.framebuffer === null) {
        publicAPI.createFramebuffer(viewNode);
      } else {
        const fbSize = model.framebuffer.getSize();
        if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.releaseGraphicsResources();
          model.translucentRGBATexture.releaseGraphicsResources(viewNode);
          model.translucentRTexture.releaseGraphicsResources(viewNode);
          model.translucentZTexture.releaseGraphicsResources(viewNode);
          publicAPI.createFramebuffer(viewNode);
        } else {
          model.framebuffer.saveCurrentBindingsAndBuffers();
          model.framebuffer.bind();
        }
      }
      gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
      gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 0]);
      gl.clearBufferfv(gl.DEPTH, 0, [1]);
      gl.colorMask(false, false, false, false);
      if (forwardPass.getOpaqueActorCount() > 0) {
        forwardPass.setCurrentOperation("opaqueZBufferPass");
        renNode.traverse(forwardPass);
      }
      gl.colorMask(true, true, true, true);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
      gl.viewport(0, 0, size[0], size[1]);
      gl.scissor(0, 0, size[0], size[1]);
      gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 1]);
      gl.clearBufferfv(gl.COLOR, 1, [0, 0, 0, 0]);
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
      publicAPI.setCurrentOperation("translucentPass");
      renNode.traverse(publicAPI);
      gl.drawBuffers([gl.NONE]);
      model.framebuffer.restorePreviousBindingsAndBuffers();
      if (model.copyShader === null) {
        publicAPI.createCopyShader(viewNode);
      } else {
        viewNode.getShaderCache().readyShaderProgram(model.copyShader);
      }
      if (!model.copyVAO) {
        model.copyVAO = vtkVertexArrayObject.newInstance();
        model.copyVAO.setOpenGLRenderWindow(viewNode);
      }
      model.copyVAO.bind();
      if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
        publicAPI.createVBO(viewNode);
      }
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.depthMask(false);
      gl.depthFunc(gl.ALWAYS);
      gl.viewport(0, 0, size[0], size[1]);
      gl.scissor(0, 0, size[0], size[1]);
      model.translucentRGBATexture.activate();
      model.copyShader.setUniformi("translucentRGBATexture", model.translucentRGBATexture.getTextureUnit());
      model.translucentRTexture.activate();
      model.copyShader.setUniformi("translucentRTexture", model.translucentRTexture.getTextureUnit());
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      gl.depthMask(true);
      gl.depthFunc(gl.LEQUAL);
      model.translucentRGBATexture.deactivate();
      model.translucentRTexture.deactivate();
      const ts = renNode.getTiledSizeAndOrigin();
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    };
    publicAPI.getShaderReplacement = () => {
      if (model._supported) {
        return translucentShaderReplacement;
      }
      return null;
    };
    publicAPI.releaseGraphicsResources = (viewNode) => {
      if (model.framebuffer) {
        model.framebuffer.releaseGraphicsResources(viewNode);
        model.framebuffer = null;
      }
      if (model.translucentRGBATexture) {
        model.translucentRGBATexture.releaseGraphicsResources(viewNode);
        model.translucentRGBATexture = null;
      }
      if (model.translucentRTexture) {
        model.translucentRTexture.releaseGraphicsResources(viewNode);
        model.translucentRTexture = null;
      }
      if (model.translucentZTexture) {
        model.translucentZTexture.releaseGraphicsResources(viewNode);
        model.translucentZTexture = null;
      }
      if (model.copyVAO) {
        model.copyVAO.releaseGraphicsResources(viewNode);
        model.copyVAO = null;
      }
      if (model.copyShader) {
        model.copyShader.releaseGraphicsResources(viewNode);
        model.copyShader = null;
      }
      if (model.tris) {
        model.tris.releaseGraphicsResources(viewNode);
        model.tris = null;
      }
      publicAPI.modified();
    };
  }
  var DEFAULT_VALUES50 = {
    framebuffer: null,
    copyShader: null,
    tris: null
  };
  function extend52(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES50, initialValues);
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    model.VBOBuildTime = {};
    macro.obj(model.VBOBuildTime, {
      mtime: 0
    });
    model.tris = vtkHelper.newInstance();
    macro.get(publicAPI, model, ["framebuffer"]);
    vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model);
  }
  var newInstance52 = macro.newInstance(extend52, "vtkOpenGLOrderIndependentTranslucentPass");
  var vtkOpenGLOrderIndependentTranslucentPass$1 = {
    newInstance: newInstance52,
    extend: extend52
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js
  function vtkForwardPass(publicAPI, model) {
    model.classHierarchy.push("vtkForwardPass");
    publicAPI.traverse = function(viewNode) {
      let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (model.deleted) {
        return;
      }
      model._currentParent = parent;
      publicAPI.setCurrentOperation("buildPass");
      viewNode.traverse(publicAPI);
      const numlayers = viewNode.getRenderable().getNumberOfLayers();
      const renderers = viewNode.getRenderable().getRenderersByReference();
      for (let i = 0; i < numlayers; i++) {
        for (let index = 0; index < renderers.length; index++) {
          const ren = renderers[index];
          const renNode = viewNode.getViewNodeFor(ren);
          if (ren.getDraw() && ren.getLayer() === i) {
            model.opaqueActorCount = 0;
            model.translucentActorCount = 0;
            model.volumeCount = 0;
            model.overlayActorCount = 0;
            publicAPI.setCurrentOperation("queryPass");
            renNode.traverse(publicAPI);
            if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {
              const size = viewNode.getFramebufferSize();
              if (model.framebuffer === null) {
                model.framebuffer = vtkOpenGLFramebuffer.newInstance();
              }
              model.framebuffer.setOpenGLRenderWindow(viewNode);
              model.framebuffer.saveCurrentBindingsAndBuffers();
              const fbSize = model.framebuffer.getSize();
              if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
                model.framebuffer.create(size[0], size[1]);
                model.framebuffer.populateFramebuffer();
              }
              model.framebuffer.bind();
              publicAPI.setCurrentOperation("zBufferPass");
              renNode.traverse(publicAPI);
              model.framebuffer.restorePreviousBindingsAndBuffers();
              model.depthRequested = false;
            }
            publicAPI.setCurrentOperation("cameraPass");
            renNode.traverse(publicAPI);
            if (model.opaqueActorCount > 0) {
              publicAPI.setCurrentOperation("opaquePass");
              renNode.traverse(publicAPI);
            }
            if (model.translucentActorCount > 0) {
              if (!model.translucentPass) {
                model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass$1.newInstance();
              }
              model.translucentPass.traverse(viewNode, renNode, publicAPI);
            }
            if (model.volumeCount > 0) {
              publicAPI.setCurrentOperation("volumePass");
              renNode.traverse(publicAPI);
            }
            if (model.overlayActorCount > 0) {
              publicAPI.setCurrentOperation("overlayPass");
              renNode.traverse(publicAPI);
            }
          }
        }
      }
    };
    publicAPI.getZBufferTexture = () => {
      if (model.framebuffer) {
        return model.framebuffer.getColorTexture();
      }
      return null;
    };
    publicAPI.requestDepth = () => {
      model.depthRequested = true;
    };
    publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
    publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
    publicAPI.incrementVolumeCount = () => model.volumeCount++;
    publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;
  }
  var DEFAULT_VALUES51 = {
    opaqueActorCount: 0,
    translucentActorCount: 0,
    volumeCount: 0,
    overlayActorCount: 0,
    framebuffer: null,
    depthRequested: false
  };
  function extend53(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES51, initialValues);
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ["framebuffer", "opaqueActorCount", "translucentActorCount", "volumeCount"]);
    vtkForwardPass(publicAPI, model);
  }
  var newInstance53 = macro.newInstance(extend53, "vtkForwardPass");
  var vtkForwardPass$1 = {
    newInstance: newInstance53,
    extend: extend53
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/HardwareSelector.js
  var {
    FieldAssociations: FieldAssociations3
  } = vtkDataSet$1;
  function vtkHardwareSelector(publicAPI, model) {
    model.classHierarchy.push("vtkHardwareSelector");
    publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {
    };
    publicAPI.selectAsync = async (renderer, fx1, fy1, fx2, fy2) => {
      const srcData = await publicAPI.getSourceDataAsync(renderer, fx1, fy1, fx2, fy2);
      if (srcData) {
        return srcData.generateSelection(fx1, fy1, fx2, fy2);
      }
      return [];
    };
  }
  var DEFAULT_VALUES52 = {
    fieldAssociation: FieldAssociations3.FIELD_ASSOCIATION_CELLS,
    captureZValues: false
  };
  function extend54(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES52, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["fieldAssociation", "captureZValues"]);
    vtkHardwareSelector(publicAPI, model);
  }
  var newInstance54 = macro.newInstance(extend54, "vtkHardwareSelector");
  var vtkHardwareSelector$1 = {
    newInstance: newInstance54,
    extend: extend54
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode/Constants.js
  var SelectionContent = {
    GLOBALIDS: 0,
    PEDIGREEIDS: 1,
    VALUES: 2,
    INDICES: 3,
    FRUSTUM: 4,
    LOCATIONS: 5,
    THRESHOLDS: 6,
    BLOCKS: 7,
    QUERY: 8
  };
  var SelectionField = {
    CELL: 0,
    POINT: 1,
    FIELD: 2,
    VERTEX: 3,
    EDGE: 4,
    ROW: 5
  };
  var Constants12 = {
    SelectionContent,
    SelectionField
  };

  // node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode.js
  function vtkSelectionNode(publicAPI, model) {
    model.classHierarchy.push("vtkSelectionNode");
    publicAPI.getBounds = () => model.points.getBounds();
  }
  var DEFAULT_VALUES53 = {
    contentType: -1,
    fieldType: -1,
    properties: null,
    selectionList: []
  };
  function extend55(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES53, initialValues);
    macro.obj(publicAPI, model);
    model.properties = {};
    macro.setGet(publicAPI, model, ["contentType", "fieldType", "properties", "selectionList"]);
    vtkSelectionNode(publicAPI, model);
  }
  var newInstance55 = macro.newInstance(extend55, "vtkSelectionNode");
  var vtkSelectionNode$1 = {
    newInstance: newInstance55,
    extend: extend55,
    ...Constants12
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js
  var {
    PassTypes: PassTypes2
  } = Constants9;
  var {
    SelectionContent: SelectionContent2,
    SelectionField: SelectionField2
  } = vtkSelectionNode$1;
  var {
    FieldAssociations: FieldAssociations4
  } = vtkDataSet$1;
  var {
    vtkErrorMacro: vtkErrorMacro21
  } = macro;
  var idOffset = 1;
  function getInfoHash(info) {
    return `${info.propID} ${info.compositeID}`;
  }
  function getAlpha(xx, yy, pb, area) {
    if (!pb) {
      return 0;
    }
    const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
    return pb[offset + 3];
  }
  function convert(xx, yy, pb, area) {
    if (!pb) {
      return 0;
    }
    const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
    const r = pb[offset];
    const g = pb[offset + 1];
    const b = pb[offset + 2];
    return (b * 256 + g) * 256 + r;
  }
  function getID(low24, high8) {
    let val = high8;
    val <<= 24;
    val |= low24;
    return val;
  }
  function getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {
        return null;
      }
      const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];
      const actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ACTOR_PASS], buffdata.area);
      if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {
        return null;
      }
      const info2 = {};
      info2.valid = true;
      info2.propID = actorid - idOffset;
      info2.prop = buffdata.props[info2.propID];
      let compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.COMPOSITE_INDEX_PASS], buffdata.area);
      if (compositeID < 0 || compositeID > 16777215) {
        compositeID = 0;
      }
      info2.compositeID = compositeID - idOffset;
      if (buffdata.captureZValues) {
        const offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;
        info2.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535;
        info2.displayPosition = inDisplayPosition;
      }
      if (buffdata.pixBuffer[PassTypes2.ID_LOW24]) {
        if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ID_LOW24], buffdata.area) === 0) {
          return info2;
        }
      }
      const low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ID_LOW24], buffdata.area);
      const high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ID_HIGH24], buffdata.area);
      info2.attributeID = getID(low24, high24);
      return info2;
    }
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);
    if (info && info.valid) {
      return info;
    }
    for (let dist3 = 1; dist3 < maxDist; ++dist3) {
      for (let y = dispPos[1] > dist3 ? dispPos[1] - dist3 : 0; y <= dispPos[1] + dist3; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist3) {
          curPos[0] = dispPos[0] - dist3;
          info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist3;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      for (let x = dispPos[0] >= dist3 ? dispPos[0] - (dist3 - 1) : 0; x <= dispPos[0] + (dist3 - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist3) {
          curPos[1] = dispPos[1] - dist3;
          info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist3;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  }
  function convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {
    const sel = [];
    let count = 0;
    dataMap.forEach((value, key) => {
      const child = vtkSelectionNode$1.newInstance();
      child.setContentType(SelectionContent2.INDICES);
      switch (fieldassociation) {
        case FieldAssociations4.FIELD_ASSOCIATION_CELLS:
          child.setFieldType(SelectionField2.CELL);
          break;
        case FieldAssociations4.FIELD_ASSOCIATION_POINTS:
          child.setFieldType(SelectionField2.POINT);
          break;
        default:
          vtkErrorMacro21("Unknown field association");
      }
      child.getProperties().propID = value.info.propID;
      child.getProperties().prop = value.info.prop;
      child.getProperties().compositeID = value.info.compositeID;
      child.getProperties().attributeID = value.info.attributeID;
      child.getProperties().pixelCount = value.pixelCount;
      if (captureZValues) {
        child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
        child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);
      }
      child.setSelectionList(value.attributeIDs);
      sel[count] = child;
      count++;
    });
    return sel;
  }
  function generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y2 = Math.floor(fy2);
    const dataMap = /* @__PURE__ */ new Map();
    const outSelectedPosition = [0, 0];
    for (let yy = y1; yy <= y2; yy++) {
      for (let xx = x1; xx <= x2; xx++) {
        const pos = [xx, yy];
        const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);
        if (info && info.valid) {
          const hash = getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (buffdata.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);
  }
  function vtkOpenGLHardwareSelector(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLHardwareSelector");
    publicAPI.releasePixBuffers = () => {
      model.rawPixBuffer = [];
      model.pixBuffer = [];
      model.zBuffer = null;
    };
    publicAPI.beginSelection = () => {
      model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
      model.maxAttributeId = 0;
      const size = model._openGLRenderWindow.getSize();
      if (!model.framebuffer) {
        model.framebuffer = vtkOpenGLFramebuffer.newInstance();
        model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.framebuffer.saveCurrentBindingsAndBuffers();
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.framebuffer.saveCurrentBindingsAndBuffers();
        const fbSize = model.framebuffer.getSize();
        if (!fbSize || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.create(size[0], size[1]);
          model.framebuffer.populateFramebuffer();
        } else {
          model.framebuffer.bind();
        }
      }
      model._openGLRenderer.clear();
      model._openGLRenderer.setSelector(publicAPI);
      model.hitProps = {};
      model.propPixels = {};
      model.props = [];
      publicAPI.releasePixBuffers();
      if (model.fieldAssociation === FieldAssociations4.FIELD_ASSOCIATION_POINTS) {
        const gl = model._openGLRenderWindow.getContext();
        const originalBlending = gl.isEnabled(gl.BLEND);
        gl.disable(gl.BLEND);
        model._openGLRenderWindow.traverseAllPasses();
        if (originalBlending) {
          gl.enable(gl.BLEND);
        }
      }
    };
    publicAPI.endSelection = () => {
      model.hitProps = {};
      model._openGLRenderer.setSelector(null);
      model.framebuffer.restorePreviousBindingsAndBuffers();
    };
    publicAPI.preCapturePass = () => {
      const gl = model._openGLRenderWindow.getContext();
      model.originalBlending = gl.isEnabled(gl.BLEND);
      gl.disable(gl.BLEND);
    };
    publicAPI.postCapturePass = () => {
      const gl = model._openGLRenderWindow.getContext();
      if (model.originalBlending) {
        gl.enable(gl.BLEND);
      }
    };
    publicAPI.select = () => {
      let sel = null;
      if (publicAPI.captureBuffers()) {
        sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);
        publicAPI.releasePixBuffers();
      }
      return sel;
    };
    publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {
      model._renderer = renderer;
      if (fx1 === void 0) {
        const size = model._openGLRenderWindow.getSize();
        publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);
      } else {
        publicAPI.setArea(fx1, fy1, fx2, fy2);
      }
      if (!publicAPI.captureBuffers()) {
        return false;
      }
      const result = {
        area: [...model.area],
        pixBuffer: [...model.pixBuffer],
        captureZValues: model.captureZValues,
        zBuffer: model.zBuffer,
        props: [...model.props],
        fieldAssociation: model.fieldAssociation,
        renderer,
        openGLRenderWindow: model._openGLRenderWindow
      };
      result.generateSelection = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return generateSelectionWithData(result, ...args);
      };
      return result;
    };
    publicAPI.captureBuffers = () => {
      if (!model._renderer || !model._openGLRenderWindow) {
        vtkErrorMacro21("Renderer and view must be set before calling Select.");
        return false;
      }
      model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
      model._openGLRenderWindow.getRenderable().preRender();
      publicAPI.invokeEvent({
        type: "StartEvent"
      });
      model.originalBackground = model._renderer.getBackgroundByReference();
      model._renderer.setBackground(0, 0, 0, 0);
      const rpasses = model._openGLRenderWindow.getRenderPasses();
      publicAPI.beginSelection();
      const pixelBufferSavedPasses = [];
      for (model.currentPass = PassTypes2.MIN_KNOWN_PASS; model.currentPass <= PassTypes2.MAX_KNOWN_PASS; model.currentPass++) {
        if (publicAPI.passRequired(model.currentPass)) {
          publicAPI.preCapturePass(model.currentPass);
          if (model.captureZValues && model.currentPass === PassTypes2.ACTOR_PASS && typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
            rpasses[0].requestDepth();
            model._openGLRenderWindow.traverseAllPasses();
          } else {
            model._openGLRenderWindow.traverseAllPasses();
          }
          publicAPI.postCapturePass(model.currentPass);
          publicAPI.savePixelBuffer(model.currentPass);
          pixelBufferSavedPasses.push(model.currentPass);
        }
      }
      pixelBufferSavedPasses.forEach((pass) => {
        model.currentPass = pass;
        publicAPI.processPixelBuffers();
      });
      model.currentPass = PassTypes2.MAX_KNOWN_PASS;
      publicAPI.endSelection();
      model._renderer.setBackground(model.originalBackground);
      publicAPI.invokeEvent({
        type: "EndEvent"
      });
      return true;
    };
    publicAPI.processPixelBuffers = () => {
      model.props.forEach((prop, index) => {
        if (publicAPI.isPropHit(index)) {
          prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);
        }
      });
    };
    publicAPI.passRequired = (pass) => {
      if (pass === PassTypes2.ID_HIGH24) {
        if (model.fieldAssociation === FieldAssociations4.FIELD_ASSOCIATION_POINTS) {
          return model.maximumPointId > 16777215;
        }
        if (model.fieldAssociation === FieldAssociations4.FIELD_ASSOCIATION_CELLS) {
          return model.maximumCellId > 16777215;
        }
      }
      return true;
    };
    publicAPI.savePixelBuffer = (passNo) => {
      model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
      if (!model.rawPixBuffer[passNo]) {
        const size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;
        model.rawPixBuffer[passNo] = new Uint8Array(size);
        model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);
      }
      if (passNo === PassTypes2.ACTOR_PASS) {
        if (model.captureZValues) {
          const rpasses = model._openGLRenderWindow.getRenderPasses();
          if (typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
            const fb = rpasses[0].getFramebuffer();
            fb.saveCurrentBindingsAndBuffers();
            fb.bind();
            model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
            fb.restorePreviousBindingsAndBuffers();
          }
        }
        publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);
      }
    };
    publicAPI.buildPropHitList = (pixelbuffer) => {
      let offset = 0;
      for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {
        for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {
          let val = convert(xx, yy, pixelbuffer, model.area);
          if (val > 0) {
            val--;
            if (!(val in model.hitProps)) {
              model.hitProps[val] = true;
              model.propPixels[val] = [];
            }
            model.propPixels[val].push(offset * 4);
          }
          ++offset;
        }
      }
    };
    publicAPI.renderProp = (prop) => {
      if (model.currentPass === PassTypes2.ACTOR_PASS) {
        publicAPI.setPropColorValueFromInt(model.props.length + idOffset);
        model.props.push(prop);
      }
    };
    publicAPI.renderCompositeIndex = (index) => {
      if (model.currentPass === PassTypes2.COMPOSITE_INDEX_PASS) {
        publicAPI.setPropColorValueFromInt(index + idOffset);
      }
    };
    publicAPI.renderAttributeId = (attribid) => {
      if (attribid < 0) {
        return;
      }
      model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;
    };
    publicAPI.passTypeToString = (type) => macro.enumToString(PassTypes2, type);
    publicAPI.isPropHit = (id) => Boolean(model.hitProps[id]);
    publicAPI.setPropColorValueFromInt = (val) => {
      model.propColorValue[0] = val % 256 / 255;
      model.propColorValue[1] = Math.floor(val / 256) % 256 / 255;
      model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255;
    };
    publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {
      const maxDist = maxDistance < 0 ? 0 : maxDistance;
      if (maxDist === 0) {
        outSelectedPosition[0] = inDisplayPosition[0];
        outSelectedPosition[1] = inDisplayPosition[1];
        if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {
          return null;
        }
        const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];
        const actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ACTOR_PASS], model.area);
        if (actorid <= 0 || actorid - idOffset >= model.props.length) {
          return null;
        }
        const info2 = {};
        info2.valid = true;
        info2.propID = actorid - idOffset;
        info2.prop = model.props[info2.propID];
        let compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.COMPOSITE_INDEX_PASS], model.area);
        if (compositeID < 0 || compositeID > 16777215) {
          compositeID = 0;
        }
        info2.compositeID = compositeID - idOffset;
        if (model.captureZValues) {
          const offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;
          info2.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535;
          info2.displayPosition = inDisplayPosition;
        }
        if (model.pixBuffer[PassTypes2.ID_LOW24]) {
          if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ID_LOW24], model.area) === 0) {
            return info2;
          }
        }
        const low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ID_LOW24], model.area);
        const high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ID_HIGH24], model.area);
        info2.attributeID = getID(low24, high24);
        return info2;
      }
      const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
      const curPos = [0, 0];
      let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
      for (let dist3 = 1; dist3 < maxDist; ++dist3) {
        for (let y = dispPos[1] > dist3 ? dispPos[1] - dist3 : 0; y <= dispPos[1] + dist3; ++y) {
          curPos[1] = y;
          if (dispPos[0] >= dist3) {
            curPos[0] = dispPos[0] - dist3;
            info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
            if (info && info.valid) {
              return info;
            }
          }
          curPos[0] = dispPos[0] + dist3;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        for (let x = dispPos[0] >= dist3 ? dispPos[0] - (dist3 - 1) : 0; x <= dispPos[0] + (dist3 - 1); ++x) {
          curPos[0] = x;
          if (dispPos[1] >= dist3) {
            curPos[1] = dispPos[1] - dist3;
            info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
            if (info && info.valid) {
              return info;
            }
          }
          curPos[1] = dispPos[1] + dist3;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
      }
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      return null;
    };
    publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {
      const x1 = Math.floor(fx1);
      const y1 = Math.floor(fy1);
      const x2 = Math.floor(fx2);
      const y2 = Math.floor(fy2);
      const dataMap = /* @__PURE__ */ new Map();
      const outSelectedPosition = [0, 0];
      for (let yy = y1; yy <= y2; yy++) {
        for (let xx = x1; xx <= x2; xx++) {
          const pos = [xx, yy];
          const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
          if (info && info.valid) {
            const hash = getInfoHash(info);
            if (!dataMap.has(hash)) {
              dataMap.set(hash, {
                info,
                pixelCount: 1,
                attributeIDs: [info.attributeID]
              });
            } else {
              const dmv = dataMap.get(hash);
              dmv.pixelCount++;
              if (model.captureZValues) {
                if (info.zValue < dmv.info.zValue) {
                  dmv.info = info;
                }
              }
              if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
                dmv.attributeIDs.push(info.attributeID);
              }
            }
          }
        }
      }
      return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);
    };
    publicAPI.getRawPixelBuffer = (passNo) => model.rawPixBuffer[passNo];
    publicAPI.getPixelBuffer = (passNo) => model.pixBuffer[passNo];
    publicAPI.attach = (openGLRenderWindow, renderer) => {
      model._openGLRenderWindow = openGLRenderWindow;
      model._renderer = renderer;
    };
    const superSetArea = publicAPI.setArea;
    publicAPI.setArea = function() {
      if (superSetArea(...arguments)) {
        model.area[0] = Math.floor(model.area[0]);
        model.area[1] = Math.floor(model.area[1]);
        model.area[2] = Math.floor(model.area[2]);
        model.area[3] = Math.floor(model.area[3]);
        return true;
      }
      return false;
    };
  }
  var DEFAULT_VALUES54 = {
    area: void 0,
    // _renderer: null,
    // _openGLRenderWindow: null,
    // _openGLRenderer: null,
    currentPass: -1,
    propColorValue: null,
    props: null,
    maximumPointId: 0,
    maximumCellId: 0,
    idOffset: 1
  };
  function extend56(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES54, initialValues);
    vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
    model.propColorValue = [0, 0, 0];
    model.props = [];
    if (!model.area) {
      model.area = [0, 0, 0, 0];
    }
    macro.setGetArray(publicAPI, model, ["area"], 4);
    macro.setGet(publicAPI, model, ["_renderer", "currentPass", "_openGLRenderWindow", "maximumPointId", "maximumCellId"]);
    macro.setGetArray(publicAPI, model, ["propColorValue"], 3);
    macro.moveToProtected(publicAPI, model, ["renderer", "openGLRenderWindow"]);
    macro.event(publicAPI, model, "event");
    vtkOpenGLHardwareSelector(publicAPI, model);
  }
  var newInstance56 = macro.newInstance(extend56, "vtkOpenGLHardwareSelector");
  var vtkHardwareSelector2 = {
    newInstance: newInstance56,
    extend: extend56,
    ...Constants9
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js
  var import_spark_md5 = __toESM(require_spark_md5(), 1);
  var SET_GET_FIELDS = ["lastShaderProgramBound", "context", "_openGLRenderWindow"];
  function vtkShaderCache(publicAPI, model) {
    model.classHierarchy.push("vtkShaderCache");
    publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {
      let nFSSource = FSSource;
      if (GSSource.length > 0) {
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, "VSOut", "GSOut").result;
      }
      const gl2 = model._openGLRenderWindow.getWebgl2();
      let fragDepthString = "\n";
      let version = "#version 100\n";
      if (gl2) {
        version = "#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n";
      } else {
        model.context.getExtension("OES_standard_derivatives");
        if (model.context.getExtension("EXT_frag_depth")) {
          fragDepthString = "#extension GL_EXT_frag_depth : enable\n";
        }
        if (model.context.getExtension("EXT_shader_texture_lod")) {
          fragDepthString += "#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT";
        }
      }
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::System::Dec", [`${version}
`, gl2 ? "" : "#extension GL_OES_standard_derivatives : enable\n", fragDepthString, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
      let nVSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::System::Dec", [`${version}
`, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
      if (gl2) {
        nVSSource = vtkShaderProgram$1.substitute(nVSSource, "varying", "out").result;
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, "varying", "in").result;
        let shaderOutputs = "";
        let outputCount = 0;
        while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {
          nFSSource = vtkShaderProgram$1.substitute(nFSSource, `gl_FragData\\[${outputCount}\\]`, `fragOutput${outputCount}`).result;
          shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};
`;
          outputCount++;
        }
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::Output::Dec", shaderOutputs).result;
      }
      const nGSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::System::Dec", version).result;
      return {
        VSSource: nVSSource,
        FSSource: nFSSource,
        GSSource: nGSSource
      };
    };
    publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {
      const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);
      const shaderProgram = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);
      return publicAPI.readyShaderProgram(shaderProgram);
    };
    publicAPI.readyShaderProgram = (program) => {
      if (!program) {
        return null;
      }
      if (!program.getCompiled() && !program.compileShader()) {
        return null;
      }
      if (!publicAPI.bindShaderProgram(program)) {
        return null;
      }
      return program;
    };
    publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {
      const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;
      const result = import_spark_md5.default.hash(hashInput);
      if (!(result in model.shaderPrograms)) {
        const sps = vtkShaderProgram$1.newInstance();
        sps.setContext(model.context);
        sps.getVertexShader().setSource(vertexCode);
        sps.getFragmentShader().setSource(fragmentCode);
        if (geometryCode) {
          sps.getGeometryShader().setSource(geometryCode);
        }
        sps.setMd5Hash(result);
        model.shaderPrograms[result] = sps;
        return sps;
      }
      return model.shaderPrograms[result];
    };
    publicAPI.releaseGraphicsResources = (win) => {
      publicAPI.releaseCurrentShaderProgram();
      Object.keys(model.shaderPrograms).map((key) => model.shaderPrograms[key]).forEach((sp) => sp.cleanup());
      model.shaderPrograms = {};
    };
    publicAPI.releaseCurrentShaderProgram = () => {
      if (model.lastShaderProgramBound) {
        model.lastShaderProgramBound.cleanup();
        model.lastShaderProgramBound = null;
      }
    };
    publicAPI.bindShaderProgram = (program) => {
      if (model.lastShaderProgramBound === program) {
        return 1;
      }
      if (model.lastShaderProgramBound) {
        model.lastShaderProgramBound.release();
      }
      program.bind();
      model.lastShaderProgramBound = program;
      return 1;
    };
  }
  var DEFAULT_VALUES55 = {
    lastShaderProgramBound: null,
    shaderPrograms: null,
    context: null
    // _openGLRenderWindow: null,
  };
  function extend57(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES55, initialValues);
    model.shaderPrograms = {};
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, SET_GET_FIELDS);
    macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
    vtkShaderCache(publicAPI, model);
  }
  var newInstance57 = macro.newInstance(extend57, "vtkShaderCache");
  var vtkShaderCache$1 = {
    newInstance: newInstance57,
    extend: extend57
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/TextureUnitManager.js
  var {
    vtkErrorMacro: vtkErrorMacro22
  } = macro;
  function vtkOpenGLTextureUnitManager(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLTextureUnitManager");
    publicAPI.deleteTable = () => {
      for (let i = 0; i < model.numberOfTextureUnits; ++i) {
        if (model.textureUnits[i] === true) {
          vtkErrorMacro22("some texture units  were not properly released");
        }
      }
      model.textureUnits = [];
      model.numberOfTextureUnits = 0;
    };
    publicAPI.setContext = (ctx) => {
      if (model.context !== ctx) {
        if (model.context !== 0) {
          publicAPI.deleteTable();
        }
        model.context = ctx;
        if (model.context) {
          model.numberOfTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
          for (let i = 0; i < model.numberOfTextureUnits; ++i) {
            model.textureUnits[i] = false;
          }
        }
        publicAPI.modified();
      }
    };
    publicAPI.allocate = () => {
      for (let i = 0; i < model.numberOfTextureUnits; i++) {
        if (!publicAPI.isAllocated(i)) {
          model.textureUnits[i] = true;
          return i;
        }
      }
      return -1;
    };
    publicAPI.allocateUnit = (unit2) => {
      if (publicAPI.isAllocated(unit2)) {
        return -1;
      }
      model.textureUnits[unit2] = true;
      return unit2;
    };
    publicAPI.isAllocated = (textureUnitId) => model.textureUnits[textureUnitId];
    publicAPI.free = (val) => {
      model.textureUnits[val] = false;
    };
    publicAPI.freeAll = () => {
      for (let i = 0; i < model.numberOfTextureUnits; ++i) {
        model.textureUnits[i] = false;
      }
    };
  }
  var DEFAULT_VALUES56 = {
    context: null,
    numberOfTextureUnits: 0,
    textureUnits: 0
  };
  function extend58(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES56, initialValues);
    macro.obj(publicAPI, model);
    model.textureUnits = [];
    macro.get(publicAPI, model, ["numberOfTextureUnits"]);
    macro.setGet(publicAPI, model, ["context"]);
    vtkOpenGLTextureUnitManager(publicAPI, model);
  }
  var newInstance58 = macro.newInstance(extend58, "vtkOpenGLTextureUnitManager");
  var vtkTextureUnitManager = {
    newInstance: newInstance58,
    extend: extend58
  };

  // node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderWindowViewNode.js
  function vtkRenderWindowViewNode(publicAPI, model) {
    model.classHierarchy.push("vtkRenderWindowViewNode");
    publicAPI.getViewNodeFactory = () => null;
    publicAPI.getAspectRatio = () => model.size[0] / model.size[1];
    publicAPI.getAspectRatioForRenderer = (renderer) => {
      const viewport = renderer.getViewportByReference();
      return model.size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * model.size[1]);
    };
    publicAPI.isInViewport = (x, y, viewport) => {
      const vCoords = viewport.getViewportByReference();
      const size = publicAPI.getFramebufferSize();
      if (vCoords[0] * size[0] <= x && vCoords[2] * size[0] >= x && vCoords[1] * size[1] <= y && vCoords[3] * size[1] >= y) {
        return true;
      }
      return false;
    };
    publicAPI.getViewportSize = (viewport) => {
      const vCoords = viewport.getViewportByReference();
      const size = publicAPI.getFramebufferSize();
      return [(vCoords[2] - vCoords[0]) * size[0], (vCoords[3] - vCoords[1]) * size[1]];
    };
    publicAPI.getViewportCenter = (viewport) => {
      const size = publicAPI.getViewportSize(viewport);
      return [size[0] * 0.5, size[1] * 0.5];
    };
    publicAPI.displayToNormalizedDisplay = (x, y, z) => {
      const size = publicAPI.getFramebufferSize();
      return [x / size[0], y / size[1], z];
    };
    publicAPI.normalizedDisplayToDisplay = (x, y, z) => {
      const size = publicAPI.getFramebufferSize();
      return [x * size[0], y * size[1], z];
    };
    publicAPI.worldToView = (x, y, z, renderer) => renderer.worldToView(x, y, z);
    publicAPI.viewToWorld = (x, y, z, renderer) => renderer.viewToWorld(x, y, z);
    publicAPI.worldToDisplay = (x, y, z, renderer) => {
      const val = renderer.worldToView(x, y, z);
      const dims = publicAPI.getViewportSize(renderer);
      const val2 = renderer.viewToProjection(val[0], val[1], val[2], dims[0] / dims[1]);
      const val3 = renderer.projectionToNormalizedDisplay(val2[0], val2[1], val2[2]);
      return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
    };
    publicAPI.displayToWorld = (x, y, z, renderer) => {
      const val = publicAPI.displayToNormalizedDisplay(x, y, z);
      const val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
      const dims = publicAPI.getViewportSize(renderer);
      const val3 = renderer.projectionToView(val2[0], val2[1], val2[2], dims[0] / dims[1]);
      return renderer.viewToWorld(val3[0], val3[1], val3[2]);
    };
    publicAPI.normalizedDisplayToViewport = (x, y, z, renderer) => {
      let vCoords = renderer.getViewportByReference();
      vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
      const coords = publicAPI.normalizedDisplayToDisplay(x, y, z);
      return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z];
    };
    publicAPI.viewportToNormalizedViewport = (x, y, z, renderer) => {
      const size = publicAPI.getViewportSize(renderer);
      if (size && size[0] !== 0 && size[1] !== 0) {
        return [x / (size[0] - 1), y / (size[1] - 1), z];
      }
      return [x, y, z];
    };
    publicAPI.normalizedViewportToViewport = (x, y, z, renderer) => {
      const size = publicAPI.getViewportSize(renderer);
      return [x * (size[0] - 1), y * (size[1] - 1), z];
    };
    publicAPI.displayToLocalDisplay = (x, y, z) => {
      const size = publicAPI.getFramebufferSize();
      return [x, size[1] - y - 1, z];
    };
    publicAPI.viewportToNormalizedDisplay = (x, y, z, renderer) => {
      let vCoords = renderer.getViewportByReference();
      vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
      const x2 = x + vCoords[0] + 0.5;
      const y2 = y + vCoords[1] + 0.5;
      return publicAPI.displayToNormalizedDisplay(x2, y2, z);
    };
    publicAPI.getComputedDevicePixelRatio = () => model.size[0] / publicAPI.getContainerSize()[0];
    publicAPI.getContainerSize = () => {
      macro.vtkErrorMacro("not implemented");
    };
    publicAPI.getPixelData = (x1, y1, x2, y2) => {
      macro.vtkErrorMacro("not implemented");
    };
    publicAPI.createSelector = () => {
      macro.vtkErrorMacro("not implemented");
    };
  }
  var DEFAULT_VALUES57 = {
    size: void 0,
    selector: void 0
  };
  function extend59(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES57, initialValues);
    if (!model.size) {
      model.size = [300, 300];
    }
    macro.getArray(publicAPI, model, ["size"], 2);
    macro.get(publicAPI, model, ["selector"]);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    vtkRenderWindowViewNode(publicAPI, model);
  }
  var newInstance59 = macro.newInstance(extend59, "vtkRenderWindowViewNode");
  var vtkRenderWindowViewNode$1 = {
    newInstance: newInstance59,
    extend: extend59
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/ContextProxy.js
  var GET_UNDERLYING_CONTEXT = "__getUnderlyingContext";
  function createContextProxyHandler() {
    const cache = /* @__PURE__ */ new Map();
    const getParameterHandler = {
      apply(target, gl, args) {
        if (cache.has(args[0])) {
          return cache.get(args[0]);
        }
        return target.apply(gl, args);
      }
    };
    function cachedSetterHandler(key) {
      return {
        apply(target, gl, args) {
          cache.set(key, args[0]);
          return target.apply(gl, args);
        }
      };
    }
    const propHandlers = /* @__PURE__ */ Object.create(null);
    propHandlers.getParameter = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), getParameterHandler);
    propHandlers.depthMask = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));
    return {
      get(gl, prop, receiver) {
        if (prop === GET_UNDERLYING_CONTEXT) return () => gl;
        let value = Reflect.get(gl, prop, gl);
        if (value instanceof Function) {
          value = value.bind(gl);
        }
        const propHandler = propHandlers[prop];
        if (propHandler) {
          return propHandler(gl, prop, receiver, value);
        }
        return value;
      }
    };
  }

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js
  var {
    vtkDebugMacro: vtkDebugMacro5,
    vtkErrorMacro: vtkErrorMacro23
  } = macro;
  var SCREENSHOT_PLACEHOLDER = {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%"
  };
  var parentMethodsToProxy = ["activateTexture", "deactivateTexture", "disableCullFace", "enableCullFace", "get3DContext", "getActiveFramebuffer", "getContext", "getDefaultTextureByteSize", "getDefaultTextureInternalFormat", "getDefaultToWebgl2", "getGLInformations", "getGraphicsMemoryInfo", "getGraphicsResourceForObject", "getHardwareMaximumLineWidth", "getPixelData", "getShaderCache", "getTextureUnitForTexture", "getTextureUnitManager", "getWebgl2", "makeCurrent", "releaseGraphicsResources", "registerGraphicsResourceUser", "unregisterGraphicsResourceUser", "restoreContext", "setActiveFramebuffer", "setContext", "setDefaultToWebgl2", "setGraphicsResourceForObject"];
  function checkRenderTargetSupport(gl, format2, type) {
    const framebuffer = gl.createFramebuffer();
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, format2, 2, 2, 0, format2, type, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return status === gl.FRAMEBUFFER_COMPLETE;
  }
  var GL_CONTEXT_COUNT = 0;
  var GL_CONTEXT_LISTENERS = [];
  function createGLContext() {
    GL_CONTEXT_COUNT++;
    GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
  }
  function deleteGLContext() {
    GL_CONTEXT_COUNT--;
    GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
  }
  function _preventDefault(e) {
    e.preventDefault();
  }
  function vtkOpenGLRenderWindow(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLRenderWindow");
    let cachingContextHandler;
    function getCachingContextHandler() {
      if (!cachingContextHandler) {
        cachingContextHandler = createContextProxyHandler();
      }
      return cachingContextHandler;
    }
    publicAPI.getViewNodeFactory = () => model.myFactory;
    model.canvas.addEventListener("webglcontextlost", _preventDefault, false);
    model.canvas.addEventListener("webglcontextrestored", publicAPI.restoreContext, false);
    const previousSize = [0, 0];
    function updateWindow() {
      if (model.renderable) {
        if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
          previousSize[0] = model.size[0];
          previousSize[1] = model.size[1];
          model.canvas.setAttribute("width", model.size[0]);
          model.canvas.setAttribute("height", model.size[1]);
        }
      }
      if (model.viewStream) {
        model.viewStream.setSize(model.size[0], model.size[1]);
      }
      model.canvas.style.display = model.useOffScreen ? "none" : "block";
      if (model.el) {
        model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
      }
      model.containerSize = null;
    }
    publicAPI.onModified(updateWindow);
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
        publicAPI.addMissingNodes(model.renderable.getChildRenderWindowsByReference());
        publicAPI.removeUnusedNodes();
        publicAPI.initialize();
        model.children.forEach((child) => {
          child.setOpenGLRenderWindow?.(publicAPI);
        });
      }
    };
    publicAPI.initialize = () => {
      if (!model.initialized) {
        model.rootOpenGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
        if (model.rootOpenGLRenderWindow) {
          model.context2D = publicAPI.get2DContext();
        } else {
          model.context = publicAPI.get3DContext();
          publicAPI.resizeFromChildRenderWindows();
          if (model.context) {
            createGLContext();
          }
          model.textureUnitManager = vtkTextureUnitManager.newInstance();
          model.textureUnitManager.setContext(model.context);
          model.shaderCache.setContext(model.context);
          const gl = model.context;
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          gl.depthFunc(gl.LEQUAL);
          gl.enable(gl.BLEND);
        }
        model.initialized = true;
      }
    };
    publicAPI.makeCurrent = () => {
      model.context.makeCurrent();
    };
    publicAPI.setContainer = (el) => {
      if (model.el && model.el !== el) {
        if (model.canvas.parentNode !== model.el) {
          vtkErrorMacro23("Error: canvas parent node does not match container");
        }
        model.el.removeChild(model.canvas);
        if (model.el.contains(model.bgImage)) {
          model.el.removeChild(model.bgImage);
        }
      }
      if (model.el !== el) {
        model.el = el;
        if (model.el) {
          model.el.appendChild(model.canvas);
          if (model.useBackgroundImage) {
            model.el.appendChild(model.bgImage);
          }
        }
        publicAPI.modified();
      }
    };
    publicAPI.getContainer = () => model.el;
    publicAPI.getContainerSize = () => {
      if (!model.containerSize && model.el) {
        const {
          width,
          height
        } = model.el.getBoundingClientRect();
        model.containerSize = [width, height];
      }
      return model.containerSize || model.size;
    };
    publicAPI.getFramebufferSize = () => {
      const fbSize = model.activeFramebuffer?.getSize();
      return fbSize || model.size;
    };
    publicAPI.getPixelData = (x1, y1, x2, y2) => {
      const pixels = new Uint8Array((x2 - x1 + 1) * (y2 - y1 + 1) * 4);
      model.context.readPixels(x1, y1, x2 - x1 + 1, y2 - y1 + 1, model.context.RGBA, model.context.UNSIGNED_BYTE, pixels);
      return pixels;
    };
    publicAPI.get3DContext = function() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        preserveDrawingBuffer: false,
        depth: true,
        alpha: true,
        powerPreference: "high-performance"
      };
      let result = null;
      const webgl2Supported = typeof WebGL2RenderingContext !== "undefined";
      model.webgl2 = false;
      if (model.defaultToWebgl2 && webgl2Supported) {
        result = model.canvas.getContext("webgl2", options);
        if (result) {
          model.webgl2 = true;
          vtkDebugMacro5("using webgl2");
        }
      }
      if (!result) {
        vtkDebugMacro5("using webgl1");
        result = model.canvas.getContext("webgl", options) || model.canvas.getContext("experimental-webgl", options);
      }
      return new Proxy(result, getCachingContextHandler());
    };
    publicAPI.get2DContext = function() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return model.canvas.getContext("2d", options);
    };
    publicAPI.restoreContext = () => {
      const rp = vtkRenderPass$1.newInstance();
      rp.setCurrentOperation("Release");
      rp.traverse(publicAPI, null);
    };
    publicAPI.activateTexture = (texture) => {
      const result = model._textureResourceIds.get(texture);
      if (result !== void 0) {
        model.context.activeTexture(model.context.TEXTURE0 + result);
        return;
      }
      const activeUnit = publicAPI.getTextureUnitManager().allocate();
      if (activeUnit < 0) {
        vtkErrorMacro23("Hardware does not support the number of textures defined.");
        return;
      }
      model._textureResourceIds.set(texture, activeUnit);
      model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
    };
    publicAPI.deactivateTexture = (texture) => {
      const result = model._textureResourceIds.get(texture);
      if (result !== void 0) {
        publicAPI.getTextureUnitManager().free(result);
        model._textureResourceIds.delete(texture);
      }
    };
    publicAPI.getTextureUnitForTexture = (texture) => {
      const result = model._textureResourceIds.get(texture);
      if (result !== void 0) {
        return result;
      }
      return -1;
    };
    publicAPI.getDefaultTextureByteSize = function(vtkType) {
      let oglNorm16Ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      let useHalfFloat = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (model.webgl2) {
        switch (vtkType) {
          case VtkDataTypes.CHAR:
          case VtkDataTypes.SIGNED_CHAR:
          case VtkDataTypes.UNSIGNED_CHAR:
            return 1;
          case oglNorm16Ext:
          case useHalfFloat:
          case VtkDataTypes.UNSIGNED_SHORT:
          case VtkDataTypes.SHORT:
          case VtkDataTypes.VOID:
            return 2;
          default:
            return 4;
        }
      }
      return 1;
    };
    publicAPI.getDefaultTextureInternalFormat = function(vtktype, numComps) {
      let oglNorm16Ext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      let useHalfFloat = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (model.webgl2) {
        switch (vtktype) {
          case VtkDataTypes.UNSIGNED_CHAR:
            switch (numComps) {
              case 1:
                return model.context.R8;
              case 2:
                return model.context.RG8;
              case 3:
                return model.context.RGB8;
              case 4:
              default:
                return model.context.RGBA8;
            }
          case (oglNorm16Ext && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT):
            switch (numComps) {
              case 1:
                return oglNorm16Ext.R16_EXT;
              case 2:
                return oglNorm16Ext.RG16_EXT;
              case 3:
                return oglNorm16Ext.RGB16_EXT;
              case 4:
              default:
                return oglNorm16Ext.RGBA16_EXT;
            }
          // prioritize norm16 over float
          case (oglNorm16Ext && !useHalfFloat && VtkDataTypes.SHORT):
            switch (numComps) {
              case 1:
                return oglNorm16Ext.R16_SNORM_EXT;
              case 2:
                return oglNorm16Ext.RG16_SNORM_EXT;
              case 3:
                return oglNorm16Ext.RGB16_SNORM_EXT;
              case 4:
              default:
                return oglNorm16Ext.RGBA16_SNORM_EXT;
            }
          case VtkDataTypes.UNSIGNED_SHORT:
          case VtkDataTypes.SHORT:
          case VtkDataTypes.FLOAT:
          default:
            switch (numComps) {
              case 1:
                return useHalfFloat ? model.context.R16F : model.context.R32F;
              case 2:
                return useHalfFloat ? model.context.RG16F : model.context.RG32F;
              case 3:
                return useHalfFloat ? model.context.RGB16F : model.context.RGB32F;
              case 4:
              default:
                return useHalfFloat ? model.context.RGBA16F : model.context.RGBA32F;
            }
        }
      }
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
        default:
          return model.context.RGBA;
      }
    };
    publicAPI.setBackgroundImage = (img) => {
      model.bgImage.src = img.src;
    };
    publicAPI.setUseBackgroundImage = (value) => {
      model.useBackgroundImage = value;
      if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
        model.el.appendChild(model.bgImage);
      } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    };
    function getCanvasDataURL() {
      let format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.imageFormat;
      const temporaryCanvas = document.createElement("canvas");
      const temporaryContext = temporaryCanvas.getContext("2d");
      temporaryCanvas.width = model.canvas.width;
      temporaryCanvas.height = model.canvas.height;
      temporaryContext.drawImage(model.canvas, 0, 0);
      const mainBoundingClientRect = model.canvas.getBoundingClientRect();
      const renderWindow = model.renderable;
      const renderers = renderWindow.getRenderers();
      renderers.forEach((renderer) => {
        const viewProps = renderer.getViewProps();
        viewProps.forEach((viewProp) => {
          if (viewProp.getContainer) {
            const container = viewProp.getContainer();
            const canvasList = container.getElementsByTagName("canvas");
            for (let i = 0; i < canvasList.length; i++) {
              const currentCanvas = canvasList[i];
              const boundingClientRect = currentCanvas.getBoundingClientRect();
              const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
              const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
              temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
            }
          }
        });
      });
      const screenshot = temporaryCanvas.toDataURL(format2);
      temporaryCanvas.remove();
      publicAPI.invokeImageReady(screenshot);
    }
    publicAPI.captureNextImage = function() {
      let format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
      let {
        resetCamera: resetCamera2 = false,
        size = null,
        scale: scale7 = 1
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (model.deleted) {
        return null;
      }
      model.imageFormat = format2;
      const previous = model.notifyStartCaptureImage;
      model.notifyStartCaptureImage = true;
      model._screenshot = {
        size: !!size || scale7 !== 1 ? size || model.size.map((val) => val * scale7) : null
      };
      return new Promise((resolve, reject) => {
        const subscription = publicAPI.onImageReady((imageURL) => {
          if (model._screenshot.size === null) {
            model.notifyStartCaptureImage = previous;
            subscription.unsubscribe();
            if (model._screenshot.placeHolder) {
              model.size = model._screenshot.originalSize;
              publicAPI.modified();
              if (model._screenshot.cameras) {
                model._screenshot.cameras.forEach((_ref) => {
                  let {
                    restoreParamsFn,
                    arg
                  } = _ref;
                  return restoreParamsFn(arg);
                });
              }
              publicAPI.traverseAllPasses();
              model.el.removeChild(model._screenshot.placeHolder);
              model._screenshot.placeHolder.remove();
              model._screenshot = null;
            }
            resolve(imageURL);
          } else {
            const tmpImg = document.createElement("img");
            tmpImg.style = SCREENSHOT_PLACEHOLDER;
            tmpImg.src = imageURL;
            model._screenshot.placeHolder = model.el.appendChild(tmpImg);
            model.canvas.style.display = "none";
            model._screenshot.originalSize = model.size;
            model.size = model._screenshot.size;
            model.rootOpenGLRenderWindow?.resizeFromChildRenderWindows();
            model._screenshot.size = null;
            publicAPI.modified();
            if (resetCamera2) {
              const isUserResetCamera = resetCamera2 !== true;
              model._screenshot.cameras = model.renderable.getRenderers().map((renderer) => {
                const camera = renderer.getActiveCamera();
                const params = camera.get("focalPoint", "position", "parallelScale");
                return {
                  resetCameraArgs: isUserResetCamera ? {
                    renderer
                  } : void 0,
                  resetCameraFn: isUserResetCamera ? resetCamera2 : renderer.resetCamera,
                  restoreParamsFn: camera.set,
                  // "clone" the params so we don't keep refs to properties
                  arg: JSON.parse(JSON.stringify(params))
                };
              });
              model._screenshot.cameras.forEach((_ref2) => {
                let {
                  resetCameraFn,
                  resetCameraArgs
                } = _ref2;
                return resetCameraFn(resetCameraArgs);
              });
            }
            publicAPI.traverseAllPasses();
          }
        });
      });
    };
    let hardwareMaximumLineWidth;
    publicAPI.getHardwareMaximumLineWidth = () => {
      if (hardwareMaximumLineWidth != null) {
        return hardwareMaximumLineWidth;
      }
      const gl = publicAPI.get3DContext();
      const lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
      hardwareMaximumLineWidth = lineWidthRange[1];
      return lineWidthRange[1];
    };
    publicAPI.getGLInformations = () => {
      if (model._glInformation) {
        return model._glInformation;
      }
      const gl = publicAPI.get3DContext();
      const glTextureFloat = gl.getExtension("OES_texture_float");
      const glTextureHalfFloat = gl.getExtension("OES_texture_half_float");
      const glDebugRendererInfo = gl.getExtension("WEBGL_debug_renderer_info");
      const glDrawBuffers = gl.getExtension("WEBGL_draw_buffers");
      const glAnisotropic = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
      const params = [["Max Vertex Attributes", "MAX_VERTEX_ATTRIBS", gl.getParameter(gl.MAX_VERTEX_ATTRIBS)], ["Max Varying Vectors", "MAX_VARYING_VECTORS", gl.getParameter(gl.MAX_VARYING_VECTORS)], ["Max Vertex Uniform Vectors", "MAX_VERTEX_UNIFORM_VECTORS", gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)], ["Max Fragment Uniform Vectors", "MAX_FRAGMENT_UNIFORM_VECTORS", gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)], ["Max Fragment Texture Image Units", "MAX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)], ["Max Vertex Texture Image Units", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)], ["Max Combined Texture Image Units", "MAX_COMBINED_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)], ["Max 2D Texture Size", "MAX_TEXTURE_SIZE", gl.getParameter(gl.MAX_TEXTURE_SIZE)], ["Max Cube Texture Size", "MAX_CUBE_MAP_TEXTURE_SIZE", gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)], ["Max Texture Anisotropy", "MAX_TEXTURE_MAX_ANISOTROPY_EXT", glAnisotropic && gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)], ["Point Size Range", "ALIASED_POINT_SIZE_RANGE", gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(" - ")], ["Line Width Range", "ALIASED_LINE_WIDTH_RANGE", gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(" - ")], ["Max Viewport Dimensions", "MAX_VIEWPORT_DIMS", gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(" - ")], ["Max Renderbuffer Size", "MAX_RENDERBUFFER_SIZE", gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)], ["Framebuffer Red Bits", "RED_BITS", gl.getParameter(gl.RED_BITS)], ["Framebuffer Green Bits", "GREEN_BITS", gl.getParameter(gl.GREEN_BITS)], ["Framebuffer Blue Bits", "BLUE_BITS", gl.getParameter(gl.BLUE_BITS)], ["Framebuffer Alpha Bits", "ALPHA_BITS", gl.getParameter(gl.ALPHA_BITS)], ["Framebuffer Depth Bits", "DEPTH_BITS", gl.getParameter(gl.DEPTH_BITS)], ["Framebuffer Stencil Bits", "STENCIL_BITS", gl.getParameter(gl.STENCIL_BITS)], ["Framebuffer Subpixel Bits", "SUBPIXEL_BITS", gl.getParameter(gl.SUBPIXEL_BITS)], ["MSAA Samples", "SAMPLES", gl.getParameter(gl.SAMPLES)], ["MSAA Sample Buffers", "SAMPLE_BUFFERS", gl.getParameter(gl.SAMPLE_BUFFERS)], ["Supported Formats for UByte Render Targets     ", "UNSIGNED_BYTE RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Half Float Render Targets", "HALF FLOAT RENDER TARGET FORMATS", [glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGBA, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGBA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGB, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGB" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "ALPHA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Full Float Render Targets", "FLOAT RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Max Multiple Render Targets Buffers", "MAX_DRAW_BUFFERS_WEBGL", glDrawBuffers ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 0], ["High Float Precision in Vertex Shader", "HIGH_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Vertex Shader", "MEDIUM_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Vertex Shader", "LOW_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Float Precision in Fragment Shader", "HIGH_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Fragment Shader", "MEDIUM_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Fragment Shader", "LOW_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Vertex Shader", "HIGH_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Vertex Shader", "MEDIUM_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Vertex Shader", "LOW_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Fragment Shader", "HIGH_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Fragment Shader", "MEDIUM_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Fragment Shader", "LOW_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["Supported Extensions", "EXTENSIONS", gl.getSupportedExtensions().join("<br/>					    ")], ["WebGL Renderer", "RENDERER", gl.getParameter(gl.RENDERER)], ["WebGL Vendor", "VENDOR", gl.getParameter(gl.VENDOR)], ["WebGL Version", "VERSION", gl.getParameter(gl.VERSION)], ["Shading Language Version", "SHADING_LANGUAGE_VERSION", gl.getParameter(gl.SHADING_LANGUAGE_VERSION)], ["Unmasked Renderer", "UNMASKED_RENDERER", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL)], ["Unmasked Vendor", "UNMASKED_VENDOR", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL)], ["WebGL Version", "WEBGL_VERSION", model.webgl2 ? 2 : 1]];
      const result = {};
      while (params.length) {
        const [label, key, value] = params.pop();
        if (key) {
          result[key] = {
            label,
            value
          };
        }
      }
      model._glInformation = result;
      return result;
    };
    publicAPI.traverseAllPasses = () => {
      if (model.renderPasses) {
        for (let index = 0; index < model.renderPasses.length; ++index) {
          model.renderPasses[index].traverse(publicAPI, null);
        }
      }
      publicAPI.copyParentContent();
      if (model.notifyStartCaptureImage) {
        getCanvasDataURL();
      }
      const childrenRW = model.renderable.getChildRenderWindowsByReference();
      for (let i = 0; i < childrenRW.length; ++i) {
        publicAPI.getViewNodeFor(childrenRW[i])?.traverseAllPasses();
      }
    };
    publicAPI.copyParentContent = () => {
      const rootParent = model.rootOpenGLRenderWindow;
      if (!rootParent || !model.context2D || model.children.some((oglRenderer) => !!oglRenderer.getSelector?.())) {
        return;
      }
      const parentCanvas = rootParent.getCanvas();
      const selfCanvas = model.canvas;
      model.context2D.drawImage(
        parentCanvas,
        0,
        parentCanvas.height - selfCanvas.height,
        // source y axis is inverted
        selfCanvas.width,
        selfCanvas.height,
        0,
        0,
        selfCanvas.width,
        selfCanvas.height
      );
    };
    publicAPI.resizeFromChildRenderWindows = () => {
      const childrenRW = model.renderable.getChildRenderWindowsByReference();
      if (childrenRW.length > 0) {
        const maxSize = [0, 0];
        for (let i = 0; i < childrenRW.length; ++i) {
          const childSize = publicAPI.getViewNodeFor(childrenRW[i])?.getSize();
          if (childSize) {
            maxSize[0] = childSize[0] > maxSize[0] ? childSize[0] : maxSize[0];
            maxSize[1] = childSize[1] > maxSize[1] ? childSize[1] : maxSize[1];
          }
        }
        publicAPI.setSize(...maxSize);
      }
    };
    publicAPI.disableCullFace = () => {
      if (model.cullFaceEnabled) {
        model.context.disable(model.context.CULL_FACE);
        model.cullFaceEnabled = false;
      }
    };
    publicAPI.enableCullFace = () => {
      if (!model.cullFaceEnabled) {
        model.context.enable(model.context.CULL_FACE);
        model.cullFaceEnabled = true;
      }
    };
    publicAPI.setViewStream = (stream) => {
      if (model.viewStream === stream) {
        return false;
      }
      if (model.subscription) {
        model.subscription.unsubscribe();
        model.subscription = null;
      }
      model.viewStream = stream;
      if (model.viewStream) {
        const mainRenderer = model.renderable.getRenderers()[0];
        mainRenderer.getBackgroundByReference()[3] = 0;
        publicAPI.setUseBackgroundImage(true);
        model.subscription = model.viewStream.onImageReady((e) => publicAPI.setBackgroundImage(e.image));
        model.viewStream.setSize(model.size[0], model.size[1]);
        model.viewStream.invalidateCache();
        model.viewStream.render();
        publicAPI.modified();
      }
      return true;
    };
    publicAPI.createSelector = () => {
      const ret = vtkHardwareSelector2.newInstance();
      ret.setOpenGLRenderWindow(publicAPI);
      return ret;
    };
    function clearEvents() {
      model.canvas.removeEventListener("webglcontextlost", _preventDefault);
      model.canvas.removeEventListener("webglcontextrestored", publicAPI.restoreContext);
    }
    publicAPI.delete = macro.chain(() => {
      if (model.context) {
        deleteGLContext();
      }
      publicAPI.setContainer();
      publicAPI.setViewStream();
    }, clearEvents, publicAPI.delete);
    publicAPI.setActiveFramebuffer = (newActiveFramebuffer) => {
      model.activeFramebuffer = newActiveFramebuffer;
    };
    const superSetSize = publicAPI.setSize;
    publicAPI.setSize = (width, height) => {
      const modified = superSetSize(width, height);
      if (modified) {
        publicAPI.invokeWindowResizeEvent({
          width,
          height
        });
      }
      return modified;
    };
    publicAPI.registerGraphicsResourceUser = (coreObject, newUser) => {
      if (!model._graphicsResources.has(coreObject)) {
        publicAPI.setGraphicsResourceForObject(coreObject, null, null);
      }
      const sharedResource = model._graphicsResources.get(coreObject);
      sharedResource?.users.add(newUser);
    };
    publicAPI.unregisterGraphicsResourceUser = (coreObject, oldUser) => {
      const sharedResource = model._graphicsResources.get(coreObject);
      if (!sharedResource) {
        return;
      }
      sharedResource.users.delete(oldUser);
      if (!sharedResource.users.size) {
        sharedResource.oglObject?.releaseGraphicsResources(publicAPI);
        model._graphicsResources.delete(coreObject);
      }
    };
    publicAPI.getGraphicsResourceForObject = (coreObject) => model._graphicsResources.get(coreObject);
    publicAPI.setGraphicsResourceForObject = (coreObject, oglObject, hash) => {
      if (!coreObject) {
        return;
      }
      const sharedResource = model._graphicsResources.get(coreObject);
      sharedResource?.oglObject?.releaseGraphicsResources(publicAPI);
      model._graphicsResources.set(coreObject, {
        coreObject,
        oglObject,
        hash,
        users: sharedResource?.users ?? /* @__PURE__ */ new Set()
      });
    };
    publicAPI.getGraphicsMemoryInfo = () => {
      let memUsed = 0;
      model._graphicsResources.forEach((_ref3) => {
        let {
          oglObject
        } = _ref3;
        memUsed += oglObject.getAllocatedGPUMemoryInBytes();
      });
      return memUsed;
    };
    publicAPI.releaseGraphicsResources = () => {
      if (model.shaderCache !== null) {
        model.shaderCache.releaseGraphicsResources(publicAPI);
      }
      model._graphicsResources.forEach((_ref4) => {
        let {
          oglObject
        } = _ref4;
        oglObject.releaseGraphicsResources(publicAPI);
      });
      model._graphicsResources.clear();
      if (model.textureUnitManager !== null) {
        model.textureUnitManager.freeAll();
      }
      model.renderable.getRenderersByReference().forEach((ren) => {
        const glRen = publicAPI.getViewNodeFor(ren);
        glRen?.releaseGraphicsResources();
      });
    };
    const publicAPIBeforeProxy = {
      ...publicAPI
    };
    parentMethodsToProxy.forEach((methodName) => {
      publicAPI[methodName] = function() {
        if (model.rootOpenGLRenderWindow) {
          return model.rootOpenGLRenderWindow[methodName](...arguments);
        }
        return publicAPIBeforeProxy[methodName](...arguments);
      };
    });
  }
  var DEFAULT_VALUES58 = {
    cullFaceEnabled: false,
    shaderCache: null,
    initialized: false,
    context: null,
    context2D: null,
    canvas: null,
    cursorVisibility: true,
    cursor: "pointer",
    textureUnitManager: null,
    textureResourceIds: null,
    containerSize: null,
    renderPasses: [],
    notifyStartCaptureImage: false,
    webgl2: false,
    defaultToWebgl2: true,
    // attempt webgl2 on by default
    activeFramebuffer: null,
    imageFormat: "image/png",
    useOffScreen: false,
    useBackgroundImage: false
  };
  function extend60(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES58, initialValues);
    vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
    if (!model.canvas) {
      model.canvas = document.createElement("canvas");
      model.canvas.style.width = "100%";
    }
    if (!model.selector) {
      model.selector = vtkHardwareSelector2.newInstance();
      model.selector.setOpenGLRenderWindow(publicAPI);
    }
    model.bgImage = new Image();
    model.bgImage.style.position = "absolute";
    model.bgImage.style.left = "0";
    model.bgImage.style.top = "0";
    model.bgImage.style.width = "100%";
    model.bgImage.style.height = "100%";
    model.bgImage.style.zIndex = "-1";
    model._textureResourceIds = /* @__PURE__ */ new Map();
    model._graphicsResources = /* @__PURE__ */ new Map();
    model._glInformation = null;
    model.myFactory = vtkViewNodeFactory2.newInstance();
    model.shaderCache = vtkShaderCache$1.newInstance();
    model.shaderCache.setOpenGLRenderWindow(publicAPI);
    model.renderPasses[0] = vtkForwardPass$1.newInstance();
    macro.get(publicAPI, model, ["shaderCache", "textureUnitManager", "webgl2", "useBackgroundImage", "activeFramebuffer", "rootOpenGLRenderWindow"]);
    macro.setGet(publicAPI, model, ["initialized", "context", "context2D", "canvas", "renderPasses", "notifyStartCaptureImage", "defaultToWebgl2", "cursor", "useOffScreen"]);
    macro.setGetArray(publicAPI, model, ["size"], 2);
    macro.event(publicAPI, model, "imageReady");
    macro.event(publicAPI, model, "windowResizeEvent");
    vtkOpenGLRenderWindow(publicAPI, model);
  }
  var newInstance60 = macro.newInstance(extend60, "vtkOpenGLRenderWindow");
  registerViewConstructor("WebGL", newInstance60);
  registerOverride("vtkRenderWindow", newInstance60);

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js
  function vtkWebGPUShaderModule(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUShaderModule");
    publicAPI.initialize = (device, shaderDesc) => {
      model.device = device;
      model.handle = model.device.getHandle().createShaderModule({
        code: shaderDesc.getCode()
      });
    };
  }
  var DEFAULT_VALUES59 = {
    device: null,
    handle: null
  };
  function extend61(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES59, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["lastCameraMTime"]);
    macro.setGet(publicAPI, model, ["device", "handle"]);
    vtkWebGPUShaderModule(publicAPI, model);
  }
  var newInstance61 = macro.newInstance(extend61, "vtkWebGPUShaderModule");
  var vtkWebGPUShaderModule$1 = {
    newInstance: newInstance61,
    extend: extend61
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js
  function substitute2(source, search, replace) {
    let all = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    const replaceStr = Array.isArray(replace) ? replace.join("\n") : replace;
    let replaced = false;
    if (source.search(search) !== -1) {
      replaced = true;
    }
    let gflag = "";
    if (all) {
      gflag = "g";
    }
    const regex = new RegExp(search, gflag);
    const resultstr = source.replace(regex, replaceStr);
    return {
      replace: replaced,
      result: resultstr
    };
  }
  function vtkWebGPUShaderCache(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUShaderCache");
    publicAPI.getShaderModule = (shaderDesc) => {
      const sType = shaderDesc.getType();
      const sHash = shaderDesc.getHash();
      const keys = model._shaderModules.keys();
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key.getHash() === sHash && key.getType() === sType) {
          return model._shaderModules.get(key);
        }
      }
      const sm = vtkWebGPUShaderModule$1.newInstance();
      sm.initialize(model.device, shaderDesc);
      model._shaderModules.set(shaderDesc, sm);
      return sm;
    };
  }
  var DEFAULT_VALUES60 = {
    shaderModules: null,
    device: null,
    window: null
  };
  function extend62(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES60, initialValues);
    model._shaderModules = /* @__PURE__ */ new Map();
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["device", "window"]);
    vtkWebGPUShaderCache(publicAPI, model);
  }
  var newInstance62 = macro.newInstance(extend62, "vtkWebGPUShaderCache");
  var vtkWebGPUShaderCache$1 = {
    newInstance: newInstance62,
    extend: extend62,
    substitute: substitute2
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
  function vtkWebGPUBindGroup(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUBindGroup");
    publicAPI.setBindables = (bindables) => {
      if (model.bindables.length === bindables.length) {
        let allMatch = true;
        for (let i = 0; i < model.bindables.length; i++) {
          if (model.bindables[i] !== bindables[i]) {
            allMatch = false;
          }
        }
        if (allMatch) {
          return;
        }
      }
      model.bindables = bindables;
      publicAPI.modified();
    };
    publicAPI.getBindGroupLayout = (device) => {
      const entries = [];
      for (let i = 0; i < model.bindables.length; i++) {
        const entry = model.bindables[i].getBindGroupLayoutEntry();
        entry.binding = i;
        entries.push(entry);
      }
      return device.getBindGroupLayout({
        entries
      });
    };
    publicAPI.getBindGroup = (device) => {
      let mtime = publicAPI.getMTime();
      for (let i = 0; i < model.bindables.length; i++) {
        const tm = model.bindables[i].getBindGroupTime().getMTime();
        mtime = tm > mtime ? tm : mtime;
      }
      if (mtime < model.bindGroupTime.getMTime()) {
        return model.bindGroup;
      }
      const entries = [];
      for (let i = 0; i < model.bindables.length; i++) {
        const entry = model.bindables[i].getBindGroupEntry();
        entry.binding = i;
        entries.push(entry);
      }
      model.bindGroup = device.getHandle().createBindGroup({
        layout: publicAPI.getBindGroupLayout(device),
        entries,
        label: model.label
      });
      model.bindGroupTime.modified();
      return model.bindGroup;
    };
    publicAPI.getShaderCode = (pipeline) => {
      const lines = [];
      const bgroup = pipeline.getBindGroupLayoutCount(model.label);
      for (let i = 0; i < model.bindables.length; i++) {
        lines.push(model.bindables[i].getShaderCode(i, bgroup));
      }
      return lines.join("\n");
    };
  }
  var DEFAULT_VALUES61 = {
    device: null,
    handle: null,
    label: null
  };
  function extend63(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES61, initialValues);
    macro.obj(publicAPI, model);
    model.bindables = [];
    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });
    macro.get(publicAPI, model, ["bindGroupTime", "handle", "sizeInBytes", "usage"]);
    macro.setGet(publicAPI, model, ["label", "device", "arrayInformation"]);
    vtkWebGPUBindGroup(publicAPI, model);
  }
  var newInstance63 = macro.newInstance(extend63);
  var vtkWebGPUBindGroup$1 = {
    newInstance: newInstance63,
    extend: extend63
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Pipeline.js
  function vtkWebGPUPipeline(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUPipeline");
    publicAPI.getShaderDescriptions = () => model.shaderDescriptions;
    publicAPI.initialize = (device, hash) => {
      model.pipelineDescription = model.renderEncoder.getPipelineSettings();
      model.pipelineDescription.primitive.topology = model.topology;
      model.pipelineDescription.vertex = model.vertexState;
      model.pipelineDescription.label = hash;
      const bindGroupLayouts = [];
      for (let i = 0; i < model.layouts.length; i++) {
        bindGroupLayouts.push(model.layouts[i].layout);
      }
      model.pipelineLayout = device.getHandle().createPipelineLayout({
        bindGroupLayouts
      });
      model.pipelineDescription.layout = model.pipelineLayout;
      for (let i = 0; i < model.shaderDescriptions.length; i++) {
        const sd = model.shaderDescriptions[i];
        const sm = device.getShaderModule(sd);
        if (sd.getType() === "vertex") {
          model.pipelineDescription.vertex.module = sm.getHandle();
          model.pipelineDescription.vertex.entryPoint = "main";
        }
        if (sd.getType() === "fragment") {
          model.pipelineDescription.fragment.module = sm.getHandle();
          model.pipelineDescription.fragment.entryPoint = "main";
        }
      }
      model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
    };
    publicAPI.getShaderDescription = (stype) => {
      for (let i = 0; i < model.shaderDescriptions.length; i++) {
        if (model.shaderDescriptions[i].getType() === stype) return model.shaderDescriptions[i];
      }
      return null;
    };
    publicAPI.addBindGroupLayout = (bindGroup) => {
      if (!bindGroup) {
        return;
      }
      model.layouts.push({
        layout: bindGroup.getBindGroupLayout(model.device),
        label: bindGroup.getLabel()
      });
    };
    publicAPI.getBindGroupLayout = (idx) => model.layouts[idx].layout;
    publicAPI.getBindGroupLayoutCount = (llabel) => {
      for (let i = 0; i < model.layouts.length; i++) {
        if (model.layouts[i].label === llabel) {
          return i;
        }
      }
      return 0;
    };
    publicAPI.bindVertexInput = (renderEncoder, vInput) => {
      vInput.bindBuffers(renderEncoder);
    };
  }
  var DEFAULT_VALUES62 = {
    handle: null,
    layouts: null,
    renderEncoder: null,
    shaderDescriptions: null,
    vertexState: null,
    topology: null,
    pipelineDescription: null
  };
  function extend64(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES62, initialValues);
    obj(publicAPI, model);
    model.layouts = [];
    model.shaderDescriptions = [];
    get(publicAPI, model, ["handle", "pipelineDescription"]);
    setGet(publicAPI, model, ["device", "renderEncoder", "topology", "vertexState"]);
    vtkWebGPUPipeline(publicAPI, model);
  }
  var newInstance64 = newInstance(extend64, "vtkWebGPUPipeline");
  var vtkWebGPUPipeline$1 = {
    newInstance: newInstance64,
    extend: extend64
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js
  function vtkWebGPUShaderDescription(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUShaderDescription");
    publicAPI.hasOutput = (name) => model.outputNames.includes(name);
    publicAPI.addOutput = function(type, name) {
      let interpolation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      model.outputTypes.push(type);
      model.outputNames.push(name);
      model.outputInterpolations.push(interpolation);
    };
    publicAPI.addBuiltinOutput = (type, name) => {
      model.builtinOutputTypes.push(type);
      model.builtinOutputNames.push(name);
    };
    publicAPI.addBuiltinInput = (type, name) => {
      model.builtinInputTypes.push(type);
      model.builtinInputNames.push(name);
    };
    publicAPI.replaceShaderCode = (priorStage, vertexInput) => {
      const inputImpl = [];
      let iodec = [];
      if (vertexInput) {
        inputImpl.push(vertexInput.getShaderCode());
      }
      if (priorStage || model.builtinInputNames.length) {
        const inputStruct = [];
        inputStruct.push(`struct ${model.type}Input
{`);
        if (priorStage) {
          const inputNames = priorStage.getOutputNamesByReference();
          const inputTypes = priorStage.getOutputTypesByReference();
          const inputInterpolations = priorStage.getOutputInterpolationsByReference();
          for (let i = 0; i < inputNames.length; i++) {
            if (inputInterpolations[i] !== void 0) {
              inputStruct.push(`  @location(${i}) @interpolate(${inputInterpolations[i]}) ${inputNames[i]} : ${inputTypes[i]},`);
            } else {
              inputStruct.push(`  @location(${i}) ${inputNames[i]} : ${inputTypes[i]},`);
            }
          }
        }
        for (let i = 0; i < model.builtinInputNames.length; i++) {
          inputStruct.push(`  ${model.builtinInputNames[i]} : ${model.builtinInputTypes[i]},`);
        }
        if (inputStruct.length > 1) {
          inputStruct.push("};");
          iodec = inputStruct;
          inputImpl[inputImpl.length - 1] += ",";
          inputImpl.push(`input: ${model.type}Input`);
        }
      }
      if (inputImpl.length) {
        model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Input", inputImpl).result;
      }
      if (model.outputNames.length + model.builtinOutputNames.length) {
        const outputStruct = [`struct ${model.type}Output
{`];
        for (let i = 0; i < model.outputNames.length; i++) {
          if (model.outputInterpolations[i] !== void 0) {
            outputStruct.push(`  @location(${i}) @interpolate(${model.outputInterpolations[i]}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
          } else {
            outputStruct.push(`  @location(${i}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
          }
        }
        for (let i = 0; i < model.builtinOutputNames.length; i++) {
          outputStruct.push(`  ${model.builtinOutputNames[i]} : ${model.builtinOutputTypes[i]},`);
        }
        outputStruct.push("};");
        iodec = iodec.concat(outputStruct);
        model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Output", [`-> ${model.type}Output`]).result;
      }
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Dec", iodec).result;
    };
  }
  var DEFAULT_VALUES63 = {
    type: null,
    // 'vertex' or 'fragment'
    hash: null,
    code: null,
    outputNames: null,
    outputTypes: null
  };
  function extend65(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES63, initialValues);
    model.outputNames = [];
    model.outputTypes = [];
    model.outputInterpolations = [];
    model.builtinOutputNames = [];
    model.builtinOutputTypes = [];
    model.builtinInputNames = [];
    model.builtinInputTypes = [];
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["type", "hash", "code"]);
    macro.getArray(publicAPI, model, ["outputTypes", "outputNames", "outputInterpolations"]);
    vtkWebGPUShaderDescription(publicAPI, model);
  }
  var newInstance65 = macro.newInstance(extend65, "vtkWebGPUShaderDescription");
  var vtkWebGPUShaderDescription$1 = {
    newInstance: newInstance65,
    extend: extend65
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
  var textureDetails = {
    // 8-bit formats
    r8unorm: {
      numComponents: 1,
      nativeType: Uint8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "float"
    },
    r8snorm: {
      numComponents: 1,
      nativeType: Int8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "float"
    },
    r8uint: {
      numComponents: 1,
      nativeType: Uint8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "uint"
    },
    r8sint: {
      numComponents: 1,
      nativeType: Int8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "sint"
    },
    // 16-bit formats
    r16uint: {
      numComponents: 1,
      nativeType: Uint16Array,
      stride: 2,
      elementSize: 2,
      sampleType: "uint"
    },
    r16sint: {
      numComponents: 1,
      nativeType: Int16Array,
      stride: 2,
      elementSize: 2,
      sampleType: "sint"
    },
    r16float: {
      numComponents: 1,
      nativeType: Float32Array,
      stride: 2,
      elementSize: 2,
      sampleType: "float"
    },
    rg8unorm: {
      numComponents: 2,
      nativeType: Uint8Array,
      stride: 2,
      elementSize: 1,
      sampleType: "float"
    },
    rg8snorm: {
      numComponents: 2,
      nativeType: Int8Array,
      stride: 2,
      elementSize: 1,
      sampleType: "float"
    },
    rg8uint: {
      numComponents: 2,
      nativeType: Uint8Array,
      stride: 2,
      elementSize: 1,
      sampleType: "uint"
    },
    rg8sint: {
      numComponents: 2,
      nativeType: Int8Array,
      stride: 2,
      elementSize: 1,
      sampleType: "sint"
    },
    // 32-bit formats
    r32uint: {
      numComponents: 1,
      nativeType: Uint32Array,
      stride: 4,
      elementSize: 4,
      sampleType: "uint"
    },
    r32sint: {
      numComponents: 1,
      nativeType: Int32Array,
      stride: 4,
      elementSize: 4,
      sampleType: "sint"
    },
    r32float: {
      numComponents: 1,
      nativeType: Float32Array,
      stride: 4,
      elementSize: 4,
      sampleType: "unfilterable-float"
    },
    rg16uint: {
      numComponents: 2,
      nativeType: Uint16Array,
      stride: 4,
      elementSize: 2,
      sampleType: "uint"
    },
    rg16sint: {
      numComponents: 2,
      nativeType: Int16Array,
      stride: 4,
      elementSize: 2,
      sampleType: "sint"
    },
    rg16float: {
      numComponents: 2,
      nativeType: Float32Array,
      stride: 4,
      elementSize: 2,
      sampleType: "float"
    },
    rgba8unorm: {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    "rgba8unorm-srgb": {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    rgba8snorm: {
      numComponents: 4,
      nativeType: Int8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    rgba8uint: {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "uint"
    },
    rgba8sint: {
      numComponents: 4,
      nativeType: Int8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "sint"
    },
    bgra8unorm: {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    "bgra8unorm-srgb": {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    // Packed 32-bit formats
    rgb9e5ufloat: {
      numComponents: 4,
      nativeType: Uint32Array,
      stride: 4,
      sampleType: "float"
    },
    rgb10a2unorm: {
      numComponents: 4,
      nativeType: Uint32Array,
      stride: 4,
      sampleType: "float"
    },
    rg11b10ufloat: {
      numComponents: 4,
      nativeType: Float32Array,
      stride: 4,
      sampleType: "float"
    },
    // 64-bit formats
    rg32uint: {
      numComponents: 2,
      nativeType: Uint32Array,
      stride: 8,
      elementSize: 4,
      sampleType: "uint"
    },
    rg32sint: {
      numComponents: 2,
      nativeType: Int32Array,
      stride: 8,
      elementSize: 4,
      sampleType: "sint"
    },
    rg32float: {
      numComponents: 2,
      nativeType: Float32Array,
      stride: 8,
      elementSize: 4,
      sampleType: "unfilterable-float"
    },
    rgba16uint: {
      numComponents: 4,
      nativeType: Uint16Array,
      stride: 8,
      elementSize: 2,
      sampleType: "uint"
    },
    rgba16sint: {
      numComponents: 4,
      nativeType: Int16Array,
      stride: 8,
      elementSize: 2,
      sampleType: "sint"
    },
    rgba16float: {
      numComponents: 4,
      nativeType: Float32Array,
      stride: 8,
      elementSize: 2,
      sampleType: "float"
    },
    // 128-bit formats
    rgba32uint: {
      numComponents: 4,
      nativeType: Uint32Array,
      stride: 16,
      elementSize: 4,
      sampleType: "uint"
    },
    rgba32sint: {
      numComponents: 4,
      nativeType: Int32Array,
      stride: 16,
      elementSize: 4,
      sampleType: "sint"
    },
    rgba32float: {
      numComponents: 4,
      nativeType: Float32Array,
      stride: 16,
      elementSize: 4,
      sampleType: "unfilterable-float"
    },
    // Depth and stencil formats
    stencil8: {
      numComponents: 1,
      nativeType: Uint8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "uint"
    },
    depth16unorm: {
      numComponents: 1,
      nativeType: Uint16Array,
      stride: 2,
      elementSize: 2,
      sampleType: "depth"
    },
    depth24plus: {
      numComponents: 1,
      nativeType: Uint32Array,
      stride: 4,
      elementSize: 3,
      sampleType: "depth"
    },
    "depth24plus-stencil8": {
      numComponents: 2,
      nativeType: Uint32Array,
      stride: 4,
      sampleType: "mixed"
    },
    depth32float: {
      numComponents: 1,
      nativeType: Float32Array,
      stride: 4,
      elementSize: 4,
      sampleType: "depth"
    }
  };
  function getDetailsFromTextureFormat(format2) {
    if (!format2 || format2.length < 6) return 0;
    if (format2 in textureDetails === true) {
      return textureDetails[format2];
    }
    vtkErrorMacro2(`unknown format ${format2}`);
    return null;
  }
  function getByteStrideFromBufferFormat(format2) {
    if (!format2 || format2.length < 5) return 0;
    let numComp = 1;
    if (format2[format2.length - 2] === "x") {
      numComp = Number(format2[format2.length - 1]);
    }
    const sizeStart = numComp === 1 ? format2.length - 1 : format2.length - 3;
    const num = Number(format2[sizeStart]);
    if (Number.isNaN(num)) {
      vtkErrorMacro2(`unknown format ${format2}`);
      return 0;
    }
    const typeSize = 5 - num / 2;
    return numComp * typeSize;
  }
  function getNumberOfComponentsFromBufferFormat(format2) {
    if (!format2 || format2.length < 5) return 0;
    let numComp = 1;
    if (format2[format2.length - 2] === "x") {
      numComp = Number(format2[format2.length - 1]);
    }
    return numComp;
  }
  function getNativeTypeFromBufferFormat(format2) {
    if (!format2 || format2.length < 5) return 0;
    let result;
    if (format2[0] === "f") {
      result = "Float";
    } else if (format2[0] === "s") {
      result = "Int";
    } else if (format2[0] === "u") {
      result = "Uint";
    } else {
      vtkErrorMacro2(`unknown format ${format2}`);
      return void 0;
    }
    const base = format2.split("x")[0];
    const num = Number(base[base.length - 1]);
    if (Number.isNaN(num)) {
      vtkErrorMacro2(`unknown format ${format2}`);
      return void 0;
    }
    result += 8 * (5 - num / 2);
    result += "Array";
    return result;
  }
  function getShaderTypeFromBufferFormat(format2) {
    let dataType;
    if (format2[0] === "f" || format2[1] === "n") {
      dataType = "f32";
    } else if (format2[0] === "s" && format2[1] === "i") {
      dataType = "i32";
    } else if (format2[0] === "u" && format2[1] === "i") {
      dataType = "u32";
    } else {
      vtkErrorMacro2(`unknown format ${format2}`);
      return void 0;
    }
    let numComp = 1;
    if (format2[format2.length - 2] === "x") {
      numComp = Number(format2[format2.length - 1]);
    }
    if (numComp === 4) return `vec4<${dataType}>`;
    if (numComp === 3) return `vec3<${dataType}>`;
    if (numComp === 2) return `vec2<${dataType}>`;
    return dataType;
  }
  function getByteStrideFromShaderFormat(format2) {
    if (!format2) return 0;
    let numComp = 1;
    if (format2.substring(0, 3) === "vec") {
      numComp = Number(format2[3]);
    } else if (format2.substring(0, 3) === "mat") {
      numComp = format2[3] * format2[5];
    }
    const typeSize = 4;
    return numComp * typeSize;
  }
  function getNativeTypeFromShaderFormat(format2) {
    if (!format2) return void 0;
    if (format2.includes("f32")) return "Float32Array";
    if (format2.includes("i32")) return "Int32Array";
    if (format2.includes("u32")) return "Uint32Array";
    vtkErrorMacro2(`unknown format ${format2}`);
    return void 0;
  }
  var vtkWebGPUTypes = {
    getDetailsFromTextureFormat,
    getByteStrideFromBufferFormat,
    getNumberOfComponentsFromBufferFormat,
    getNativeTypeFromBufferFormat,
    getShaderTypeFromBufferFormat,
    getByteStrideFromShaderFormat,
    getNativeTypeFromShaderFormat
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js
  function arraysEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; ++i) {
      if (!b.includes(a[i])) return false;
    }
    return true;
  }
  function vtkWebGPUVertexInput(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUVertexInput");
    publicAPI.addBuffer = function(buffer, inames) {
      let stepMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "vertex";
      let names = inames;
      if (!Array.isArray(names)) {
        names = [names];
      }
      for (let i = 0; i < model.inputs.length; i++) {
        if (arraysEqual(model.inputs[i].names, names)) {
          if (model.inputs[i].buffer === buffer) {
            return;
          }
          model.inputs[i].buffer = buffer;
          return;
        }
      }
      model.inputs.push({
        buffer,
        stepMode,
        names
      });
      model.inputs = model.inputs.sort((v1, v2) => {
        if (v1.names[0] < v2.names[0]) {
          return -1;
        }
        if (v1.names[0] > v2.names[0]) {
          return 1;
        }
        return 0;
      });
    };
    publicAPI.removeBufferIfPresent = (name) => {
      for (let i = 0; i < model.inputs.length; i++) {
        if (model.inputs[i].names.includes(name)) {
          model.inputs.splice(i, 1);
        }
      }
    };
    publicAPI.getBuffer = (name) => {
      for (let i = 0; i < model.inputs.length; i++) {
        if (model.inputs[i].names.includes(name)) {
          return model.inputs[i].buffer;
        }
      }
      return null;
    };
    publicAPI.hasAttribute = (name) => {
      for (let i = 0; i < model.inputs.length; i++) {
        if (model.inputs[i].names.includes(name)) {
          return true;
        }
      }
      return false;
    };
    publicAPI.getAttributeTime = (name) => {
      for (let i = 0; i < model.inputs.length; i++) {
        if (model.inputs[i].names.includes(name)) {
          return model.inputs[i].buffer.getSourceTime();
        }
      }
      return 0;
    };
    publicAPI.getShaderCode = () => {
      let result = "";
      let nameCount = 0;
      for (let i = 0; i < model.inputs.length; i++) {
        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
          const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];
          const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);
          if (nameCount > 0) {
            result += ",\n";
          }
          result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;
          nameCount++;
        }
      }
      return result;
    };
    publicAPI.getVertexInputInformation = () => {
      const info = {};
      if (model.inputs.length) {
        const vertexBuffers = [];
        let nameCount = 0;
        for (let i = 0; i < model.inputs.length; i++) {
          const buf = model.inputs[i].buffer;
          const buffer = {
            arrayStride: buf.getStrideInBytes(),
            stepMode: model.inputs[i].stepMode,
            attributes: []
          };
          const arrayInfo = buf.getArrayInformation();
          for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
            buffer.attributes.push({
              shaderLocation: nameCount,
              offset: arrayInfo[nm].offset,
              format: arrayInfo[nm].format
            });
            nameCount++;
          }
          vertexBuffers.push(buffer);
        }
        info.buffers = vertexBuffers;
      }
      return info;
    };
    publicAPI.bindBuffers = (renderEncoder) => {
      for (let i = 0; i < model.inputs.length; i++) {
        renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());
      }
      if (model.indexBuffer) {
        renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);
      }
    };
    publicAPI.getReady = () => {
    };
    publicAPI.releaseGraphicsResources = () => {
      if (model.created) {
        model.inputs = [];
        model.bindingDescriptions = [];
        model.attributeDescriptions = [];
      }
    };
  }
  var DEFAULT_VALUES64 = {
    inputs: null,
    bindingDescriptions: false,
    attributeDescriptions: null,
    indexBuffer: null
  };
  function extend66(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES64, initialValues);
    obj(publicAPI, model);
    model.bindingDescriptions = [];
    model.attributeDescriptions = [];
    model.inputs = [];
    setGet(publicAPI, model, ["created", "device", "handle", "indexBuffer"]);
    vtkWebGPUVertexInput(publicAPI, model);
  }
  var newInstance66 = newInstance(extend66, "vtkWebGPUVertexInput");
  var vtkWebGPUVertexInput$1 = {
    newInstance: newInstance66,
    extend: extend66
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js
  var vtkWebGPUSimpleMapperVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  // var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
  var vtkWebGPUSimpleMapperFS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::Light::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  function vtkWebGPUSimpleMapper(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUSimpleMapper");
    publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {
      const vDesc = vtkWebGPUShaderDescription$1.newInstance({
        type: "vertex",
        hash,
        code: model.vertexShaderTemplate
      });
      const fDesc = vtkWebGPUShaderDescription$1.newInstance({
        type: "fragment",
        hash,
        code: model.fragmentShaderTemplate
      });
      const sdrs = pipeline.getShaderDescriptions();
      sdrs.push(vDesc);
      sdrs.push(fDesc);
      const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
      const re2 = new RegExp("//VTK::[^:]*::", "g");
      const unique = scode.match(re2).filter((v, i, a) => a.indexOf(v) === i);
      const fnames = unique.map((v) => `replaceShader${v.substring(7, v.length - 2)}`);
      for (let i = 0; i < fnames.length; i++) {
        const fname = fnames[i];
        if (fname !== "replaceShaderIOStructs" && model.shaderReplacements.has(fname)) {
          model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
        }
      }
      publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);
    };
    publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription("vertex");
      vDesc.replaceShaderCode(null, vertexInput);
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.replaceShaderCode(vDesc);
    };
    publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {
      model.renderEncoder.replaceShaderCode(pipeline);
    };
    model.shaderReplacements.set("replaceShaderRenderEncoder", publicAPI.replaceShaderRenderEncoder);
    publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {
      if (!model.WebGPURenderer) {
        return;
      }
      const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
      const vDesc = pipeline.getShaderDescription("vertex");
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription("fragment");
      code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
      fDesc.setCode(code);
    };
    model.shaderReplacements.set("replaceShaderRenderer", publicAPI.replaceShaderRenderer);
    publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {
      const ubocode = model.bindGroup.getShaderCode(pipeline);
      const vDesc = pipeline.getShaderDescription("vertex");
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addBuiltinInput("bool", "@builtin(front_facing) frontFacing");
      code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
      fDesc.setCode(code);
    };
    model.shaderReplacements.set("replaceShaderMapper", publicAPI.replaceShaderMapper);
    publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription("vertex");
      vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result;
      vDesc.setCode(code);
    };
    model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
    publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription("vertex");
      vDesc.addOutput("vec2<f32>", "tcoordVS");
    };
    model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
    publicAPI.addTextureView = (view) => {
      if (model.textureViews.includes(view)) {
        return;
      }
      model.textureViews.push(view);
    };
    publicAPI.prepareToDraw = (renderEncoder) => {
      model.renderEncoder = renderEncoder;
      publicAPI.updateInput();
      publicAPI.updateBuffers();
      publicAPI.updateBindings();
      publicAPI.updatePipeline();
    };
    publicAPI.updateInput = () => {
    };
    publicAPI.updateBuffers = () => {
    };
    publicAPI.updateBindings = () => {
      model.bindGroup.setBindables(publicAPI.getBindables());
    };
    publicAPI.computePipelineHash = () => {
    };
    publicAPI.registerDrawCallback = (encoder) => {
      encoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    };
    publicAPI.prepareAndDraw = (encoder) => {
      publicAPI.prepareToDraw(encoder);
      encoder.setPipeline(model.pipeline);
      publicAPI.draw(encoder);
    };
    publicAPI.draw = (renderEncoder) => {
      const pipeline = renderEncoder.getBoundPipeline();
      renderEncoder.activateBindGroup(model.bindGroup);
      if (model.WebGPURenderer) {
        model.WebGPURenderer.bindUBO(renderEncoder);
      }
      pipeline.bindVertexInput(renderEncoder, model.vertexInput);
      const indexBuffer = model.vertexInput.getIndexBuffer();
      if (indexBuffer) {
        renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);
      } else {
        renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
      }
    };
    publicAPI.getBindables = () => {
      const bindables = [...model.additionalBindables];
      if (model.UBO) {
        bindables.push(model.UBO);
      }
      if (model.SSBO) {
        bindables.push(model.SSBO);
      }
      for (let t = 0; t < model.textureViews.length; t++) {
        bindables.push(model.textureViews[t]);
        const samp = model.textureViews[t].getSampler();
        if (samp) {
          bindables.push(samp);
        }
      }
      return bindables;
    };
    publicAPI.updatePipeline = () => {
      publicAPI.computePipelineHash();
      model.pipeline = model.device.getPipeline(model.pipelineHash);
      if (!model.pipeline) {
        model.pipeline = vtkWebGPUPipeline$1.newInstance();
        model.pipeline.setDevice(model.device);
        if (model.WebGPURenderer) {
          model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
        }
        model.pipeline.addBindGroupLayout(model.bindGroup);
        publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
        model.pipeline.setTopology(model.topology);
        model.pipeline.setRenderEncoder(model.renderEncoder);
        model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
        model.device.createPipeline(model.pipelineHash, model.pipeline);
      }
    };
  }
  var DEFAULT_VALUES65 = {
    additionalBindables: void 0,
    bindGroup: null,
    device: null,
    fragmentShaderTemplate: null,
    numberOfInstances: 1,
    numberOfVertices: 0,
    pipelineHash: null,
    shaderReplacements: null,
    SSBO: null,
    textureViews: null,
    topology: "triangle-list",
    UBO: null,
    vertexShaderTemplate: null,
    WebGPURenderer: null
  };
  function extend67(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES65, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.textureViews = [];
    model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
    model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
      label: "mapperBG"
    });
    model.additionalBindables = [];
    model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;
    model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;
    model.shaderReplacements = /* @__PURE__ */ new Map();
    macro.get(publicAPI, model, ["pipeline", "vertexInput"]);
    macro.setGet(publicAPI, model, ["additionalBindables", "device", "fragmentShaderTemplate", "interpolate", "numberOfInstances", "numberOfVertices", "pipelineHash", "shaderReplacements", "SSBO", "textureViews", "topology", "UBO", "vertexShaderTemplate", "WebGPURenderer"]);
    vtkWebGPUSimpleMapper(publicAPI, model);
  }
  var newInstance67 = macro.newInstance(extend67, "vtkWebGPUSimpleMapper");
  var vtkWebGPUSimpleMapper$1 = {
    newInstance: newInstance67,
    extend: extend67
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
  function vtkWebGPUFullScreenQuad(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUFullScreenQuad");
    publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription("vertex");
      vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
      vDesc.addOutput("vec4<f32>", "vertexVC");
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);", "output.vertexVC = vec4<f32>(vertexBC, 1);"]).result;
      vDesc.setCode(code);
    };
    model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
    publicAPI.updateBuffers = () => {
      const buff = model.device.getBufferManager().getFullScreenQuadBuffer();
      model.vertexInput.addBuffer(buff, ["vertexBC"]);
      model.numberOfVertices = 6;
    };
  }
  var DEFAULT_VALUES66 = {};
  function extend68(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES66, initialValues);
    vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initialValues);
    vtkWebGPUFullScreenQuad(publicAPI, model);
  }
  var newInstance68 = macro.newInstance(extend68, "vtkWebGPUFullScreenQuad");
  var vtkWebGPUFullScreenQuad$1 = {
    newInstance: newInstance68,
    extend: extend68
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderEncoder.js
  var forwarded = ["setBindGroup", "setIndexBuffer", "setVertexBuffer", "draw", "drawIndexed"];
  function vtkWebGPURenderEncoder(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPURenderEncoder");
    publicAPI.begin = (encoder) => {
      model.drawCallbacks = [];
      model.handle = encoder.beginRenderPass(model.description);
      if (model.label) {
        model.handle.pushDebugGroup(model.label);
      }
    };
    publicAPI.end = () => {
      for (let i = 0; i < model.drawCallbacks.length; i++) {
        const pStruct = model.drawCallbacks[i];
        const pl = pStruct.pipeline;
        publicAPI.setPipeline(pl);
        for (let cb = 0; cb < pStruct.callbacks.length; cb++) {
          pStruct.callbacks[cb](publicAPI);
        }
      }
      if (model.label) {
        model.handle.popDebugGroup();
      }
      model.handle.end();
      model.boundPipeline = null;
    };
    publicAPI.setPipeline = (pl) => {
      if (model.boundPipeline === pl) {
        return;
      }
      model.handle.setPipeline(pl.getHandle());
      const pd = pl.getPipelineDescription();
      if (model.colorTextureViews.length !== pd.fragment.targets.length) {
        console.log(`mismatched attachment counts on pipeline ${pd.fragment.targets.length} while encoder has ${model.colorTextureViews.length}`);
        console.trace();
      } else {
        for (let i = 0; i < model.colorTextureViews.length; i++) {
          const fmt = model.colorTextureViews[i].getTexture()?.getFormat();
          if (fmt && fmt !== pd.fragment.targets[i].format) {
            console.log(`mismatched attachments for attachment ${i} on pipeline ${pd.fragment.targets[i].format} while encoder has ${fmt}`);
            console.trace();
          }
        }
      }
      if (!model.depthTextureView !== !("depthStencil" in pd)) {
        console.log("mismatched depth attachments");
        console.trace();
      } else if (model.depthTextureView) {
        const dfmt = model.depthTextureView.getTexture()?.getFormat();
        if (dfmt && dfmt !== pd.depthStencil.format) {
          console.log(`mismatched depth attachments on pipeline ${pd.depthStencil.format} while encoder has ${dfmt}`);
          console.trace();
        }
      }
      model.boundPipeline = pl;
    };
    publicAPI.replaceShaderCode = (pipeline) => {
      model.replaceShaderCodeFunction(pipeline);
    };
    publicAPI.setColorTextureView = (idx, view) => {
      if (model.colorTextureViews[idx] === view) {
        return;
      }
      model.colorTextureViews[idx] = view;
    };
    publicAPI.activateBindGroup = (bg) => {
      const device = model.boundPipeline.getDevice();
      const midx = model.boundPipeline.getBindGroupLayoutCount(bg.getLabel());
      model.handle.setBindGroup(midx, bg.getBindGroup(device));
      const bgl1 = device.getBindGroupLayoutDescription(bg.getBindGroupLayout(device));
      const bgl2 = device.getBindGroupLayoutDescription(model.boundPipeline.getBindGroupLayout(midx));
      if (bgl1 !== bgl2) {
        console.log(`renderEncoder ${model.pipelineHash} mismatched bind group layouts bind group has
${bgl1}
 versus pipeline
${bgl2}
`);
        console.trace();
      }
    };
    publicAPI.attachTextureViews = () => {
      for (let i = 0; i < model.colorTextureViews.length; i++) {
        if (!model.description.colorAttachments[i]) {
          model.description.colorAttachments[i] = {
            view: model.colorTextureViews[i].getHandle()
          };
        } else {
          model.description.colorAttachments[i].view = model.colorTextureViews[i].getHandle();
        }
      }
      if (model.depthTextureView) {
        model.description.depthStencilAttachment.view = model.depthTextureView.getHandle();
      }
    };
    publicAPI.registerDrawCallback = (pipeline, cb) => {
      for (let i = 0; i < model.drawCallbacks.length; i++) {
        if (model.drawCallbacks[i].pipeline === pipeline) {
          model.drawCallbacks[i].callbacks.push(cb);
          return;
        }
      }
      model.drawCallbacks.push({
        pipeline,
        callbacks: [cb]
      });
    };
    for (let i = 0; i < forwarded.length; i++) {
      publicAPI[forwarded[i]] = function() {
        return model.handle[forwarded[i]](...arguments);
      };
    }
  }
  var DEFAULT_VALUES67 = {
    description: null,
    handle: null,
    boundPipeline: null,
    pipelineHash: null,
    pipelineSettings: null,
    replaceShaderCodeFunction: null,
    depthTextureView: null,
    label: null
  };
  function extend69(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES67, initialValues);
    obj(publicAPI, model);
    model.description = {
      colorAttachments: [{
        view: void 0,
        loadOp: "load",
        storeOp: "store"
      }],
      depthStencilAttachment: {
        view: void 0,
        depthLoadOp: "clear",
        depthClearValue: 0,
        depthStoreOp: "store"
      }
    };
    model.replaceShaderCodeFunction = (pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = computedColor;"]).result;
      fDesc.setCode(code);
    };
    model.pipelineSettings = {
      primitive: {
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: "greater-equal",
        format: "depth32float"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    };
    model.colorTextureViews = [];
    get(publicAPI, model, ["boundPipeline", "colorTextureViews"]);
    setGet(publicAPI, model, ["depthTextureView", "description", "handle", "label", "pipelineHash", "pipelineSettings", "replaceShaderCodeFunction"]);
    vtkWebGPURenderEncoder(publicAPI, model);
  }
  var newInstance69 = newInstance(extend69, "vtkWebGPURenderEncoder");
  var vtkWebGPURenderEncoder$1 = {
    newInstance: newInstance69,
    extend: extend69
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
  function vtkWebGPUSampler(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUSampler");
    publicAPI.create = function(device) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      model.device = device;
      model.options.addressModeU = options.addressModeU ? options.addressModeU : "clamp-to-edge";
      model.options.addressModeV = options.addressModeV ? options.addressModeV : "clamp-to-edge";
      model.options.addressModeW = options.addressModeW ? options.addressModeW : "clamp-to-edge";
      model.options.magFilter = options.magFilter ? options.magFilter : "nearest";
      model.options.minFilter = options.minFilter ? options.minFilter : "nearest";
      model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : "nearest";
      model.options.label = model.label;
      model.handle = model.device.getHandle().createSampler(model.options);
      model.bindGroupTime.modified();
    };
    publicAPI.getShaderCode = (binding, group) => {
      const result = `@binding(${binding}) @group(${group}) var ${model.label}: sampler;`;
      return result;
    };
    publicAPI.getBindGroupEntry = () => {
      const foo = {
        resource: model.handle
      };
      return foo;
    };
  }
  var DEFAULT_VALUES68 = {
    device: null,
    handle: null,
    label: null,
    options: null
  };
  function extend70(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES68, initialValues);
    macro.obj(publicAPI, model);
    model.options = {};
    model.bindGroupLayoutEntry = {
      /* eslint-disable no-undef */
      visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
      /* eslint-enable no-undef */
      sampler: {
        // type: 'filtering',
      }
    };
    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });
    macro.get(publicAPI, model, ["bindGroupTime", "handle", "options"]);
    macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label"]);
    vtkWebGPUSampler(publicAPI, model);
  }
  var newInstance70 = macro.newInstance(extend70);
  var vtkWebGPUSampler$1 = {
    newInstance: newInstance70,
    extend: extend70
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureView.js
  function vtkWebGPUTextureView(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUTextureView");
    publicAPI.create = (texture, options) => {
      model.texture = texture;
      model.options = options;
      model.options.dimension = model.options.dimension || "2d";
      model.options.label = model.label;
      model.textureHandle = texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.texture.getFormat());
      model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
    };
    publicAPI.createFromTextureHandle = (textureHandle, options) => {
      model.texture = null;
      model.options = options;
      model.options.dimension = model.options.dimension || "2d";
      model.options.label = model.label;
      model.textureHandle = textureHandle;
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(options.format);
      model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
      model.bindGroupTime.modified();
    };
    publicAPI.getBindGroupEntry = () => {
      const foo = {
        resource: publicAPI.getHandle()
      };
      return foo;
    };
    publicAPI.getShaderCode = (binding, group) => {
      let ttype = "f32";
      if (model.bindGroupLayoutEntry.texture.sampleType === "sint") {
        ttype = "i32";
      } else if (model.bindGroupLayoutEntry.texture.sampleType === "uint") {
        ttype = "u32";
      }
      let result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_${model.options.dimension}<${ttype}>;`;
      if (model.bindGroupLayoutEntry.texture.sampleType === "depth") {
        result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_depth_${model.options.dimension};`;
      }
      return result;
    };
    publicAPI.addSampler = (device, options) => {
      const newSamp = vtkWebGPUSampler$1.newInstance({
        label: `${model.label}Sampler`
      });
      newSamp.create(device, options);
      publicAPI.setSampler(newSamp);
    };
    publicAPI.getBindGroupTime = () => {
      if (model.texture && model.texture.getHandle() !== model.textureHandle) {
        model.textureHandle = model.texture.getHandle();
        model.handle = model.textureHandle.createView(model.options);
        model.bindGroupTime.modified();
      }
      return model.bindGroupTime;
    };
    publicAPI.getHandle = () => {
      if (model.texture && model.texture.getHandle() !== model.textureHandle) {
        model.textureHandle = model.texture.getHandle();
        model.handle = model.textureHandle.createView(model.options);
        model.bindGroupTime.modified();
      }
      return model.handle;
    };
  }
  var DEFAULT_VALUES69 = {
    texture: null,
    handle: null,
    sampler: null,
    label: null
  };
  function extend71(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES69, initialValues);
    macro.obj(publicAPI, model);
    model.bindGroupLayoutEntry = {
      /* eslint-disable no-undef */
      visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
      /* eslint-enable no-undef */
      texture: {
        sampleType: "float",
        viewDimension: "2d"
        // multisampled: false,
      }
    };
    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });
    macro.get(publicAPI, model, ["bindGroupTime", "texture"]);
    macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "label", "sampler"]);
    vtkWebGPUTextureView(publicAPI, model);
  }
  var newInstance71 = macro.newInstance(extend71);
  var vtkWebGPUTextureView$1 = {
    newInstance: newInstance71,
    extend: extend71
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/Texture.js
  function vtkTexture(publicAPI, model) {
    model.classHierarchy.push("vtkTexture");
    publicAPI.imageLoaded = () => {
      model.image.removeEventListener("load", publicAPI.imageLoaded);
      model.imageLoaded = true;
      publicAPI.modified();
    };
    publicAPI.setJsImageData = (imageData) => {
      if (model.jsImageData === imageData) {
        return;
      }
      if (imageData !== null) {
        publicAPI.setInputData(null);
        publicAPI.setInputConnection(null);
        model.image = null;
        model.canvas = null;
        model.imageBitmap = null;
      }
      model.jsImageData = imageData;
      model.imageLoaded = true;
      publicAPI.modified();
    };
    publicAPI.setImageBitmap = (imageBitmap) => {
      if (model.imageBitmap === imageBitmap) {
        return;
      }
      if (imageBitmap !== null) {
        publicAPI.setInputData(null);
        publicAPI.setInputConnection(null);
        model.image = null;
        model.canvas = null;
        model.jsImageData = null;
      }
      model.imageBitmap = imageBitmap;
      model.imageLoaded = true;
      publicAPI.modified();
    };
    publicAPI.setCanvas = (canvas) => {
      if (model.canvas === canvas) {
        return;
      }
      if (canvas !== null) {
        publicAPI.setInputData(null);
        publicAPI.setInputConnection(null);
        model.image = null;
        model.imageBitmap = null;
        model.jsImageData = null;
      }
      model.canvas = canvas;
      publicAPI.modified();
    };
    publicAPI.setImage = (image) => {
      if (model.image === image) {
        return;
      }
      if (image !== null) {
        publicAPI.setInputData(null);
        publicAPI.setInputConnection(null);
        model.canvas = null;
        model.jsImageData = null;
        model.imageBitmap = null;
      }
      model.image = image;
      model.imageLoaded = false;
      if (image.complete) {
        publicAPI.imageLoaded();
      } else {
        image.addEventListener("load", publicAPI.imageLoaded);
      }
      publicAPI.modified();
    };
    publicAPI.getDimensionality = () => {
      let width = 0;
      let height = 0;
      let depth = 1;
      if (publicAPI.getInputData()) {
        const data = publicAPI.getInputData();
        width = data.getDimensions()[0];
        height = data.getDimensions()[1];
        depth = data.getDimensions()[2];
      }
      if (model.jsImageData) {
        width = model.jsImageData.width;
        height = model.jsImageData.height;
      }
      if (model.canvas) {
        width = model.canvas.width;
        height = model.canvas.height;
      }
      if (model.image) {
        width = model.image.width;
        height = model.image.height;
      }
      if (model.imageBitmap) {
        width = model.imageBitmap.width;
        height = model.imageBitmap.height;
      }
      const dimensionality = (width > 1) + (height > 1) + (depth > 1);
      return dimensionality;
    };
    publicAPI.getInputAsJsImageData = () => {
      if (!model.imageLoaded || publicAPI.getInputData()) return null;
      if (model.jsImageData) {
        return model.jsImageData;
      }
      if (model.imageBitmap) {
        return model.imageBitmap;
      }
      if (model.canvas) {
        const context = model.canvas.getContext("2d");
        const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);
        return imageData;
      }
      if (model.image) {
        const width = model.image.width;
        const height = model.image.height;
        const canvas = new OffscreenCanvas(width, height);
        const context = canvas.getContext("2d");
        context.translate(0, height);
        context.scale(1, -1);
        context.drawImage(model.image, 0, 0, width, height);
        const imageData = context.getImageData(0, 0, width, height);
        return imageData;
      }
      return null;
    };
  }
  var generateMipmaps = (device, texture, mipLevelCount) => {
    const computeShaderCode = `
    @group(0) @binding(0) var inputTexture: texture_2d<f32>;
    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let texelCoord = vec2<i32>(global_id.xy);
      let outputSize = textureDimensions(outputTexture);

      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {
        return;
      }

      let inputSize = textureDimensions(inputTexture);
      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);

      // Compute the floating-point source coordinate
      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;

      // Get integer coordinates for the four surrounding texels
      let x0 = i32(floor(srcCoord.x));
      let x1 = min(x0 + 1, i32(inputSize.x) - 1);
      let y0 = i32(floor(srcCoord.y));
      let y1 = min(y0 + 1, i32(inputSize.y) - 1);

      // Compute the weights
      let wx = srcCoord.x - f32(x0);
      let wy = srcCoord.y - f32(y0);

      // Fetch the four texels
      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);
      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);
      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);
      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);

      // Bilinear interpolation
      let color = mix(
        mix(c00, c10, wx),
        mix(c01, c11, wx),
        wy
      );

      textureStore(outputTexture, texelCoord, color);
    }
  `;
    const computeShader = device.createShaderModule({
      code: computeShaderCode
    });
    const bindGroupLayout = device.createBindGroupLayout({
      entries: [{
        binding: 0,
        // eslint-disable-next-line no-undef
        visibility: GPUShaderStage.COMPUTE,
        texture: {
          sampleType: "float"
        }
      }, {
        binding: 1,
        // eslint-disable-next-line no-undef
        visibility: GPUShaderStage.COMPUTE,
        storageTexture: {
          format: "rgba8unorm",
          access: "write-only"
        }
      }, {
        binding: 2,
        // eslint-disable-next-line no-undef
        visibility: GPUShaderStage.COMPUTE,
        sampler: {
          type: "filtering"
        }
      }]
    });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    const pipeline = device.createComputePipeline({
      label: "ComputeMipmapPipeline",
      layout: pipelineLayout,
      compute: {
        module: computeShader,
        entryPoint: "main"
      }
    });
    const sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear"
    });
    for (let mipLevel = 1; mipLevel < mipLevelCount; mipLevel++) {
      const srcView = texture.createView({
        baseMipLevel: mipLevel - 1,
        mipLevelCount: 1
      });
      const dstView = texture.createView({
        baseMipLevel: mipLevel,
        mipLevelCount: 1
      });
      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [{
          binding: 0,
          resource: srcView
        }, {
          binding: 1,
          resource: dstView
        }, {
          binding: 2,
          resource: sampler
        }]
      });
      const commandEncoder = device.createCommandEncoder({
        label: `MipmapGenerateCommandEncoder`
      });
      const computePass = commandEncoder.beginComputePass();
      computePass.setPipeline(pipeline);
      computePass.setBindGroup(0, bindGroup);
      const mipWidth = Math.max(1, texture.width >> mipLevel);
      const mipHeight = Math.max(1, texture.height >> mipLevel);
      const workgroupsX = Math.ceil(mipWidth / 8);
      const workgroupsY = Math.ceil(mipHeight / 8);
      computePass.dispatchWorkgroups(workgroupsX, workgroupsY);
      computePass.end();
      device.queue.submit([commandEncoder.finish()]);
    }
  };
  var DEFAULT_VALUES70 = {
    image: null,
    canvas: null,
    jsImageData: null,
    imageBitmap: null,
    imageLoaded: false,
    repeat: false,
    interpolate: false,
    edgeClamp: false,
    mipLevel: 0,
    resizable: false
    // must be set at construction time if the texture can be resizable
  };
  function extend72(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES70, initialValues);
    macro.obj(publicAPI, model);
    macro.algo(publicAPI, model, 6, 0);
    macro.get(publicAPI, model, ["canvas", "image", "jsImageData", "imageBitmap", "imageLoaded", "resizable"]);
    macro.setGet(publicAPI, model, ["repeat", "edgeClamp", "interpolate", "mipLevel"]);
    vtkTexture(publicAPI, model);
  }
  var newInstance72 = macro.newInstance(extend72, "vtkTexture");
  var STATIC12 = {
    generateMipmaps
  };
  var vtkTexture$1 = {
    newInstance: newInstance72,
    extend: extend72,
    ...STATIC12
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Texture.js
  function vtkWebGPUTexture(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUTexture");
    publicAPI.create = (device, options) => {
      model.device = device;
      model.width = options.width;
      model.height = options.height;
      model.depth = options.depth ? options.depth : 1;
      const dimension = model.depth === 1 ? "2d" : "3d";
      model.format = options.format ? options.format : "rgba8unorm";
      model.mipLevel = options.mipLevel ? options.mipLevel : 0;
      model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        // 'rgba8unorm',
        usage: model.usage,
        label: model.label,
        dimension,
        mipLevelCount: model.mipLevel + 1
      });
    };
    publicAPI.assignFromHandle = (device, handle, options) => {
      model.device = device;
      model.handle = handle;
      model.width = options.width;
      model.height = options.height;
      model.depth = options.depth ? options.depth : 1;
      model.format = options.format ? options.format : "rgba8unorm";
      model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    };
    publicAPI.writeImageData = (req) => {
      let nativeArray = [];
      const _copyImageToTexture = (source) => {
        model.device.getHandle().queue.copyExternalImageToTexture({
          source,
          flipY: req.flip
        }, {
          texture: model.handle,
          premultipliedAlpha: true,
          mipLevel: 0,
          origin: {
            x: 0,
            y: 0,
            z: 0
          }
        }, [source.width, source.height, model.depth]);
        if (publicAPI.getDimensionality() !== 3 && model.mipLevel > 0) {
          vtkTexture$1.generateMipmaps(model.device.getHandle(), model.handle, model.mipLevel + 1);
        }
        model.ready = true;
      };
      if (req.canvas) {
        _copyImageToTexture(req.canvas);
        return;
      }
      if (req.imageBitmap) {
        req.width = req.imageBitmap.width;
        req.height = req.imageBitmap.height;
        req.depth = 1;
        req.format = "rgba8unorm";
        req.flip = true;
        _copyImageToTexture(req.imageBitmap);
        return;
      }
      if (req.jsImageData) {
        req.width = req.jsImageData.width;
        req.height = req.jsImageData.height;
        req.depth = 1;
        req.format = "rgba8unorm";
        req.flip = true;
        _copyImageToTexture(req.jsImageData);
        return;
      }
      if (req.image) {
        req.width = req.image.width;
        req.height = req.image.height;
        req.depth = 1;
        req.format = "rgba8unorm";
        req.flip = true;
        _copyImageToTexture(req.image);
        return;
      }
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
      let bufferBytesPerRow = model.width * tDetails.stride;
      const alignTextureData = (arr, height, depth) => {
        const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
        const bytesPerElement = arr.BYTES_PER_ELEMENT;
        const inWidthInBytes = arr.length / (height * depth) * bytesPerElement;
        if (!halfFloat && inWidthInBytes % 256 === 0) {
          return [arr, inWidthInBytes];
        }
        const inWidth = inWidthInBytes / bytesPerElement;
        const outBytesPerElement = tDetails.elementSize;
        const outWidthInBytes = 256 * Math.floor((inWidth * outBytesPerElement + 255) / 256);
        const outWidth = outWidthInBytes / outBytesPerElement;
        const outArray = macro.newTypedArray(halfFloat ? "Uint16Array" : arr.constructor.name, outWidth * height * depth);
        const totalRows = height * depth;
        if (halfFloat) {
          for (let v = 0; v < totalRows; v++) {
            const inOffset = v * inWidth;
            const outOffset = v * outWidth;
            for (let i = 0; i < inWidth; i++) {
              outArray[outOffset + i] = HalfFloat.toHalf(arr[inOffset + i]);
            }
          }
        } else if (outWidth === inWidth) {
          outArray.set(arr);
        } else {
          for (let v = 0; v < totalRows; v++) {
            outArray.set(arr.subarray(v * inWidth, (v + 1) * inWidth), v * outWidth);
          }
        }
        return [outArray, outWidthInBytes];
      };
      if (req.nativeArray) {
        nativeArray = req.nativeArray;
      }
      const is3D = publicAPI.getDimensionality() === 3;
      const alignedTextureData = alignTextureData(nativeArray, model.height, is3D ? model.depth : 1);
      bufferBytesPerRow = alignedTextureData[1];
      const data = alignedTextureData[0];
      model.device.getHandle().queue.writeTexture({
        texture: model.handle,
        mipLevel: 0,
        origin: {
          x: 0,
          y: 0,
          z: 0
        }
      }, data, {
        offset: 0,
        bytesPerRow: bufferBytesPerRow,
        rowsPerImage: model.height
      }, {
        width: model.width,
        height: model.height,
        depthOrArrayLayers: is3D ? model.depth : 1
      });
      if (!is3D && model.mipLevel > 0) {
        vtkTexture$1.generateMipmaps(model.device.getHandle(), model.handle, model.mipLevel + 1);
      }
      model.ready = true;
    };
    publicAPI.getScale = () => {
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
      return halfFloat ? 1 : 255;
    };
    publicAPI.getNumberOfComponents = () => {
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
      return tDetails.numComponents;
    };
    publicAPI.getDimensionality = () => {
      let dims = 0;
      if (model.width > 1) dims++;
      if (model.height > 1) dims++;
      if (model.depth > 1) dims++;
      return dims;
    };
    publicAPI.resizeToMatch = (tex) => {
      if (tex.getWidth() !== model.width || tex.getHeight() !== model.height || tex.getDepth() !== model.depth) {
        model.width = tex.getWidth();
        model.height = tex.getHeight();
        model.depth = tex.getDepth();
        model.handle = model.device.getHandle().createTexture({
          size: [model.width, model.height, model.depth],
          format: model.format,
          usage: model.usage,
          label: model.label
        });
      }
    };
    publicAPI.resize = function(width, height) {
      let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      if (width !== model.width || height !== model.height || depth !== model.depth) {
        model.width = width;
        model.height = height;
        model.depth = depth;
        model.handle = model.device.getHandle().createTexture({
          size: [model.width, model.height, model.depth],
          format: model.format,
          usage: model.usage,
          label: model.label
        });
      }
    };
    publicAPI.createView = function(label) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!options.dimension) {
        options.dimension = model.depth === 1 ? "2d" : "3d";
      }
      const view = vtkWebGPUTextureView$1.newInstance({
        label
      });
      view.create(publicAPI, options);
      return view;
    };
  }
  var DEFAULT_VALUES71 = {
    device: null,
    handle: null,
    buffer: null,
    ready: false,
    label: null
  };
  function extend73(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES71, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["handle", "ready", "width", "height", "depth", "format", "usage"]);
    macro.setGet(publicAPI, model, ["device", "label"]);
    vtkWebGPUTexture(publicAPI, model);
  }
  var newInstance73 = macro.newInstance(extend73);
  var vtkWebGPUTexture$1 = {
    newInstance: newInstance73,
    extend: extend73
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/OpaquePass.js
  function vtkWebGPUOpaquePass(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUOpaquePass");
    publicAPI.traverse = (renNode, viewNode) => {
      if (model.deleted) {
        return;
      }
      model._currentParent = viewNode;
      const device = viewNode.getDevice();
      if (!model.renderEncoder) {
        publicAPI.createRenderEncoder();
        model.colorTexture = vtkWebGPUTexture$1.newInstance({
          label: "opaquePassColor"
        });
        model.colorTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: "rgba16float",
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
        });
        const ctView = model.colorTexture.createView("opaquePassColorTexture");
        model.renderEncoder.setColorTextureView(0, ctView);
        model.depthFormat = "depth32float";
        model.depthTexture = vtkWebGPUTexture$1.newInstance({
          label: "opaquePassDepth"
        });
        model.depthTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: model.depthFormat,
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
        });
        const dView = model.depthTexture.createView("opaquePassDepthTexture");
        model.renderEncoder.setDepthTextureView(dView);
      } else {
        model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
        model.depthTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      }
      model.renderEncoder.attachTextureViews();
      publicAPI.setCurrentOperation("opaquePass");
      renNode.setRenderEncoder(model.renderEncoder);
      renNode.traverse(publicAPI);
    };
    publicAPI.getColorTextureView = () => model.renderEncoder.getColorTextureViews()[0];
    publicAPI.getDepthTextureView = () => model.renderEncoder.getDepthTextureView();
    publicAPI.createRenderEncoder = () => {
      model.renderEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: "OpaquePass"
      });
      model.renderEncoder.setPipelineHash("op");
    };
  }
  var DEFAULT_VALUES72 = {
    renderEncoder: null,
    colorTexture: null,
    depthTexture: null
  };
  function extend74(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES72, initialValues);
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ["colorTexture", "depthTexture"]);
    vtkWebGPUOpaquePass(publicAPI, model);
  }
  var newInstance74 = macro.newInstance(extend74, "vtkWebGPUOpaquePass");
  var vtkWebGPUOpaquePass$1 = {
    newInstance: newInstance74,
    extend: extend74
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/OrderIndependentTranslucentPass.js
  var oitpFragTemplate2 = `
//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));
  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;
  if (reveal == 1.0) { discard; }
  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);
  var total: f32 = max(tcolor.a, 0.01);
  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  function vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass");
    publicAPI.traverse = (renNode, viewNode) => {
      if (model.deleted) {
        return;
      }
      model._currentParent = viewNode;
      const device = viewNode.getDevice();
      if (!model.translucentRenderEncoder) {
        publicAPI.createRenderEncoder();
        publicAPI.createFinalEncoder();
        model.translucentColorTexture = vtkWebGPUTexture$1.newInstance({
          label: "translucentPassColor"
        });
        model.translucentColorTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: "rgba16float",
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
        });
        const v1 = model.translucentColorTexture.createView("oitpColorTexture");
        model.translucentRenderEncoder.setColorTextureView(0, v1);
        model.translucentAccumulateTexture = vtkWebGPUTexture$1.newInstance({
          label: "translucentPassAccumulate"
        });
        model.translucentAccumulateTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: "r16float",
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
        });
        const v2 = model.translucentAccumulateTexture.createView("oitpAccumTexture");
        model.translucentRenderEncoder.setColorTextureView(1, v2);
        model.fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
        model.fullScreenQuad.setDevice(viewNode.getDevice());
        model.fullScreenQuad.setPipelineHash("oitpfsq");
        model.fullScreenQuad.setTextureViews(model.translucentRenderEncoder.getColorTextureViews());
        model.fullScreenQuad.setFragmentShaderTemplate(oitpFragTemplate2);
      } else {
        model.translucentColorTexture.resizeToMatch(model.colorTextureView.getTexture());
        model.translucentAccumulateTexture.resizeToMatch(model.colorTextureView.getTexture());
      }
      model.translucentRenderEncoder.setDepthTextureView(model.depthTextureView);
      model.translucentRenderEncoder.attachTextureViews();
      publicAPI.setCurrentOperation("translucentPass");
      renNode.setRenderEncoder(model.translucentRenderEncoder);
      renNode.traverse(publicAPI);
      publicAPI.finalPass(viewNode, renNode);
    };
    publicAPI.finalPass = (viewNode, renNode) => {
      model.translucentFinalEncoder.setColorTextureView(0, model.colorTextureView);
      model.translucentFinalEncoder.attachTextureViews();
      model.translucentFinalEncoder.begin(viewNode.getCommandEncoder());
      renNode.scissorAndViewport(model.translucentFinalEncoder);
      model.fullScreenQuad.prepareAndDraw(model.translucentFinalEncoder);
      model.translucentFinalEncoder.end();
    };
    publicAPI.getTextures = () => [model.translucentColorTexture, model.translucentAccumulateTexture];
    publicAPI.createRenderEncoder = () => {
      model.translucentRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: "translucentRender"
      });
      const rDesc = model.translucentRenderEncoder.getDescription();
      rDesc.colorAttachments = [{
        view: void 0,
        clearValue: [0, 0, 0, 0],
        loadOp: "clear",
        storeOp: "store"
      }, {
        view: void 0,
        clearValue: [1, 0, 0, 0],
        loadOp: "clear",
        storeOp: "store"
      }];
      rDesc.depthStencilAttachment = {
        view: void 0,
        depthLoadOp: "load",
        depthStoreOp: "store"
      };
      model.translucentRenderEncoder.setReplaceShaderCodeFunction((pipeline) => {
        const fDesc = pipeline.getShaderDescription("fragment");
        fDesc.addOutput("vec4<f32>", "outColor");
        fDesc.addOutput("f32", "outAccum");
        fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", [
          // very simple depth weighting in w z ranges from 1.0 near to 0.0
          "var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);",
          "output.outColor = vec4<f32>(computedColor.rgb*w, w);",
          "output.outAccum = computedColor.a;"
        ]).result;
        fDesc.setCode(code);
      });
      model.translucentRenderEncoder.setPipelineHash("oitpr");
      model.translucentRenderEncoder.setPipelineSettings({
        primitive: {
          cullMode: "none"
        },
        depthStencil: {
          depthWriteEnabled: false,
          depthCompare: "greater",
          format: "depth32float"
        },
        fragment: {
          targets: [{
            format: "rgba16float",
            blend: {
              color: {
                srcFactor: "one",
                dstFactor: "one"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one"
              }
            }
          }, {
            format: "r16float",
            blend: {
              color: {
                srcFactor: "zero",
                dstFactor: "one-minus-src"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one-minus-src-alpha"
              }
            }
          }]
        }
      });
    };
    publicAPI.createFinalEncoder = () => {
      model.translucentFinalEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: "translucentFinal"
      });
      model.translucentFinalEncoder.setDescription({
        colorAttachments: [{
          view: null,
          loadOp: "load",
          storeOp: "store"
        }]
      });
      model.translucentFinalEncoder.setReplaceShaderCodeFunction((pipeline) => {
        const fDesc = pipeline.getShaderDescription("fragment");
        fDesc.addOutput("vec4<f32>", "outColor");
        fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result;
        fDesc.setCode(code);
      });
      model.translucentFinalEncoder.setPipelineHash("oitpf");
      model.translucentFinalEncoder.setPipelineSettings({
        primitive: {
          cullMode: "none"
        },
        fragment: {
          targets: [{
            format: "rgba16float",
            blend: {
              color: {
                srcFactor: "src-alpha",
                dstFactor: "one-minus-src-alpha"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one-minus-src-alpha"
              }
            }
          }]
        }
      });
    };
  }
  var DEFAULT_VALUES73 = {
    colorTextureView: null,
    depthTextureView: null
  };
  function extend75(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES73, initialValues);
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["colorTextureView", "depthTextureView"]);
    vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model);
  }
  var newInstance75 = macro.newInstance(extend75, "vtkWebGPUOrderIndependentTranslucentPass");
  var vtkWebGPUOrderIndepenentTranslucentPass = {
    newInstance: newInstance75,
    extend: extend75
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js
  var BufferUsage = {
    Verts: 0,
    Lines: 1,
    Triangles: 2,
    Strips: 3,
    LinesFromStrips: 4,
    LinesFromTriangles: 5,
    Points: 6,
    UniformArray: 7,
    PointArray: 8,
    NormalsFromPoints: 9,
    Texture: 10,
    RawVertex: 11,
    Storage: 12,
    Index: 13
  };
  var PrimitiveTypes = {
    Start: 0,
    Points: 0,
    Lines: 1,
    Triangles: 2,
    TriangleStrips: 3,
    TriangleEdges: 4,
    TriangleStripEdges: 5,
    End: 6
  };
  var Constants13 = {
    BufferUsage,
    PrimitiveTypes
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Buffer.js
  var forwarded2 = ["getMappedRange", "mapAsync", "unmap"];
  function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
    const byteCount = srcArrayBuffer.byteLength;
    const srcBuffer = device.createBuffer({
      size: byteCount,
      /* eslint-disable no-undef */
      usage: GPUBufferUsage.COPY_SRC,
      /* eslint-enable no-undef */
      mappedAtCreation: true
    });
    const arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
    new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer));
    srcBuffer.unmap();
    const encoder = device.createCommandEncoder();
    encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
    const commandBuffer = encoder.finish();
    const queue = device.queue;
    queue.submit([commandBuffer]);
    srcBuffer.destroy();
  }
  function vtkWebGPUBuffer(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUBuffer");
    publicAPI.create = (sizeInBytes, usage) => {
      model.handle = model.device.getHandle().createBuffer({
        size: sizeInBytes,
        usage,
        label: model.label
      });
      model.sizeInBytes = sizeInBytes;
      model.usage = usage;
    };
    publicAPI.write = (data) => {
      bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
    };
    publicAPI.createAndWrite = (data, usage) => {
      const paddedSize = Math.ceil(data.byteLength / 4) * 4;
      model.handle = model.device.getHandle().createBuffer({
        size: paddedSize,
        usage,
        mappedAtCreation: true,
        label: model.label
      });
      model.sizeInBytes = paddedSize;
      model.usage = usage;
      new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer));
      model.handle.unmap();
    };
    for (let i = 0; i < forwarded2.length; i++) {
      publicAPI[forwarded2[i]] = function() {
        return model.handle[forwarded2[i]](...arguments);
      };
    }
  }
  var DEFAULT_VALUES74 = {
    device: null,
    handle: null,
    sizeInBytes: 0,
    strideInBytes: 0,
    arrayInformation: null,
    usage: null,
    label: null,
    sourceTime: null
  };
  function extend76(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES74, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["handle", "sizeInBytes", "usage"]);
    macro.setGet(publicAPI, model, ["strideInBytes", "device", "arrayInformation", "label", "sourceTime"]);
    vtkWebGPUBuffer(publicAPI, model);
  }
  var newInstance76 = macro.newInstance(extend76);
  var vtkWebGPUBuffer$1 = {
    newInstance: newInstance76,
    extend: extend76,
    ...Constants13
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js
  var {
    Representation: Representation4
  } = vtkProperty$1;
  var {
    PrimitiveTypes: PrimitiveTypes2
  } = Constants13;
  var _LimitedMap = class {
    constructor() {
      this.keys = new Uint32Array(10);
      this.values = new Uint32Array(10);
      this.count = 0;
    }
    clear() {
      this.count = 0;
    }
    has(key) {
      for (let i = 0; i < this.count; i++) {
        if (this.keys[i] === key) {
          return true;
        }
      }
      return void 0;
    }
    get(key) {
      for (let i = 0; i < this.count; i++) {
        if (this.keys[i] === key) {
          return this.values[i];
        }
      }
      return void 0;
    }
    set(key, value) {
      if (this.count < 9) {
        this.keys[this.count] = key;
        this.values[this.count++] = value;
      }
    }
  };
  function getPrimitiveName(primType) {
    switch (primType) {
      case PrimitiveTypes2.Points:
        return "points";
      case PrimitiveTypes2.Lines:
        return "lines";
      case PrimitiveTypes2.Triangles:
      case PrimitiveTypes2.TriangleEdges:
        return "polys";
      case PrimitiveTypes2.TriangleStripEdges:
      case PrimitiveTypes2.TriangleStrips:
        return "strips";
      default:
        return "";
    }
  }
  function _getOrAddFlatId(state2, ptId, cellId) {
    let flatId = state2.pointIdToFlatId[ptId];
    if (flatId < 0) {
      flatId = state2.flatId;
      state2.pointIdToFlatId[ptId] = flatId;
      state2.flatIdToPointId[state2.flatId] = ptId;
      state2.flatIdToCellId[state2.flatId] = cellId;
      state2.flatId++;
    }
    return flatId;
  }
  function fillCell(ptIds, cellId, state2) {
    const numPtIds = ptIds.length;
    for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
      let ptId2 = ptIds[ptIdx];
      if (state2.cellProvokedMap.has(ptId2)) {
        state2.ibo[state2.iboId++] = state2.cellProvokedMap.get(ptId2);
        for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
          ptId2 = ptIds[ptIdx2 % numPtIds];
          const flatId2 = _getOrAddFlatId(state2, ptId2, cellId);
          state2.ibo[state2.iboId++] = flatId2;
        }
        return;
      }
    }
    for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
      let ptId2 = ptIds[ptIdx];
      if (!state2.provokedPointIds[ptId2]) {
        let flatId2 = _getOrAddFlatId(state2, ptId2, cellId);
        state2.provokedPointIds[ptId2] = 1;
        state2.cellProvokedMap.set(ptId2, flatId2);
        state2.flatIdToCellId[flatId2] = cellId;
        state2.ibo[state2.iboId++] = flatId2;
        for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
          ptId2 = ptIds[ptIdx2 % numPtIds];
          flatId2 = _getOrAddFlatId(state2, ptId2, cellId);
          state2.ibo[state2.iboId++] = flatId2;
        }
        return;
      }
    }
    let ptId = ptIds[0];
    let flatId = state2.flatId;
    state2.cellProvokedMap.set(ptId, flatId);
    state2.flatIdToPointId[state2.flatId] = ptId;
    state2.flatIdToCellId[state2.flatId] = cellId;
    state2.flatId++;
    state2.ibo[state2.iboId++] = flatId;
    for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {
      ptId = ptIds[ptIdx2];
      flatId = _getOrAddFlatId(state2, ptId, cellId);
      state2.ibo[state2.iboId++] = flatId;
    }
  }
  function countCell(ptIds, cellId, state2) {
    const numPtIds = ptIds.length;
    state2.iboSize += numPtIds;
    for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
      const ptId = ptIds[ptIdx];
      if (state2.cellProvokedMap.has(ptId)) {
        return;
      }
    }
    for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
      const ptId = ptIds[ptIdx];
      if (!state2.provokedPointIds[ptId]) {
        state2.provokedPointIds[ptId] = 1;
        state2.cellProvokedMap.set(ptId, 1);
        return;
      }
    }
    state2.cellProvokedMap.set(ptIds[0], 1);
    state2.extraPoints++;
  }
  var processCell;
  var _single = new Uint32Array(1);
  var _double = new Uint32Array(2);
  var _triple = new Uint32Array(3);
  var _indexCellBuilders = {
    // easy, every input point becomes an output point
    anythingToPoints(numPoints, cellPts, offset, cellId, state2) {
      for (let i = 0; i < numPoints; ++i) {
        _single[0] = cellPts[offset + i];
        processCell(_single, cellId, state2);
      }
    },
    linesToWireframe(numPoints, cellPts, offset, cellId, state2) {
      for (let i = 0; i < numPoints - 1; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 1];
        processCell(_double, cellId, state2);
      }
    },
    polysToWireframe(numPoints, cellPts, offset, cellId, state2) {
      if (numPoints > 2) {
        for (let i = 0; i < numPoints; ++i) {
          _double[0] = cellPts[offset + i];
          _double[1] = cellPts[offset + (i + 1) % numPoints];
          processCell(_double, cellId, state2);
        }
      }
    },
    stripsToWireframe(numPoints, cellPts, offset, cellId, state2) {
      if (numPoints > 2) {
        for (let i = 0; i < numPoints - 1; ++i) {
          _double[0] = cellPts[offset + i];
          _double[1] = cellPts[offset + i + 1];
          processCell(_double, cellId, state2);
        }
        for (let i = 0; i < numPoints - 2; i++) {
          _double[0] = cellPts[offset + i];
          _double[1] = cellPts[offset + i + 2];
          processCell(_double, cellId, state2);
        }
      }
    },
    polysToSurface(npts, cellPts, offset, cellId, state2) {
      for (let i = 0; i < npts - 2; i++) {
        _triple[0] = cellPts[offset];
        _triple[1] = cellPts[offset + i + 1];
        _triple[2] = cellPts[offset + i + 2];
        processCell(_triple, cellId, state2);
      }
    },
    stripsToSurface(npts, cellPts, offset, cellId, state2) {
      for (let i = 0; i < npts - 2; i++) {
        _triple[0] = cellPts[offset + i];
        _triple[1] = cellPts[offset + i + 1 + i % 2];
        _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];
        processCell(_triple, cellId, state2);
      }
    }
  };
  function vtkWebGPUIndexBuffer(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUIndexBuffer");
    publicAPI.buildIndexBuffer = (req) => {
      const cellArray = req.cells;
      const primitiveType = req.primitiveType;
      const representation = req.representation;
      const cellOffset = req.cellOffset;
      const array = cellArray.getData();
      const cellArraySize = array.length;
      const inRepName = getPrimitiveName(primitiveType);
      const numPts = req.numberOfPoints;
      const state2 = {
        provokedPointIds: new Uint8Array(numPts),
        // size is good
        extraPoints: 0,
        iboSize: 0,
        flatId: 0,
        iboId: 0,
        cellProvokedMap: new _LimitedMap()
      };
      let func = null;
      if (representation === Representation4.POINTS || primitiveType === PrimitiveTypes2.Points) {
        func = _indexCellBuilders.anythingToPoints;
      } else if (representation === Representation4.WIREFRAME || primitiveType === PrimitiveTypes2.Lines) {
        func = _indexCellBuilders[`${inRepName}ToWireframe`];
      } else {
        func = _indexCellBuilders[`${inRepName}ToSurface`];
      }
      processCell = countCell;
      let cellId = cellOffset || 0;
      for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {
        state2.cellProvokedMap.clear();
        func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state2);
        cellArrayIndex += array[cellArrayIndex] + 1;
        cellId++;
      }
      if (numPts <= 65535) {
        state2.flatIdToPointId = new Uint16Array(numPts + state2.extraPoints);
      } else {
        state2.flatIdToPointId = new Uint32Array(numPts + state2.extraPoints);
      }
      if (numPts + state2.extraPoints < 36863) {
        state2.pointIdToFlatId = new Int16Array(numPts);
      } else {
        state2.pointIdToFlatId = new Int32Array(numPts);
      }
      if (numPts + state2.extraPoints <= 65535) {
        state2.ibo = new Uint16Array(state2.iboSize);
        req.format = "uint16";
      } else {
        state2.ibo = new Uint32Array(state2.iboSize);
        req.format = "uint32";
      }
      if (cellId <= 65535) {
        state2.flatIdToCellId = new Uint16Array(numPts + state2.extraPoints);
      } else {
        state2.flatIdToCellId = new Uint32Array(numPts + state2.extraPoints);
      }
      state2.pointIdToFlatId.fill(-1);
      state2.provokedPointIds.fill(0);
      processCell = fillCell;
      cellId = cellOffset || 0;
      for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {
        state2.cellProvokedMap.clear();
        func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state2);
        cellArrayIndex += array[cellArrayIndex] + 1;
        cellId++;
      }
      delete state2.provokedPointIds;
      delete state2.pointIdToFlatId;
      req.nativeArray = state2.ibo;
      model.flatIdToPointId = state2.flatIdToPointId;
      model.flatIdToCellId = state2.flatIdToCellId;
      model.flatSize = state2.flatId;
      model.indexCount = state2.iboId;
    };
  }
  var DEFAULT_VALUES75 = {
    flatIdToPointId: null,
    flatIdToCellId: null,
    flatSize: 0,
    indexCount: 0
  };
  function extend77(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES75, initialValues);
    vtkWebGPUBuffer$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["flatIdToPointId", "flatIdToCellId", "flatSize", "indexCount"]);
    vtkWebGPUIndexBuffer(publicAPI, model);
  }
  var newInstance77 = macro.newInstance(extend77);
  var vtkWebGPUIndexBuffer$1 = {
    newInstance: newInstance77,
    extend: extend77,
    ...Constants13
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js
  var {
    BufferUsage: BufferUsage2
  } = Constants13;
  var {
    vtkErrorMacro: vtkErrorMacro24
  } = macro$1;
  var {
    VtkDataTypes: VtkDataTypes5
  } = vtkDataArray$1;
  var STATIC13 = {};
  function _getFormatForDataArray(dataArray) {
    let format2;
    switch (dataArray.getDataType()) {
      case VtkDataTypes5.UNSIGNED_CHAR:
        format2 = "uint8";
        break;
      case VtkDataTypes5.FLOAT:
        format2 = "float32";
        break;
      case VtkDataTypes5.UNSIGNED_INT:
        format2 = "uint32";
        break;
      case VtkDataTypes5.INT:
        format2 = "sint32";
        break;
      case VtkDataTypes5.DOUBLE:
        format2 = "float32";
        break;
      case VtkDataTypes5.UNSIGNED_SHORT:
        format2 = "uint16";
        break;
      case VtkDataTypes5.SHORT:
        format2 = "sin16";
        break;
      default:
        format2 = "float32";
        break;
    }
    switch (dataArray.getNumberOfComponents()) {
      case 2:
        format2 += "x2";
        break;
      case 3:
        if (!format2.includes("32")) {
          vtkErrorMacro24(`unsupported x3 type for ${format2}`);
        }
        format2 += "x3";
        break;
      case 4:
        format2 += "x4";
        break;
    }
    return format2;
  }
  function packArray(indexBuffer, inArrayData, numComp, outputType, options) {
    const result = {};
    const flatSize = indexBuffer.getFlatSize();
    if (!flatSize) {
      return result;
    }
    let shift = [0, 0, 0, 0];
    if (options.shift) {
      if (options.shift.length) {
        shift = options.shift;
      } else {
        shift.fill(options.shift);
      }
    }
    let scale7 = [1, 1, 1, 1];
    if (options.scale) {
      if (options.scale.length) {
        scale7 = options.scale;
      } else {
        scale7.fill(options.scale);
      }
    }
    const packExtra = Object.prototype.hasOwnProperty.call(options, "packExtra") ? options.packExtra : false;
    let addAPoint;
    let vboidx = 0;
    const stride = numComp + (packExtra ? 1 : 0);
    const packedVBO = newTypedArray(outputType, flatSize * stride);
    let flatIdMap = indexBuffer.getFlatIdToPointId();
    if (options.cellData) {
      flatIdMap = indexBuffer.getFlatIdToCellId();
    }
    if (numComp === 1) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
      };
    } else if (numComp === 2) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
        packedVBO[vboidx++] = scale7[1] * inArrayData[i + 1] + shift[1];
      };
    } else if (numComp === 3 && !packExtra) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
        packedVBO[vboidx++] = scale7[1] * inArrayData[i + 1] + shift[1];
        packedVBO[vboidx++] = scale7[2] * inArrayData[i + 2] + shift[2];
      };
    } else if (numComp === 3 && packExtra) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
        packedVBO[vboidx++] = scale7[1] * inArrayData[i + 1] + shift[1];
        packedVBO[vboidx++] = scale7[2] * inArrayData[i + 2] + shift[2];
        packedVBO[vboidx++] = scale7[3] * 1 + shift[3];
      };
    } else if (numComp === 4) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
        packedVBO[vboidx++] = scale7[1] * inArrayData[i + 1] + shift[1];
        packedVBO[vboidx++] = scale7[2] * inArrayData[i + 2] + shift[2];
        packedVBO[vboidx++] = scale7[3] * inArrayData[i + 3] + shift[3];
      };
    }
    for (let index = 0; index < flatSize; index++) {
      const inArrayId = numComp * flatIdMap[index];
      addAPoint(inArrayId);
    }
    result.nativeArray = packedVBO;
    return result;
  }
  function getNormal2(pointData, i0, i1, i2) {
    const v1 = [pointData[i2 * 3] - pointData[i1 * 3], pointData[i2 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i2 * 3 + 2] - pointData[i1 * 3 + 2]];
    const v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
    const result = [];
    cross3(v1, v2, result);
    normalize4(result);
    return result;
  }
  function generateNormals(cellArray, pointArray) {
    const pointData = pointArray.getData();
    const cellArrayData = cellArray.getData();
    if (!cellArrayData || !pointData) {
      return null;
    }
    const packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);
    const size = cellArrayData.length;
    let vboidx = 0;
    for (let index = 0; index < size; ) {
      const normal = getNormal2(pointData, cellArrayData[index + 1], cellArrayData[index + 2], cellArrayData[index + 3]);
      packedVBO[vboidx++] = 127 * normal[0];
      packedVBO[vboidx++] = 127 * normal[1];
      packedVBO[vboidx++] = 127 * normal[2];
      packedVBO[vboidx++] = 127;
      index += cellArrayData[index] + 1;
    }
    return packedVBO;
  }
  function vtkWebGPUBufferManager(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUBufferManager");
    function _createBuffer(req) {
      if (req.dataArray && !req.nativeArray) {
        req.nativeArray = req.dataArray.getData();
      }
      let buffer;
      let gpuUsage;
      if (req.usage === BufferUsage2.Index) {
        buffer = vtkWebGPUIndexBuffer$1.newInstance({
          label: req.label
        });
        buffer.setDevice(model.device);
        gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
        buffer.buildIndexBuffer(req);
        buffer.createAndWrite(req.nativeArray, gpuUsage);
        buffer.setArrayInformation([{
          format: req.format
        }]);
      }
      if (!buffer) {
        buffer = vtkWebGPUBuffer$1.newInstance({
          label: req.label
        });
        buffer.setDevice(model.device);
      }
      if (req.usage === BufferUsage2.UniformArray) {
        gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
        buffer.createAndWrite(req.nativeArray, gpuUsage);
      }
      if (req.usage === BufferUsage2.Storage) {
        gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
        buffer.createAndWrite(req.nativeArray, gpuUsage);
      }
      if (req.usage === BufferUsage2.Texture) {
        gpuUsage = GPUBufferUsage.COPY_SRC;
        buffer.createAndWrite(req.nativeArray, gpuUsage);
      }
      if (req.usage === BufferUsage2.PointArray) {
        gpuUsage = GPUBufferUsage.VERTEX;
        const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
        const result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType, {
          packExtra: req.packExtra,
          shift: req.shift,
          scale: req.scale,
          cellData: req.cellData,
          cellOffset: req.cellOffset
        });
        buffer.createAndWrite(result.nativeArray, gpuUsage);
        buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
        buffer.setArrayInformation([{
          offset: 0,
          format: req.format,
          interpolation: req.cellData ? "flat" : "perspective"
        }]);
      }
      if (req.usage === BufferUsage2.NormalsFromPoints) {
        gpuUsage = GPUBufferUsage.VERTEX;
        const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
        const normals = generateNormals(req.cells, req.dataArray);
        const result = packArray(req.indexBuffer, normals, 4, arrayType, {
          cellData: true
        });
        buffer.createAndWrite(result.nativeArray, gpuUsage);
        buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
        buffer.setArrayInformation([{
          offset: 0,
          format: req.format,
          interpolation: "flat"
        }]);
      }
      if (req.usage === BufferUsage2.RawVertex) {
        gpuUsage = GPUBufferUsage.VERTEX;
        buffer.createAndWrite(req.nativeArray, gpuUsage);
        buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
        buffer.setArrayInformation([{
          offset: 0,
          format: req.format
        }]);
      }
      buffer.setSourceTime(req.time);
      return buffer;
    }
    publicAPI.hasBuffer = (hash) => model.device.hasCachedObject(hash);
    publicAPI.getBuffer = (req) => {
      if (req.hash) {
        return model.device.getCachedObject(req.hash, _createBuffer, req);
      }
      return _createBuffer(req);
    };
    publicAPI.getBufferForPointArray = (dataArray, indexBuffer) => {
      const format2 = _getFormatForDataArray(dataArray);
      const buffRequest = {
        hash: `${dataArray.getMTime()}I${indexBuffer.getMTime()}${format2}`,
        usage: BufferUsage2.PointArray,
        format: format2,
        dataArray,
        indexBuffer
      };
      return publicAPI.getBuffer(buffRequest);
    };
    publicAPI.getFullScreenQuadBuffer = () => {
      if (model.fullScreenQuadBuffer) {
        return model.fullScreenQuadBuffer;
      }
      model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
      model.fullScreenQuadBuffer.setDevice(model.device);
      const array = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]);
      model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);
      model.fullScreenQuadBuffer.setStrideInBytes(12);
      model.fullScreenQuadBuffer.setArrayInformation([{
        offset: 0,
        format: "float32x3"
      }]);
      return model.fullScreenQuadBuffer;
    };
  }
  var DEFAULT_VALUES76 = {
    device: null,
    fullScreenQuadBuffer: null
  };
  function extend78(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES76, initialValues);
    obj(publicAPI, model);
    setGet(publicAPI, model, ["device"]);
    vtkWebGPUBufferManager(publicAPI, model);
  }
  var newInstance78 = newInstance(extend78);
  var vtkWebGPUBufferManager$1 = {
    newInstance: newInstance78,
    extend: extend78,
    ...STATIC13,
    ...Constants13
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
  var {
    BufferUsage: BufferUsage3
  } = vtkWebGPUBufferManager$1;
  var {
    vtkErrorMacro: vtkErrorMacro25
  } = macro;
  function vtkWebGPUUniformBuffer(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUUniformBuffer");
    publicAPI.addEntry = (name, type) => {
      if (model._bufferEntryNames.has(name)) {
        vtkErrorMacro25(`entry named ${name} already exists`);
        return;
      }
      model.sortDirty = true;
      model._bufferEntryNames.set(name, model.bufferEntries.length);
      model.bufferEntries.push({
        name,
        type,
        sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),
        offset: -1,
        nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),
        packed: false
      });
    };
    publicAPI.sortBufferEntries = () => {
      if (!model.sortDirty) {
        return;
      }
      let currOffset = 0;
      const newEntries = [];
      let maxAlignment = 4;
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (entry.sizeInBytes % 16 === 0) {
          maxAlignment = Math.max(16, maxAlignment);
        }
        if (entry.sizeInBytes % 8 === 0) {
          maxAlignment = Math.max(8, maxAlignment);
        }
      }
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (entry.packed === false && entry.sizeInBytes % 16 === 0) {
          entry.packed = true;
          entry.offset = currOffset;
          newEntries.push(entry);
          currOffset += entry.sizeInBytes;
        }
      }
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (entry.packed === false && entry.sizeInBytes === 12) {
          for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {
            const entry2 = model.bufferEntries[i2];
            if (entry2.packed === false && entry2.sizeInBytes === 4) {
              entry.packed = true;
              entry.offset = currOffset;
              newEntries.push(entry);
              currOffset += entry.sizeInBytes;
              entry2.packed = true;
              entry2.offset = currOffset;
              newEntries.push(entry2);
              currOffset += entry2.sizeInBytes;
              break;
            }
          }
        }
      }
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (!entry.packed && entry.sizeInBytes % 8 === 0) {
          for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {
            const entry2 = model.bufferEntries[i2];
            if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {
              entry.packed = true;
              entry.offset = currOffset;
              newEntries.push(entry);
              currOffset += entry.sizeInBytes;
              entry2.packed = true;
              entry2.offset = currOffset;
              newEntries.push(entry2);
              currOffset += entry2.sizeInBytes;
              break;
            }
          }
        }
      }
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (!entry.packed && entry.sizeInBytes % 8 === 0) {
          let found = false;
          for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {
            const entry2 = model.bufferEntries[i2];
            if (!entry2.packed && entry2.sizeInBytes === 4) {
              for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {
                const entry3 = model.bufferEntries[i3];
                if (!entry3.packed && entry3.sizeInBytes === 4) {
                  entry.packed = true;
                  entry.offset = currOffset;
                  newEntries.push(entry);
                  currOffset += entry.sizeInBytes;
                  entry2.packed = true;
                  entry2.offset = currOffset;
                  newEntries.push(entry2);
                  currOffset += entry2.sizeInBytes;
                  entry3.packed = true;
                  entry3.offset = currOffset;
                  newEntries.push(entry3);
                  currOffset += entry3.sizeInBytes;
                  found = true;
                  break;
                }
              }
            }
          }
        }
      }
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (!entry.packed && entry.sizeInBytes > 4) {
          entry.packed = true;
          entry.offset = currOffset;
          newEntries.push(entry);
          currOffset += entry.sizeInBytes;
        }
      }
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (!entry.packed) {
          entry.packed = true;
          entry.offset = currOffset;
          newEntries.push(entry);
          currOffset += entry.sizeInBytes;
        }
      }
      model.bufferEntries = newEntries;
      model._bufferEntryNames.clear();
      for (let i = 0; i < model.bufferEntries.length; i++) {
        model._bufferEntryNames.set(model.bufferEntries[i].name, i);
      }
      model.sizeInBytes = currOffset;
      model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
      model.sortDirty = false;
    };
    publicAPI.sendIfNeeded = (device) => {
      if (!model.UBO) {
        const req = {
          nativeArray: model.Float32Array,
          usage: BufferUsage3.UniformArray,
          label: model.label
        };
        model.UBO = device.getBufferManager().getBuffer(req);
        model.bindGroupTime.modified();
        model.sendDirty = false;
      }
      if (model.sendDirty) {
        device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
        model.sendDirty = false;
      }
      model.sendTime.modified();
    };
    publicAPI.createView = (type) => {
      if (type in model === false) {
        if (!model.arrayBuffer) {
          model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
        }
        model[type] = macro.newTypedArray(type, model.arrayBuffer);
      }
    };
    publicAPI.setValue = (name, val) => {
      publicAPI.sortBufferEntries();
      const idx = model._bufferEntryNames.get(name);
      if (idx === void 0) {
        vtkErrorMacro25(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      if (entry.lastValue !== val) {
        view[entry.offset / view.BYTES_PER_ELEMENT] = val;
        model.sendDirty = true;
      }
      entry.lastValue = val;
    };
    publicAPI.setArray = (name, arr) => {
      publicAPI.sortBufferEntries();
      const idx = model._bufferEntryNames.get(name);
      if (idx === void 0) {
        vtkErrorMacro25(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      let changed = false;
      for (let i = 0; i < arr.length; i++) {
        if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {
          view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];
          changed = true;
        }
      }
      if (changed) {
        model.sendDirty = true;
        entry.lastValue = [...arr];
      }
    };
    publicAPI.getBindGroupEntry = () => {
      const foo = {
        resource: {
          buffer: model.UBO.getHandle()
        }
      };
      return foo;
    };
    publicAPI.getSendTime = () => model.sendTime.getMTime();
    publicAPI.getShaderCode = (binding, group) => {
      publicAPI.sortBufferEntries();
      const lines = [`struct ${model.label}Struct
{`];
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        lines.push(`  ${entry.name}: ${entry.type},`);
      }
      lines.push(`};
@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);
      return lines.join("\n");
    };
  }
  var DEFAULT_VALUES77 = {
    bufferEntries: null,
    bufferEntryNames: null,
    sizeInBytes: 0,
    label: null,
    bindGroupLayoutEntry: null,
    bindGroupEntry: null
  };
  function extend79(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES77, initialValues);
    macro.obj(publicAPI, model);
    model._bufferEntryNames = /* @__PURE__ */ new Map();
    model.bufferEntries = [];
    model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
      buffer: {
        type: "uniform"
      }
    };
    model.sendTime = {};
    macro.obj(model.sendTime, {
      mtime: 0
    });
    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });
    model.sendDirty = true;
    model.sortDirty = true;
    macro.get(publicAPI, model, ["binding", "bindGroupTime"]);
    macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label", "sizeInBytes"]);
    vtkWebGPUUniformBuffer(publicAPI, model);
  }
  var newInstance79 = macro.newInstance(extend79, "vtkWebGPUUniformBuffer");
  var vtkWebGPUUniformBuffer$1 = {
    newInstance: newInstance79,
    extend: extend79
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js
  var {
    BufferUsage: BufferUsage4
  } = vtkWebGPUBufferManager$1;
  var {
    vtkErrorMacro: vtkErrorMacro26
  } = macro;
  function vtkWebGPUStorageBuffer(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUStorageBuffer");
    publicAPI.addEntry = (name, type) => {
      if (model._bufferEntryNames.has(name)) {
        vtkErrorMacro26(`entry named ${name} already exists`);
        return;
      }
      model._bufferEntryNames.set(name, model.bufferEntries.length);
      const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);
      model.bufferEntries.push({
        name,
        type,
        sizeInBytes,
        offset: model.sizeInBytes,
        nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)
      });
      model.sizeInBytes += sizeInBytes;
    };
    publicAPI.send = (device) => {
      if (!model._buffer) {
        const req = {
          nativeArray: model.Float32Array,
          usage: BufferUsage4.Storage,
          label: model.label
        };
        model._buffer = device.getBufferManager().getBuffer(req);
        model.bindGroupTime.modified();
        model._sendTime.modified();
        return;
      }
      device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
      model._sendTime.modified();
    };
    publicAPI.createView = (type) => {
      if (type in model === false) {
        if (!model.arrayBuffer) {
          model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
        }
        model[type] = macro.newTypedArray(type, model.arrayBuffer);
      }
    };
    publicAPI.setValue = (name, instance, val) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === void 0) {
        vtkErrorMacro26(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
    };
    publicAPI.setArray = (name, instance, arr) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === void 0) {
        vtkErrorMacro26(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0; i < arr.length; i++) {
        view[ioffset + i] = arr[i];
      }
    };
    publicAPI.setAllInstancesFromArray = (name, arr) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === void 0) {
        vtkErrorMacro26(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      const numComponents = arr.length / model.numberOfInstances;
      for (let inst = 0; inst < model.numberOfInstances; inst++) {
        const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
        for (let i = 0; i < numComponents; i++) {
          view[ioffset + i] = arr[inst * numComponents + i];
        }
      }
    };
    publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === void 0) {
        vtkErrorMacro26(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      const numComponents = arr.length / model.numberOfInstances;
      for (let inst = 0; inst < model.numberOfInstances; inst++) {
        const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
        for (let i = 0; i < numComponents; i++) {
          view[ioffset + i] = arr[inst * numComponents + i] / 255;
        }
      }
    };
    publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === void 0) {
        vtkErrorMacro26(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      const numComponents = 9;
      for (let inst = 0; inst < model.numberOfInstances; inst++) {
        const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
        for (let j = 0; j < 3; j++) {
          for (let i = 0; i < 3; i++) {
            view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];
          }
        }
      }
    };
    publicAPI.getSendTime = () => model._sendTime.getMTime();
    publicAPI.getShaderCode = (binding, group) => {
      const lines = [`struct ${model.label}StructEntry
{`];
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        lines.push(`  ${entry.name}: ${entry.type},`);
      }
      lines.push(`
};
struct ${model.label}Struct
{
  values: array<${model.label}StructEntry>,
};
@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;
`);
      return lines.join("\n");
    };
    publicAPI.getBindGroupEntry = () => {
      const foo = {
        resource: {
          buffer: model._buffer.getHandle()
        }
      };
      return foo;
    };
    publicAPI.clearData = () => {
      model.numberOfInstances = 0;
      model.sizeInBytes = 0;
      model.bufferEntries = [];
      model._bufferEntryNames = /* @__PURE__ */ new Map();
      model._buffer = null;
      delete model.arrayBuffer;
      delete model.Float32Array;
    };
  }
  var DEFAULT_VALUES78 = {
    bufferEntries: null,
    bufferEntryNames: null,
    sizeInBytes: 0,
    label: null,
    numberOfInstances: 1
  };
  function extend80(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES78, initialValues);
    macro.obj(publicAPI, model);
    model._bufferEntryNames = /* @__PURE__ */ new Map();
    model.bufferEntries = [];
    model._sendTime = {};
    macro.obj(model._sendTime, {
      mtime: 0
    });
    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });
    model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
      buffer: {
        type: "read-only-storage"
      }
    };
    macro.get(publicAPI, model, ["bindGroupTime"]);
    macro.setGet(publicAPI, model, ["device", "bindGroupLayoutEntry", "label", "numberOfInstances", "sizeInBytes"]);
    vtkWebGPUStorageBuffer(publicAPI, model);
  }
  var newInstance80 = macro.newInstance(extend80, "vtkWebGPUStorageBuffer");
  var vtkWebGPUStorageBuffer$1 = {
    newInstance: newInstance80,
    extend: extend80
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants.js
  var BlendMode = {
    COMPOSITE_BLEND: 0,
    MAXIMUM_INTENSITY_BLEND: 1,
    MINIMUM_INTENSITY_BLEND: 2,
    AVERAGE_INTENSITY_BLEND: 3,
    ADDITIVE_INTENSITY_BLEND: 4,
    RADON_TRANSFORM_BLEND: 5,
    LABELMAP_EDGE_PROJECTION_BLEND: 6
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePassFSQ.js
  var volFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Volume::TraverseDec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

fn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32
{
  // todo multicomponent support
  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;
}

fn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>
{
  var result: vec4<f32>;

  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;
  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;
  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;
  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;
  result.w = 0.0;

  // divide by spacing as that is our delta
  result = result / volumeSSBO.values[vNum].spacing;
  // now we have a gradient in unit tcoords

  var grad: f32 = length(result.xyz);
  if (grad > 0.0)
  {
    // rotate to View Coords, needed for lighting and shading
    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;
    result = nMat * result;
    result = result / length(result);
  }

  // store gradient magnitude in .w
  result.w = grad;

  return result;
}

fn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>
{
  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);

  // convert to tcoords and reject if outside the volume
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;
  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||
      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }

  var scalar: f32 = getTextureValue(vTex, tpos);

  var coord: vec2<f32> =
    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,
      (0.5 + 2.0 * f32(vNum)) / tfunRows);
  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);

  var gofactor: f32 = 1.0;
  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);
  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)
  {
    normal = getGradient(vTex, tpos, vNum, scalar);
    if (componentSSBO.values[cNum].gomin <  1.0)
    {
      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,
      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);
    }
  }

  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);
  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;

  if (volumeSSBO.values[vNum].shade[0] > 0.0)
  {
    color = color*abs(normal.z);
  }

  outColor = vec4<f32>(color.rgb, gofactor * opacity);

  return outColor;
}

// adjust the start and end point of a raycast such that it intersects the unit cube.
// This function is used to take a raycast starting point and step vector
// and numSteps and return the startijng and ending steps for intersecting the
// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates
// that have valid values. So this funtion can be used to take a ray in texture coordinates
// and bound it to intersecting the texture.
//
fn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>
{
  var result: vec2<f32> = vec2<f32>(0.0, numSteps);
  var tpos2: vec4<f32> = tpos + tstep*numSteps;

  // move tpos to the start of the volume
  var adjust: f32 =
    min(
      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),
      min(
        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),
        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));
  if (adjust < 0.0)
  {
    result.x = result.x - adjust;
  }

  // adjust length to the end
  adjust =
    max(
      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),
      max(
        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),
        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));
  if (adjust > 0.0)
  {
    result.y = result.y - adjust;
  }

  return result;
}

fn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>
{
  // how many rows (tfuns) do we have in our tfunTexture
  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);

  var coord: vec2<f32> =
    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,
      (0.5 + 2.0 * f32(vNum)) / tfunRows);
  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);
  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);
  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;
  return vec4<f32>(color.rgb, opacity);
}

fn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var maxVal: f32 = -1.0e37;
  loop
  {
    var scalar: f32 = getTextureValue(vTex, tpos);
    if (scalar > maxVal)
    {
      maxVal = scalar;
    }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);
}

fn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var minVal: f32 = 1.0e37;
  loop
  {
    var scalar: f32 = getTextureValue(vTex, tpos);
    if (scalar < minVal)
    {
      minVal = scalar;
    }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);
}

fn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;
  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var avgVal: f32 = 0.0;
  var sampleCount: f32 = 0.0;
  loop
  {
    var sample: f32 = getTextureValue(vTex, tpos);
    // right now leave filtering off until WebGL changes get merged
    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)
    // {
      avgVal = avgVal + sample;
      sampleCount = sampleCount + 1.0;
    // }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  if (sampleCount <= 0.0)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);
}

fn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;
  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var sumVal: f32 = 0.0;
  loop
  {
    var sample: f32 = getTextureValue(vTex, tpos);
    // right now leave filtering off until WebGL changes get merged
    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)
    // {
      sumVal = sumVal + sample;
    // }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);
}

fn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>
{
  // initial ray position is at the beginning
  var rayPosSC: vec4<f32> = minPosSC;

  // how many rows (tfuns) do we have in our tfunTexture
  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);

  var curDist: f32 = 0.0;
  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);
  var sampleColor: vec4<f32>;
//VTK::Volume::TraverseCalls

  loop
  {
    // for each volume, sample and accumulate color
//VTK::Volume::CompositeCalls

    // increment position
    curDist = curDist + mapperUBO.SampleDistance;
    rayPosSC = rayPosSC + rayStepSC;

    // check if we have reached a terminating condition
    if (curDist > rayLengthSC) { break; }
    if (computedColor.a > 0.98) { break; }
  }
  return computedColor;
}

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;
  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;

  // discard empty rays
  if (rayMax <= rayMin) { discard; }
  else
  {
    // compute start and end ray positions in view coordinates
    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);
    minPosSC = minPosSC * (1.0 / minPosSC.w);
    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);
    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);

    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);
    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);
    rayStepSC.w = 0.0;

    var computedColor: vec4<f32>;

//VTK::Volume::Loop

//VTK::RenderEncoder::Impl
  }

  return output;
}
`;
  var tmpMat4 = new Float64Array(16);
  var tmp2Mat4 = new Float64Array(16);
  function vtkWebGPUVolumePassFSQ(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUVolumePassFSQ");
    publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription("vertex");
      vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);"]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
    };
    model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
    publicAPI.replaceShaderVolume = (hash, pipeline, vertexInput) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      let code = fDesc.getCode();
      const compositeCalls = [];
      const traverseCalls = [];
      for (let i = 0; i < model.volumes.length; i++) {
        const blendMode = model.volumes[i].getRenderable().getMapper().getBlendMode();
        if (blendMode === BlendMode.COMPOSITE_BLEND) {
          compositeCalls.push(`    sampleColor = processVolume(volTexture${i}, ${i}, ${model.rowStarts[i]}, rayPosSC, tfunRows);`);
          compositeCalls.push(`    computedColor = vec4<f32>(
          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,
          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);
        } else {
          traverseCalls.push(`  sampleColor = traverseVals[${i}];`);
          traverseCalls.push(`  computedColor = vec4<f32>(
          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,
          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);
        }
      }
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::CompositeCalls", compositeCalls).result;
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::TraverseCalls", traverseCalls).result;
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::TraverseDec", [`var<private> traverseVals: array<vec4<f32>,${model.volumes.length}>;`]).result;
      let compositeWhileTraversing = false;
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
        if (blendMode === BlendMode.COMPOSITE_BLEND) {
          compositeWhileTraversing = true;
        } else if (blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {
          code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseMax(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
        } else if (blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {
          code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseMin(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
        } else if (blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {
          code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseAverage(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
        } else if (blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {
          code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseAdditive(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
        }
      }
      if (compositeWhileTraversing) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", ["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result;
      }
      fDesc.setCode(code);
    };
    model.shaderReplacements.set("replaceShaderVolume", publicAPI.replaceShaderVolume);
    publicAPI.updateLUTImage = (device) => {
      let mtime = publicAPI.getMTime();
      for (let i = 0; i < model.volumes.length; i++) {
        const vol = model.volumes[i].getRenderable();
        const image = vol.getMapper().getInputData();
        mtime = Math.max(mtime, vol.getMTime(), image.getMTime());
      }
      if (mtime < model.lutBuildTime.getMTime()) {
        return;
      }
      model.numRows = 0;
      model.rowStarts = [];
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        model.rowStarts.push(model.numRows);
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const vprop = actor.getProperty();
        const image = volMapr.getInputData();
        const scalars = image.getPointData() && image.getPointData().getScalars();
        const numComp = scalars.getNumberOfComponents();
        const iComps = vprop.getIndependentComponents();
        const numIComps = iComps ? numComp : 1;
        model.numRows += numIComps;
      }
      const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);
      const opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);
      let imgRow = 0;
      const tmpTable = new Float32Array(model.rowLength * 3);
      const rowLength = model.rowLength;
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const vprop = actor.getProperty();
        const image = volMapr.getInputData();
        const scalars = image.getPointData() && image.getPointData().getScalars();
        const numComp = scalars.getNumberOfComponents();
        const iComps = vprop.getIndependentComponents();
        const numIComps = iComps ? numComp : 1;
        for (let c = 0; c < numIComps; ++c) {
          const cfun = vprop.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);
          let ioffset = imgRow * rowLength * 4;
          for (let i = 0; i < rowLength; ++i) {
            colorArray[ioffset + i * 4] = 255 * tmpTable[i * 3];
            colorArray[ioffset + i * 4 + 1] = 255 * tmpTable[i * 3 + 1];
            colorArray[ioffset + i * 4 + 2] = 255 * tmpTable[i * 3 + 2];
            colorArray[ioffset + i * 4 + 3] = 255;
            for (let co = 0; co < 4; co++) {
              colorArray[ioffset + (rowLength + i) * 4 + co] = colorArray[ioffset + i * 4 + co];
            }
          }
          const ofun = vprop.getScalarOpacity(c);
          const opacityFactor = model.sampleDist / vprop.getScalarOpacityUnitDistance(c);
          const oRange = ofun.getRange();
          ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1);
          ioffset = imgRow * rowLength;
          for (let i = 0; i < rowLength; ++i) {
            opacityArray[ioffset + i] = 1 - (1 - tmpTable[i]) ** opacityFactor;
            opacityArray[ioffset + i + rowLength] = opacityArray[ioffset + i];
          }
          imgRow += 2;
        }
      }
      {
        const treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: "rgba8unorm"
        };
        const newTex = device.getTextureManager().getTexture(treq);
        const tview = newTex.createView("tfunTexture");
        model.textureViews[2] = tview;
      }
      {
        const treq = {
          nativeArray: opacityArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: "r16float"
        };
        const newTex = device.getTextureManager().getTexture(treq);
        const tview = newTex.createView("ofunTexture");
        model.textureViews[3] = tview;
      }
      model.lutBuildTime.modified();
    };
    publicAPI.updateSSBO = (device) => {
      let mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());
      for (let i = 0; i < model.volumes.length; i++) {
        const vol = model.volumes[i].getRenderable();
        const volMapr = vol.getMapper();
        const image = volMapr.getInputData();
        mtime = Math.max(mtime, vol.getMTime(), image.getMTime(), volMapr.getMTime());
      }
      if (mtime < model.SSBO.getSendTime()) {
        return;
      }
      const center = model.WebGPURenderer.getStabilizedCenterByReference();
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(model.volumes.length);
      const marray = new Float64Array(model.volumes.length * 16);
      const vPlaneArray = new Float64Array(model.volumes.length * 16);
      const tstepArray = new Float64Array(model.volumes.length * 4);
      const shadeArray = new Float64Array(model.volumes.length * 4);
      const spacingArray = new Float64Array(model.volumes.length * 4);
      const ipScalarRangeArray = new Float64Array(model.volumes.length * 4);
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const image = volMapr.getInputData();
        mat4_exports.identity(tmpMat4);
        mat4_exports.translate(tmpMat4, tmpMat4, center);
        const mcwcmat = actor.getMatrix();
        mat4_exports.transpose(tmp2Mat4, mcwcmat);
        mat4_exports.invert(tmp2Mat4, tmp2Mat4);
        mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
        const modelToIndex = image.getWorldToIndex();
        mat4_exports.multiply(tmpMat4, modelToIndex, tmpMat4);
        const dims = image.getDimensions();
        mat4_exports.identity(tmp2Mat4);
        mat4_exports.scale(tmp2Mat4, tmp2Mat4, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
        mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
        for (let j = 0; j < 16; j++) {
          marray[vidx * 16 + j] = tmpMat4[j];
        }
        mat4_exports.invert(tmpMat4, tmpMat4);
        for (let j = 0; j < 4; j++) {
          vPlaneArray[vidx * 16 + j * 4] = tmpMat4[j * 4];
          vPlaneArray[vidx * 16 + j * 4 + 1] = tmpMat4[j * 4 + 1];
          vPlaneArray[vidx * 16 + j * 4 + 2] = tmpMat4[j * 4 + 2];
          vPlaneArray[vidx * 16 + j * 4 + 3] = 0;
        }
        tstepArray[vidx * 4] = 1 / dims[0];
        tstepArray[vidx * 4 + 1] = 1 / dims[1];
        tstepArray[vidx * 4 + 2] = 1 / dims[2];
        tstepArray[vidx * 4 + 3] = 1;
        shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1 : 0;
        const spacing = image.getSpacing();
        spacingArray[vidx * 4] = spacing[0];
        spacingArray[vidx * 4 + 1] = spacing[1];
        spacingArray[vidx * 4 + 2] = spacing[2];
        spacingArray[vidx * 4 + 3] = 1;
        const tScale = model.textureViews[vidx + 4].getTexture().getScale();
        const ipScalarRange = actor.getProperty().getIpScalarRange();
        ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;
        ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;
        ipScalarRangeArray[vidx * 4 + 2] = actor.getProperty().getFilterMode();
      }
      model.SSBO.addEntry("SCTCMatrix", "mat4x4<f32>");
      model.SSBO.addEntry("planeNormals", "mat4x4<f32>");
      model.SSBO.addEntry("shade", "vec4<f32>");
      model.SSBO.addEntry("tstep", "vec4<f32>");
      model.SSBO.addEntry("spacing", "vec4<f32>");
      model.SSBO.addEntry("ipScalarRange", "vec4<f32>");
      model.SSBO.setAllInstancesFromArray("SCTCMatrix", marray);
      model.SSBO.setAllInstancesFromArray("planeNormals", vPlaneArray);
      model.SSBO.setAllInstancesFromArray("shade", shadeArray);
      model.SSBO.setAllInstancesFromArray("tstep", tstepArray);
      model.SSBO.setAllInstancesFromArray("spacing", spacingArray);
      model.SSBO.setAllInstancesFromArray("ipScalarRange", ipScalarRangeArray);
      model.SSBO.send(device);
      model.componentSSBO.clearData();
      model.componentSSBO.setNumberOfInstances(model.numRows);
      const cScaleArray = new Float64Array(model.numRows);
      const cShiftArray = new Float64Array(model.numRows);
      const oScaleArray = new Float64Array(model.numRows);
      const oShiftArray = new Float64Array(model.numRows);
      const gominArray = new Float64Array(model.numRows);
      const gomaxArray = new Float64Array(model.numRows);
      const goshiftArray = new Float64Array(model.numRows);
      const goscaleArray = new Float64Array(model.numRows);
      let rowIdx = 0;
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const vprop = actor.getProperty();
        const image = volMapr.getInputData();
        const scalars = image.getPointData() && image.getPointData().getScalars();
        const numComp = scalars.getNumberOfComponents();
        const iComps = vprop.getIndependentComponents();
        const tformat = model.textureViews[vidx + 4].getTexture().getFormat();
        const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);
        const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
        const volInfo = {
          scale: [255],
          offset: [0]
        };
        if (halfFloat) {
          volInfo.scale[0] = 1;
        }
        for (let compIdx = 0; compIdx < numComp; compIdx++) {
          const target = iComps ? compIdx : 0;
          const sscale = volInfo.scale[compIdx];
          const ofun = vprop.getScalarOpacity(target);
          const oRange = ofun.getRange();
          const oscale = sscale / (oRange[1] - oRange[0]);
          const oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);
          oShiftArray[rowIdx] = oshift;
          oScaleArray[rowIdx] = oscale;
          const cfun = vprop.getRGBTransferFunction(target);
          const cRange = cfun.getRange();
          cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);
          cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]);
          const useGO = vprop.getUseGradientOpacity(target);
          if (useGO) {
            const gomin = vprop.getGradientOpacityMinimumOpacity(target);
            const gomax = vprop.getGradientOpacityMaximumOpacity(target);
            gominArray[rowIdx] = gomin;
            gomaxArray[rowIdx] = gomax;
            const goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];
            goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);
            goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;
          } else {
            gominArray[rowIdx] = 1;
            gomaxArray[rowIdx] = 1;
            goscaleArray[rowIdx] = 0;
            goshiftArray[rowIdx] = 1;
          }
          rowIdx++;
        }
      }
      model.componentSSBO.addEntry("cScale", "f32");
      model.componentSSBO.addEntry("cShift", "f32");
      model.componentSSBO.addEntry("oScale", "f32");
      model.componentSSBO.addEntry("oShift", "f32");
      model.componentSSBO.addEntry("goShift", "f32");
      model.componentSSBO.addEntry("goScale", "f32");
      model.componentSSBO.addEntry("gomin", "f32");
      model.componentSSBO.addEntry("gomax", "f32");
      model.componentSSBO.setAllInstancesFromArray("cScale", cScaleArray);
      model.componentSSBO.setAllInstancesFromArray("cShift", cShiftArray);
      model.componentSSBO.setAllInstancesFromArray("oScale", oScaleArray);
      model.componentSSBO.setAllInstancesFromArray("oShift", oShiftArray);
      model.componentSSBO.setAllInstancesFromArray("goScale", goscaleArray);
      model.componentSSBO.setAllInstancesFromArray("goShift", goshiftArray);
      model.componentSSBO.setAllInstancesFromArray("gomin", gominArray);
      model.componentSSBO.setAllInstancesFromArray("gomax", gomaxArray);
      model.componentSSBO.send(device);
    };
    const superClassUpdateBuffers = publicAPI.updateBuffers;
    publicAPI.updateBuffers = () => {
      superClassUpdateBuffers();
      let sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();
      for (let i = 0; i < model.volumes.length; i++) {
        const vol = model.volumes[i];
        const volMapr = vol.getRenderable().getMapper();
        const sd = volMapr.getSampleDistance();
        if (sd < sampleDist) {
          sampleDist = sd;
        }
      }
      if (model.sampleDist !== sampleDist) {
        model.sampleDist = sampleDist;
        model.UBO.setValue("SampleDistance", sampleDist);
        model.UBO.sendIfNeeded(model.device);
      }
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const image = volMapr.getInputData();
        const newTex = model.device.getTextureManager().getTextureForImageData(image);
        if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {
          const tview = newTex.createView(`volTexture${vidx}`);
          model.textureViews[vidx + 4] = tview;
        }
      }
      if (model.volumes.length < model.lastVolumeLength) {
        for (let i = model.volumes.length; i < model.lastVolumeLength; i++) {
          model.textureViews.pop();
        }
      }
      model.lastVolumeLength = model.volumes.length;
      publicAPI.updateLUTImage(model.device);
      publicAPI.updateSSBO(model.device);
      if (!model.clampSampler) {
        model.clampSampler = vtkWebGPUSampler$1.newInstance({
          label: "clampSampler"
        });
        model.clampSampler.create(model.device, {
          minFilter: "linear",
          magFilter: "linear"
        });
      }
    };
    publicAPI.computePipelineHash = () => {
      model.pipelineHash = "volfsq";
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
        model.pipelineHash += `${blendMode}`;
      }
    };
    publicAPI.setVolumes = (val) => {
      if (!model.volumes || model.volumes.length !== val.length) {
        model.volumes = [...val];
        publicAPI.modified();
        return;
      }
      for (let i = 0; i < val.length; i++) {
        if (val[i] !== model.volumes[i]) {
          model.volumes = [...val];
          publicAPI.modified();
          return;
        }
      }
    };
    const superclassGetBindables = publicAPI.getBindables;
    publicAPI.getBindables = () => {
      const bindables = superclassGetBindables();
      bindables.push(model.componentSSBO);
      bindables.push(model.clampSampler);
      return bindables;
    };
  }
  var DEFAULT_VALUES79 = {
    volumes: null,
    rowLength: 1024,
    lastVolumeLength: 0
  };
  function extend81(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES79, initialValues);
    vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
    model.fragmentShaderTemplate = volFragTemplate;
    model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
      label: "mapperUBO"
    });
    model.UBO.addEntry("SampleDistance", "f32");
    model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
      label: "volumeSSBO"
    });
    model.componentSSBO = vtkWebGPUStorageBuffer$1.newInstance({
      label: "componentSSBO"
    });
    model.lutBuildTime = {};
    macro.obj(model.lutBuildTime, {
      mtime: 0
    });
    vtkWebGPUVolumePassFSQ(publicAPI, model);
  }
  var newInstance81 = macro.newInstance(extend81, "vtkWebGPUVolumePassFSQ");
  var vtkWebGPUVolumePassFSQ$1 = {
    newInstance: newInstance81,
    extend: extend81
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePass.js
  var {
    Representation: Representation5
  } = vtkProperty$1;
  var {
    BufferUsage: BufferUsage5,
    PrimitiveTypes: PrimitiveTypes3
  } = vtkWebGPUBufferManager$1;
  var cubeFaceTriangles = [[0, 4, 6], [0, 6, 2], [1, 3, 7], [1, 7, 5], [0, 5, 4], [0, 1, 5], [2, 6, 7], [2, 7, 3], [0, 3, 1], [0, 2, 3], [4, 5, 7], [4, 7, 6]];
  var DepthBoundsFS = `
//VTK::Renderer::Dec

//VTK::Select::Dec

//VTK::VolumePass::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Select::Impl

  //VTK::TCoord::Impl

  //VTK::VolumePass::Impl

  // use the maximum (closest) of the current value and the zbuffer
  // the blend func will then take the min to find the farthest stop value
  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  var volumeCopyFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,
    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  function vtkWebGPUVolumePass(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUVolumePass");
    publicAPI.initialize = (viewNode) => {
      if (!model._clearEncoder) {
        publicAPI.createClearEncoder(viewNode);
      }
      if (!model._mergeEncoder) {
        publicAPI.createMergeEncoder(viewNode);
      }
      if (!model._copyEncoder) {
        publicAPI.createCopyEncoder(viewNode);
      }
      if (!model._depthRangeEncoder) {
        publicAPI.createDepthRangeEncoder(viewNode);
      }
      if (!model.fullScreenQuad) {
        model.fullScreenQuad = vtkWebGPUVolumePassFSQ$1.newInstance();
        model.fullScreenQuad.setDevice(viewNode.getDevice());
        model.fullScreenQuad.setTextureViews([...model._depthRangeEncoder.getColorTextureViews()]);
      }
      if (!model._volumeCopyQuad) {
        model._volumeCopyQuad = vtkWebGPUFullScreenQuad$1.newInstance();
        model._volumeCopyQuad.setPipelineHash("volpassfsq");
        model._volumeCopyQuad.setDevice(viewNode.getDevice());
        model._volumeCopyQuad.setFragmentShaderTemplate(volumeCopyFragTemplate);
        model._copyUBO = vtkWebGPUUniformBuffer$1.newInstance({
          label: "mapperUBO"
        });
        model._copyUBO.addEntry("tscale", "vec2<f32>");
        model._volumeCopyQuad.setUBO(model._copyUBO);
        model._volumeCopyQuad.setTextureViews([model._colorTextureView]);
      }
    };
    publicAPI.traverse = (renNode, viewNode) => {
      if (model.deleted) {
        return;
      }
      model._currentParent = viewNode;
      publicAPI.initialize(viewNode);
      publicAPI.computeTiming(viewNode);
      publicAPI.renderDepthBounds(renNode, viewNode);
      model._firstGroup = true;
      const device = viewNode.getDevice();
      const maxVolumes = device.getHandle().limits.maxSampledTexturesPerShaderStage - 4;
      if (model.volumes.length > maxVolumes) {
        const cameraPos = renNode.getRenderable().getActiveCamera().getPosition();
        const distances = [];
        for (let v = 0; v < model.volumes.length; v++) {
          const bounds = model.volumes[v].getRenderable().getBounds();
          const centroid = [0.5 * (bounds[1] + bounds[0]), 0.5 * (bounds[3] + bounds[2]), 0.5 * (bounds[5] + bounds[4])];
          distances[v] = distance2BetweenPoints(centroid, cameraPos);
        }
        const volumeOrder = [...Array(model.volumes.length).keys()];
        volumeOrder.sort((a, b) => distances[b] - distances[a]);
        let volumesToRender = [];
        let chunkSize = volumeOrder.length % maxVolumes;
        for (let v = 0; v < volumeOrder.length; v++) {
          volumesToRender.push(model.volumes[volumeOrder[v]]);
          if (volumesToRender.length >= chunkSize) {
            publicAPI.rayCastPass(viewNode, renNode, volumesToRender);
            volumesToRender = [];
            chunkSize = maxVolumes;
            model._firstGroup = false;
          }
        }
      } else {
        publicAPI.rayCastPass(viewNode, renNode, model.volumes);
      }
      model._volumeCopyQuad.setWebGPURenderer(renNode);
      if (model._useSmallViewport) {
        const width = model._colorTextureView.getTexture().getWidth();
        const height = model._colorTextureView.getTexture().getHeight();
        model._copyUBO.setArray("tscale", [model._smallViewportWidth / width, model._smallViewportHeight / height]);
      } else {
        model._copyUBO.setArray("tscale", [1, 1]);
      }
      model._copyUBO.sendIfNeeded(device);
      model._copyEncoder.setColorTextureView(0, model.colorTextureView);
      model._copyEncoder.attachTextureViews();
      model._copyEncoder.begin(viewNode.getCommandEncoder());
      renNode.scissorAndViewport(model._copyEncoder);
      model._volumeCopyQuad.prepareAndDraw(model._copyEncoder);
      model._copyEncoder.end();
    };
    publicAPI.delete = macro.chain(() => {
      if (model._animationRateSubscription) {
        model._animationRateSubscription.unsubscribe();
        model._animationRateSubscription = null;
      }
    }, publicAPI.delete);
    publicAPI.computeTiming = (viewNode) => {
      const rwi = viewNode.getRenderable().getInteractor();
      if (model._lastScale == null) {
        const firstMapper = model.volumes[0].getRenderable().getMapper();
        model._lastScale = firstMapper.getInitialInteractionScale() || 1;
      }
      model._useSmallViewport = false;
      if (rwi.isAnimating() && model._lastScale > 1.5) {
        model._useSmallViewport = true;
      }
      model._colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      if (!model._animationRateSubscription) {
        model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {
          const firstMapper = model.volumes[0].getRenderable().getMapper();
          if (firstMapper.getAutoAdjustSampleDistances()) {
            const frate = rwi.getRecentAnimationFrameRate();
            const targetScale = model._lastScale * rwi.getDesiredUpdateRate() / frate;
            model._lastScale = targetScale;
            if (model._lastScale > 400) {
              model._lastScale = 400;
            }
          } else {
            model._lastScale = firstMapper.getImageSampleDistance() * firstMapper.getImageSampleDistance();
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        });
      }
    };
    publicAPI.rayCastPass = (viewNode, renNode, volumes) => {
      const encoder = model._firstGroup ? model._clearEncoder : model._mergeEncoder;
      encoder.attachTextureViews();
      encoder.begin(viewNode.getCommandEncoder());
      let width = model._colorTextureView.getTexture().getWidth();
      let height = model._colorTextureView.getTexture().getHeight();
      if (model._useSmallViewport) {
        const canvas = viewNode.getCanvas();
        const scaleFactor = 1 / Math.sqrt(model._lastScale);
        model._smallViewportWidth = Math.ceil(scaleFactor * canvas.width);
        model._smallViewportHeight = Math.ceil(scaleFactor * canvas.height);
        width = model._smallViewportWidth;
        height = model._smallViewportHeight;
      }
      encoder.getHandle().setViewport(0, 0, width, height, 0, 1);
      encoder.getHandle().setScissorRect(0, 0, width, height);
      model.fullScreenQuad.setWebGPURenderer(renNode);
      model.fullScreenQuad.setVolumes(volumes);
      model.fullScreenQuad.prepareAndDraw(encoder);
      encoder.end();
    };
    publicAPI.renderDepthBounds = (renNode, viewNode) => {
      publicAPI.updateDepthPolyData(renNode);
      const pd = model._boundsPoly;
      const points = pd.getPoints();
      const cells = pd.getPolys();
      let buffRequest = {
        hash: `vp${cells.getMTime()}`,
        usage: BufferUsage5.Index,
        cells,
        numberOfPoints: points.getNumberOfPoints(),
        primitiveType: PrimitiveTypes3.Triangles,
        representation: Representation5.SURFACE
      };
      const indexBuffer = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
      model._mapper.getVertexInput().setIndexBuffer(indexBuffer);
      buffRequest = {
        usage: BufferUsage5.PointArray,
        format: "float32x4",
        hash: `vp${points.getMTime()}${cells.getMTime()}`,
        dataArray: points,
        indexBuffer,
        packExtra: true
      };
      const buff = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
      model._mapper.getVertexInput().addBuffer(buff, ["vertexBC"]);
      model._mapper.setNumberOfVertices(buff.getSizeInBytes() / buff.getStrideInBytes());
      publicAPI.drawDepthRange(renNode, viewNode);
    };
    publicAPI.updateDepthPolyData = (renNode) => {
      let update = false;
      for (let i = 0; i < model.volumes.length; i++) {
        const mtime = model.volumes[i].getMTime();
        if (!model._lastMTimes[i] || mtime !== model._lastMTimes[i]) {
          update = true;
          model._lastMTimes[i] = mtime;
        }
      }
      const stime = renNode.getStabilizedTime();
      if (model._lastMTimes.length <= model.volumes.length || stime !== model._lastMTimes[model.volumes.length]) {
        update = true;
        model._lastMTimes[model.volumes.length] = stime;
      }
      if (!update) {
        return;
      }
      const center = renNode.getStabilizedCenterByReference();
      const numPts = model.volumes.length * 8;
      const points = new Float64Array(numPts * 3);
      const numTris = model.volumes.length * 12;
      const polys = new Uint16Array(numTris * 4);
      for (let i = 0; i < model.volumes.length; i++) {
        model.volumes[i].getBoundingCubePoints(points, i * 24);
        let cellIdx = i * 12 * 4;
        const offset = i * 8;
        for (let t = 0; t < 12; t++) {
          polys[cellIdx++] = 3;
          polys[cellIdx++] = offset + cubeFaceTriangles[t][0];
          polys[cellIdx++] = offset + cubeFaceTriangles[t][1];
          polys[cellIdx++] = offset + cubeFaceTriangles[t][2];
        }
      }
      for (let p = 0; p < points.length; p += 3) {
        points[p] -= center[0];
        points[p + 1] -= center[1];
        points[p + 2] -= center[2];
      }
      model._boundsPoly.getPoints().setData(points, 3);
      model._boundsPoly.getPoints().modified();
      model._boundsPoly.getPolys().setData(polys, 1);
      model._boundsPoly.getPolys().modified();
      model._boundsPoly.modified();
    };
    publicAPI.drawDepthRange = (renNode, viewNode) => {
      model._depthRangeTexture.resizeToMatch(model.colorTextureView.getTexture());
      model._depthRangeTexture2.resizeToMatch(model.colorTextureView.getTexture());
      model._depthRangeEncoder.attachTextureViews();
      publicAPI.setCurrentOperation("volumeDepthRangePass");
      renNode.setRenderEncoder(model._depthRangeEncoder);
      renNode.volumeDepthRangePass(true);
      model._mapper.setWebGPURenderer(renNode);
      model._mapper.prepareToDraw(model._depthRangeEncoder);
      model._mapper.registerDrawCallback(model._depthRangeEncoder);
      renNode.volumeDepthRangePass(false);
    };
    publicAPI.createDepthRangeEncoder = (viewNode) => {
      const device = viewNode.getDevice();
      model._depthRangeEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: "VolumePass DepthRange"
      });
      model._depthRangeEncoder.setPipelineHash("volr");
      model._depthRangeEncoder.setReplaceShaderCodeFunction((pipeline) => {
        const fDesc = pipeline.getShaderDescription("fragment");
        fDesc.addOutput("vec4<f32>", "outColor1");
        fDesc.addOutput("vec4<f32>", "outColor2");
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);", "output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result;
        fDesc.setCode(code);
      });
      model._depthRangeEncoder.setDescription({
        colorAttachments: [{
          view: null,
          clearValue: [0, 0, 0, 0],
          loadOp: "clear",
          storeOp: "store"
        }, {
          view: null,
          clearValue: [1, 1, 1, 1],
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      model._depthRangeEncoder.setPipelineSettings({
        primitive: {
          cullMode: "none"
        },
        fragment: {
          targets: [{
            format: "r16float",
            blend: {
              color: {
                srcFactor: "one",
                dstFactor: "one",
                operation: "max"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one",
                operation: "max"
              }
            }
          }, {
            format: "r16float",
            blend: {
              color: {
                srcFactor: "one",
                dstFactor: "one",
                operation: "min"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one",
                operation: "min"
              }
            }
          }]
        }
      });
      model._depthRangeTexture = vtkWebGPUTexture$1.newInstance({
        label: "volumePassMaxDepth"
      });
      model._depthRangeTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "r16float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      const maxView = model._depthRangeTexture.createView("maxTexture");
      model._depthRangeEncoder.setColorTextureView(0, maxView);
      model._depthRangeTexture2 = vtkWebGPUTexture$1.newInstance({
        label: "volumePassDepthMin"
      });
      model._depthRangeTexture2.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "r16float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      const minView = model._depthRangeTexture2.createView("minTexture");
      model._depthRangeEncoder.setColorTextureView(1, minView);
      model._mapper.setDevice(viewNode.getDevice());
      model._mapper.setTextureViews([model.depthTextureView]);
    };
    publicAPI.createClearEncoder = (viewNode) => {
      model._colorTexture = vtkWebGPUTexture$1.newInstance({
        label: "volumePassColor"
      });
      model._colorTexture.create(viewNode.getDevice(), {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "bgra8unorm",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
      });
      model._colorTextureView = model._colorTexture.createView("volumePassColorTexture");
      model._colorTextureView.addSampler(viewNode.getDevice(), {
        minFilter: "linear",
        magFilter: "linear"
      });
      model._clearEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: "VolumePass Clear"
      });
      model._clearEncoder.setColorTextureView(0, model._colorTextureView);
      model._clearEncoder.setDescription({
        colorAttachments: [{
          view: null,
          clearValue: [0, 0, 0, 0],
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      model._clearEncoder.setPipelineHash("volpf");
      model._clearEncoder.setPipelineSettings({
        primitive: {
          cullMode: "none"
        },
        fragment: {
          targets: [{
            format: "bgra8unorm",
            blend: {
              color: {
                srcFactor: "src-alpha",
                dstFactor: "one-minus-src-alpha"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one-minus-src-alpha"
              }
            }
          }]
        }
      });
    };
    publicAPI.createCopyEncoder = (viewNode) => {
      model._copyEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: "volumePassCopy"
      });
      model._copyEncoder.setDescription({
        colorAttachments: [{
          view: null,
          loadOp: "load",
          storeOp: "store"
        }]
      });
      model._copyEncoder.setPipelineHash("volcopypf");
      model._copyEncoder.setPipelineSettings({
        primitive: {
          cullMode: "none"
        },
        fragment: {
          targets: [{
            format: "rgba16float",
            blend: {
              color: {
                srcFactor: "one",
                dstFactor: "one-minus-src-alpha"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one-minus-src-alpha"
              }
            }
          }]
        }
      });
    };
    publicAPI.createMergeEncoder = (viewNode) => {
      model._mergeEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: "volumePassMerge"
      });
      model._mergeEncoder.setColorTextureView(0, model._colorTextureView);
      model._mergeEncoder.setDescription({
        colorAttachments: [{
          view: null,
          loadOp: "load",
          storeOp: "store"
        }]
      });
      model._mergeEncoder.setReplaceShaderCodeFunction((pipeline) => {
        const fDesc = pipeline.getShaderDescription("fragment");
        fDesc.addOutput("vec4<f32>", "outColor");
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result;
        fDesc.setCode(code);
      });
      model._mergeEncoder.setPipelineHash("volpf");
      model._mergeEncoder.setPipelineSettings({
        primitive: {
          cullMode: "none"
        },
        fragment: {
          targets: [{
            format: "bgra8unorm",
            blend: {
              color: {
                srcFactor: "src-alpha",
                dstFactor: "one-minus-src-alpha"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one-minus-src-alpha"
              }
            }
          }]
        }
      });
    };
    publicAPI.setVolumes = (val) => {
      if (!model.volumes || model.volumes.length !== val.length) {
        model.volumes = [...val];
        publicAPI.modified();
        return;
      }
      for (let i = 0; i < val.length; i++) {
        if (val[i] !== model.volumes[i]) {
          model.volumes = [...val];
          publicAPI.modified();
          return;
        }
      }
    };
  }
  var DEFAULT_VALUES80 = {
    colorTextureView: null,
    depthTextureView: null,
    volumes: null
  };
  function extend82(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES80, initialValues);
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    model._mapper = vtkWebGPUSimpleMapper$1.newInstance();
    model._mapper.setFragmentShaderTemplate(DepthBoundsFS);
    model._mapper.getShaderReplacements().set("replaceShaderVolumePass", (hash, pipeline, vertexInput) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
    });
    model._boundsPoly = vtkPolyData$1.newInstance();
    model._lastMTimes = [];
    macro.setGet(publicAPI, model, ["colorTextureView", "depthTextureView"]);
    vtkWebGPUVolumePass(publicAPI, model);
  }
  var newInstance82 = macro.newInstance(extend82, "vtkWebGPUVolumePass");
  var vtkWebGPUVolumePass$1 = {
    newInstance: newInstance82,
    extend: extend82
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/ForwardPass.js
  var finalBlitFragTemplate = `
//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  function vtkForwardPass2(publicAPI, model) {
    model.classHierarchy.push("vtkForwardPass");
    publicAPI.traverse = function(viewNode) {
      let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (model.deleted) {
        return;
      }
      model._currentParent = parent;
      publicAPI.setCurrentOperation("buildPass");
      viewNode.traverse(publicAPI);
      if (!model.opaquePass) {
        model.opaquePass = vtkWebGPUOpaquePass$1.newInstance();
      }
      const numlayers = viewNode.getRenderable().getNumberOfLayers();
      const renderers = viewNode.getChildren();
      for (let i = 0; i < numlayers; i++) {
        for (let index = 0; index < renderers.length; index++) {
          const renNode = renderers[index];
          const ren = viewNode.getRenderable().getRenderers()[index];
          if (ren.getDraw() && ren.getLayer() === i) {
            model.opaqueActorCount = 0;
            model.translucentActorCount = 0;
            model.volumes = [];
            publicAPI.setCurrentOperation("queryPass");
            renNode.traverse(publicAPI);
            publicAPI.setCurrentOperation("cameraPass");
            renNode.traverse(publicAPI);
            model.opaquePass.traverse(renNode, viewNode);
            if (model.translucentActorCount > 0) {
              if (!model.translucentPass) {
                model.translucentPass = vtkWebGPUOrderIndepenentTranslucentPass.newInstance();
              }
              model.translucentPass.setColorTextureView(model.opaquePass.getColorTextureView());
              model.translucentPass.setDepthTextureView(model.opaquePass.getDepthTextureView());
              model.translucentPass.traverse(renNode, viewNode);
            }
            if (model.volumes.length > 0) {
              if (!model.volumePass) {
                model.volumePass = vtkWebGPUVolumePass$1.newInstance();
              }
              model.volumePass.setColorTextureView(model.opaquePass.getColorTextureView());
              model.volumePass.setDepthTextureView(model.opaquePass.getDepthTextureView());
              model.volumePass.setVolumes(model.volumes);
              model.volumePass.traverse(renNode, viewNode);
            }
            publicAPI.finalPass(viewNode, renNode);
          }
        }
      }
    };
    publicAPI.finalPass = (viewNode, renNode) => {
      if (!model._finalBlitEncoder) {
        publicAPI.createFinalBlitEncoder(viewNode);
      }
      model._finalBlitOutputTextureView.createFromTextureHandle(viewNode.getCurrentTexture(), {
        depth: 1,
        format: viewNode.getPresentationFormat()
      });
      model._finalBlitEncoder.attachTextureViews();
      model._finalBlitEncoder.begin(viewNode.getCommandEncoder());
      renNode.scissorAndViewport(model._finalBlitEncoder);
      model._fullScreenQuad.prepareAndDraw(model._finalBlitEncoder);
      model._finalBlitEncoder.end();
    };
    publicAPI.createFinalBlitEncoder = (viewNode) => {
      model._finalBlitEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: "forwardPassBlit"
      });
      model._finalBlitEncoder.setDescription({
        colorAttachments: [{
          view: null,
          loadOp: "load",
          storeOp: "store"
        }]
      });
      model._finalBlitEncoder.setPipelineHash("fpf");
      model._finalBlitEncoder.setPipelineSettings({
        primitive: {
          cullMode: "none"
        },
        fragment: {
          targets: [{
            format: viewNode.getPresentationFormat(),
            blend: {
              color: {
                srcFactor: "src-alpha",
                dstFactor: "one-minus-src-alpha"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one-minus-src-alpha"
              }
            }
          }]
        }
      });
      model._fsqSampler = vtkWebGPUSampler$1.newInstance({
        label: "finalPassSampler"
      });
      model._fsqSampler.create(viewNode.getDevice(), {
        minFilter: "linear",
        magFilter: "linear"
      });
      model._fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
      model._fullScreenQuad.setDevice(viewNode.getDevice());
      model._fullScreenQuad.setPipelineHash("fpfsq");
      model._fullScreenQuad.setTextureViews([model.opaquePass.getColorTextureView()]);
      model._fullScreenQuad.setAdditionalBindables([model._fsqSampler]);
      model._fullScreenQuad.setFragmentShaderTemplate(finalBlitFragTemplate);
      model._finalBlitOutputTextureView = vtkWebGPUTextureView$1.newInstance();
      model._finalBlitEncoder.setColorTextureView(0, model._finalBlitOutputTextureView);
    };
    publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
    publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
    publicAPI.addVolume = (volume) => {
      model.volumes.push(volume);
    };
  }
  var DEFAULT_VALUES81 = {
    opaqueActorCount: 0,
    translucentActorCount: 0,
    volumes: null,
    opaqueRenderEncoder: null,
    translucentPass: null,
    volumePass: null
  };
  function extend83(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES81, initialValues);
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ["opaquePass", "translucentPass", "volumePass"]);
    vtkForwardPass2(publicAPI, model);
  }
  var newInstance83 = macro.newInstance(extend83, "vtkForwardPass");
  var vtkForwardPass$12 = {
    newInstance: newInstance83,
    extend: extend83
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureManager.js
  var {
    VtkDataTypes: VtkDataTypes6
  } = vtkDataArray$1;
  function vtkWebGPUTextureManager(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUTextureManager");
    function _fillRequest(req) {
      if (req.imageData) {
        req.dataArray = req.imageData.getPointData().getScalars();
        req.time = req.dataArray.getMTime();
        req.nativeArray = req.dataArray.getData();
        const dims = req.imageData.getDimensions();
        req.width = dims[0];
        req.height = dims[1];
        req.depth = dims[2];
        const numComp = req.dataArray.getNumberOfComponents();
        switch (numComp) {
          case 1:
            req.format = "r";
            break;
          case 2:
            req.format = "rg";
            break;
          case 3:
          case 4:
          default:
            req.format = "rgba";
            break;
        }
        const dataType = req.dataArray.getDataType();
        switch (dataType) {
          case VtkDataTypes6.UNSIGNED_CHAR:
            req.format += "8unorm";
            break;
          // todo extend to other types that are not filterable
          // as they can be useful
          case VtkDataTypes6.FLOAT:
          case VtkDataTypes6.UNSIGNED_INT:
          case VtkDataTypes6.INT:
          case VtkDataTypes6.DOUBLE:
          case VtkDataTypes6.UNSIGNED_SHORT:
          case VtkDataTypes6.SHORT:
          default:
            req.format += "16float";
            break;
        }
      }
      if (req.image) {
        req.width = req.image.width;
        req.height = req.image.height;
        req.depth = 1;
        req.format = "rgba8unorm";
        req.flip = true;
        req.usage = GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
      }
      if (req.jsImageData) {
        req.width = req.jsImageData.width;
        req.height = req.jsImageData.height;
        req.depth = 1;
        req.format = "rgba8unorm";
        req.flip = true;
        req.nativeArray = req.jsImageData.data;
        req.usage = GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
      }
      if (req.imageBitmap) {
        req.width = req.imageBitmap.width;
        req.height = req.imageBitmap.height;
        req.depth = 1;
        req.format = "rgba8unorm";
        req.flip = true;
        req.usage = GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
      }
      if (req.canvas) {
        req.width = req.canvas.width;
        req.height = req.canvas.height;
        req.depth = 1;
        req.format = "rgba8unorm";
        req.flip = true;
        req.usage = GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
      }
    }
    function _createTexture(req) {
      const newTex = vtkWebGPUTexture$1.newInstance({
        label: req.label
      });
      newTex.create(model.device, {
        width: req.width,
        height: req.height,
        depth: req.depth,
        format: req.format,
        usage: req.usage,
        mipLevel: req.mipLevel
      });
      if (req.nativeArray || req.image || req.canvas || req.imageBitmap) {
        newTex.writeImageData(req);
      }
      return newTex;
    }
    publicAPI.getTexture = (req) => {
      if (req.hash) {
        return model.device.getCachedObject(req.hash, _createTexture, req);
      }
      return _createTexture(req);
    };
    publicAPI.getTextureForImageData = (imgData) => {
      const treq = {
        time: imgData.getMTime()
      };
      treq.imageData = imgData;
      _fillRequest(treq);
      treq.hash = treq.time + treq.format + treq.mipLevel;
      return model.device.getTextureManager().getTexture(treq);
    };
    publicAPI.getTextureForVTKTexture = function(srcTexture) {
      let label = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      const treq = {
        time: srcTexture.getMTime(),
        label
      };
      if (srcTexture.getInputData()) {
        treq.imageData = srcTexture.getInputData();
      } else if (srcTexture.getImage()) {
        treq.image = srcTexture.getImage();
      } else if (srcTexture.getJsImageData()) {
        treq.jsImageData = srcTexture.getJsImageData();
      } else if (srcTexture.getImageBitmap()) {
        treq.imageBitmap = srcTexture.getImageBitmap();
      } else if (srcTexture.getCanvas()) {
        treq.canvas = srcTexture.getCanvas();
      }
      _fillRequest(treq);
      treq.mipLevel = srcTexture.getMipLevel();
      treq.hash = treq.time + treq.format + treq.mipLevel;
      return model.device.getTextureManager().getTexture(treq);
    };
  }
  var DEFAULT_VALUES82 = {
    handle: null,
    device: null
  };
  function extend84(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES82, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["device"]);
    vtkWebGPUTextureManager(publicAPI, model);
  }
  var newInstance84 = macro.newInstance(extend84);
  var vtkWebGPUTextureManager$1 = {
    newInstance: newInstance84,
    extend: extend84
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Device.js
  var WeakRefMap = class extends Map {
    constructor() {
      super();
      this.registry = new FinalizationRegistry((key) => {
        const entry = super.get(key);
        if (entry && entry.deref && entry.deref() === void 0) super.delete(key);
      });
    }
    getValue(key) {
      const entry = super.get(key);
      if (entry) {
        const value = entry.deref();
        if (value !== void 0) return value;
        super.delete(key);
      }
      return void 0;
    }
    setValue(key, value) {
      let entry;
      if (value && typeof value === "object") {
        entry = new WeakRef(value);
        this.registry.register(value, key);
        super.set(key, entry);
      }
      return entry;
    }
  };
  function vtkWebGPUDevice(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUDevice");
    publicAPI.initialize = (handle) => {
      model.handle = handle;
    };
    publicAPI.createCommandEncoder = () => model.handle.createCommandEncoder();
    publicAPI.submitCommandEncoder = (commandEncoder) => {
      model.handle.queue.submit([commandEncoder.finish()]);
    };
    publicAPI.getShaderModule = (sd) => model.shaderCache.getShaderModule(sd);
    publicAPI.getBindGroupLayout = (val) => {
      if (!val.entries) {
        return null;
      }
      for (let i = 0; i < val.entries.length; i++) {
        const ent = val.entries[i];
        ent.binding = ent.binding || 0;
        ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
      }
      const sval = JSON.stringify(val);
      for (let i = 0; i < model.bindGroupLayouts.length; i++) {
        if (model.bindGroupLayouts[i].sval === sval) {
          return model.bindGroupLayouts[i].layout;
        }
      }
      const layout = model.handle.createBindGroupLayout(val);
      model.bindGroupLayouts.push({
        sval,
        layout
      });
      return layout;
    };
    publicAPI.getBindGroupLayoutDescription = (layout) => {
      for (let i = 0; i < model.bindGroupLayouts.length; i++) {
        if (model.bindGroupLayouts[i].layout === layout) {
          return model.bindGroupLayouts[i].sval;
        }
      }
      vtkErrorMacro("layout not found");
      console.trace();
      return null;
    };
    publicAPI.getPipeline = (hash) => {
      if (hash in model.pipelines) {
        return model.pipelines[hash];
      }
      return null;
    };
    publicAPI.createPipeline = (hash, pipeline) => {
      pipeline.initialize(publicAPI, hash);
      model.pipelines[hash] = pipeline;
    };
    publicAPI.onSubmittedWorkDone = () => model.handle.queue.onSubmittedWorkDone();
    publicAPI.hasCachedObject = (hash) => model.objectCache.getValue(hash);
    publicAPI.getCachedObject = function(hash, creator) {
      if (!hash) {
        vtkErrorMacro("attempt to cache an object without a hash");
        return null;
      }
      const existingValue = model.objectCache.getValue(hash);
      if (existingValue) {
        return existingValue;
      }
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      const createdObject = creator(...args);
      model.objectCache.setValue(hash, createdObject);
      return createdObject;
    };
  }
  var DEFAULT_VALUES83 = {
    handle: null,
    pipelines: null,
    shaderCache: null,
    bindGroupLayouts: null,
    bufferManager: null,
    textureManager: null
  };
  function extend85(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES83, initialValues);
    obj(publicAPI, model);
    setGet(publicAPI, model, ["handle"]);
    get(publicAPI, model, ["bufferManager", "shaderCache", "textureManager"]);
    model.objectCache = new WeakRefMap();
    model.shaderCache = vtkWebGPUShaderCache$1.newInstance();
    model.shaderCache.setDevice(publicAPI);
    model.bindGroupLayouts = [];
    model.bufferManager = vtkWebGPUBufferManager$1.newInstance();
    model.bufferManager.setDevice(publicAPI);
    model.textureManager = vtkWebGPUTextureManager$1.newInstance();
    model.textureManager.setDevice(publicAPI);
    model.pipelines = {};
    vtkWebGPUDevice(publicAPI, model);
  }
  var newInstance85 = newInstance(extend85, "vtkWebGPUDevice");
  var vtkWebGPUDevice$1 = {
    newInstance: newInstance85,
    extend: extend85
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelectionPass.js
  function vtkWebGPUHardwareSelectionPass(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUHardwareSelectionPass");
    publicAPI.traverse = (viewNode, renNode) => {
      if (model.deleted) {
        return;
      }
      model._currentParent = null;
      publicAPI.setCurrentOperation("buildPass");
      viewNode.traverse(publicAPI);
      const device = viewNode.getDevice();
      if (!model.selectionRenderEncoder) {
        publicAPI.createRenderEncoder();
        model.colorTexture = vtkWebGPUTexture$1.newInstance({
          label: "hardwareSelectorColor"
        });
        model.colorTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: "rgba32uint",
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
        });
        const v1 = model.colorTexture.createView("hardwareSelectColorTexture");
        model.selectionRenderEncoder.setColorTextureView(0, v1);
        model.depthTexture = vtkWebGPUTexture$1.newInstance({
          label: "hardwareSelectorDepth"
        });
        model.depthTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: "depth32float",
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
        });
        const v2 = model.depthTexture.createView("hardwareSelectDepthTexture");
        model.selectionRenderEncoder.setDepthTextureView(v2);
      } else {
        model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
        model.depthTexture.resizeToMatch(model.colorTexture);
      }
      model.selectionRenderEncoder.attachTextureViews();
      renNode.setRenderEncoder(model.selectionRenderEncoder);
      publicAPI.setCurrentOperation("cameraPass");
      renNode.traverse(publicAPI);
      publicAPI.setCurrentOperation("opaquePass");
      renNode.traverse(publicAPI);
    };
    publicAPI.createRenderEncoder = () => {
      model.selectionRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: "HardwareSelectionPass"
      });
      model.selectionRenderEncoder.setPipelineHash("sel");
      model.selectionRenderEncoder.setReplaceShaderCodeFunction((pipeline) => {
        const fDesc = pipeline.getShaderDescription("fragment");
        fDesc.addOutput("vec4<u32>", "outColor");
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result;
        fDesc.setCode(code);
      });
      const renDesc = model.selectionRenderEncoder.getDescription();
      renDesc.colorAttachments[0].clearValue = [0, 0, 0, 0];
      model.selectionRenderEncoder.setPipelineSettings({
        primitive: {
          cullMode: "none"
        },
        depthStencil: {
          depthWriteEnabled: true,
          depthCompare: "greater",
          format: "depth32float"
        },
        fragment: {
          targets: [{
            format: "rgba32uint",
            blend: void 0
          }]
        }
      });
    };
  }
  var DEFAULT_VALUES84 = {
    selectionRenderEncoder: null,
    colorTexture: null,
    depthTexture: null
  };
  function extend86(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES84, initialValues);
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ["colorTexture", "depthTexture"]);
    vtkWebGPUHardwareSelectionPass(publicAPI, model);
  }
  var newInstance86 = macro.newInstance(extend86, "vtkWebGPUHardwareSelectionPass");
  var vtkWebGPUHardwareSelectionPass$1 = {
    newInstance: newInstance86,
    extend: extend86
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelector.js
  var {
    SelectionContent: SelectionContent3,
    SelectionField: SelectionField3
  } = vtkSelectionNode$1;
  var {
    FieldAssociations: FieldAssociations5
  } = vtkDataSet$1;
  var {
    vtkErrorMacro: vtkErrorMacro27
  } = macro;
  function getInfoHash2(info) {
    return `${info.propID} ${info.compositeID}`;
  }
  function convert2(xx, yy, buffdata, channel) {
    const offset = ((buffdata.height - yy - 1) * buffdata.colorBufferWidth + xx) * 4 + channel;
    return buffdata.colorValues[offset];
  }
  function getPixelInformationWithData2(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < 0 || inDisplayPosition[0] >= buffdata.width || inDisplayPosition[1] < 0 || inDisplayPosition[1] >= buffdata.height) {
        return null;
      }
      const actorid = convert2(inDisplayPosition[0], inDisplayPosition[1], buffdata, 0);
      if (actorid <= 0) {
        return null;
      }
      const info2 = {};
      info2.propID = actorid;
      let compositeID = convert2(inDisplayPosition[0], inDisplayPosition[1], buffdata, 1);
      if (compositeID < 0 || compositeID > 16777215) {
        compositeID = 0;
      }
      info2.compositeID = compositeID;
      if (buffdata.captureZValues) {
        const offset = (buffdata.height - inDisplayPosition[1] - 1) * buffdata.zbufferBufferWidth + inDisplayPosition[0];
        info2.zValue = buffdata.depthValues[offset];
        info2.zValue = buffdata.webGPURenderer.convertToOpenGLDepth(info2.zValue);
        info2.displayPosition = inDisplayPosition;
      }
      return info2;
    }
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = getPixelInformationWithData2(buffdata, inDisplayPosition, 0, outSelectedPosition);
    if (info) {
      return info;
    }
    for (let dist3 = 1; dist3 < maxDist; ++dist3) {
      for (let y = dispPos[1] > dist3 ? dispPos[1] - dist3 : 0; y <= dispPos[1] + dist3; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist3) {
          curPos[0] = dispPos[0] - dist3;
          info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
          if (info) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist3;
        info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
      for (let x = dispPos[0] >= dist3 ? dispPos[0] - (dist3 - 1) : 0; x <= dispPos[0] + (dist3 - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist3) {
          curPos[1] = dispPos[1] - dist3;
          info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
          if (info) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist3;
        info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
    }
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  }
  function convertSelection2(fieldassociation, dataMap, buffdata) {
    const sel = [];
    let count = 0;
    dataMap.forEach((value, key) => {
      const child = vtkSelectionNode$1.newInstance();
      child.setContentType(SelectionContent3.INDICES);
      switch (fieldassociation) {
        case FieldAssociations5.FIELD_ASSOCIATION_CELLS:
          child.setFieldType(SelectionField3.CELL);
          break;
        case FieldAssociations5.FIELD_ASSOCIATION_POINTS:
          child.setFieldType(SelectionField3.POINT);
          break;
        default:
          vtkErrorMacro27("Unknown field association");
      }
      child.getProperties().propID = value.info.propID;
      const wprop = buffdata.webGPURenderer.getPropFromID(value.info.propID);
      child.getProperties().prop = wprop.getRenderable();
      child.getProperties().compositeID = value.info.compositeID;
      child.getProperties().pixelCount = value.pixelCount;
      if (buffdata.captureZValues) {
        child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
        child.getProperties().worldPosition = buffdata.webGPURenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, buffdata.renderer);
      }
      child.setSelectionList(value.attributeIDs);
      sel[count] = child;
      count++;
    });
    return sel;
  }
  function generateSelectionWithData2(buffdata, fx1, fy1, fx2, fy2) {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y2 = Math.floor(fy2);
    const dataMap = /* @__PURE__ */ new Map();
    const outSelectedPosition = [0, 0];
    for (let yy = y1; yy <= y2; yy++) {
      for (let xx = x1; xx <= x2; xx++) {
        const pos = [xx, yy];
        const info = getPixelInformationWithData2(buffdata, pos, 0, outSelectedPosition);
        if (info) {
          const hash = getInfoHash2(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (buffdata.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection2(buffdata.fieldAssociation, dataMap, buffdata);
  }
  function vtkWebGPUHardwareSelector(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUHardwareSelector");
    publicAPI.endSelection = () => {
      model.WebGPURenderer.setSelector(null);
    };
    publicAPI.getSourceDataAsync = async (renderer) => {
      if (!renderer || !model._WebGPURenderWindow) {
        vtkErrorMacro27("Renderer and view must be set before calling Select.");
        return false;
      }
      model._WebGPURenderWindow.getRenderable().preRender();
      if (!model._WebGPURenderWindow.getInitialized()) {
        model._WebGPURenderWindow.initialize();
        await new Promise((resolve) => {
          model._WebGPURenderWindow.onInitialized(resolve);
        });
      }
      const webGPURenderer = model._WebGPURenderWindow.getViewNodeFor(renderer);
      if (!webGPURenderer) {
        return false;
      }
      const originalSuppress = webGPURenderer.getSuppressClear();
      webGPURenderer.setSuppressClear(true);
      model._selectionPass.traverse(model._WebGPURenderWindow, webGPURenderer);
      webGPURenderer.setSuppressClear(originalSuppress);
      const device = model._WebGPURenderWindow.getDevice();
      const texture = model._selectionPass.getColorTexture();
      const depthTexture = model._selectionPass.getDepthTexture();
      const result = {
        area: [0, 0, texture.getWidth() - 1, texture.getHeight() - 1],
        captureZValues: model.captureZValues,
        fieldAssociation: model.fieldAssociation,
        renderer,
        webGPURenderer,
        webGPURenderWindow: model._WebGPURenderWindow,
        width: texture.getWidth(),
        height: texture.getHeight()
      };
      result.colorBufferWidth = 16 * Math.floor((result.width + 15) / 16);
      result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 4 * 4;
      const colorBuffer = vtkWebGPUBuffer$1.newInstance({
        label: "hardwareSelectColorBuffer"
      });
      colorBuffer.setDevice(device);
      colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      const cmdEnc = model._WebGPURenderWindow.getCommandEncoder();
      cmdEnc.copyTextureToBuffer({
        texture: texture.getHandle()
      }, {
        buffer: colorBuffer.getHandle(),
        bytesPerRow: 16 * result.colorBufferWidth,
        rowsPerImage: result.height
      }, {
        width: result.width,
        height: result.height,
        depthOrArrayLayers: 1
      });
      let zbuffer;
      if (model.captureZValues) {
        result.zbufferBufferWidth = 64 * Math.floor((result.width + 63) / 64);
        zbuffer = vtkWebGPUBuffer$1.newInstance({
          label: "hardwareSelectDepthBuffer"
        });
        zbuffer.setDevice(device);
        result.zbufferSizeInBytes = result.height * result.zbufferBufferWidth * 4;
        zbuffer.create(result.zbufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
        cmdEnc.copyTextureToBuffer({
          texture: depthTexture.getHandle(),
          aspect: "depth-only"
        }, {
          buffer: zbuffer.getHandle(),
          bytesPerRow: 4 * result.zbufferBufferWidth,
          rowsPerImage: result.height
        }, {
          width: result.width,
          height: result.height,
          depthOrArrayLayers: 1
        });
      }
      device.submitCommandEncoder(cmdEnc);
      const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
      if (model.captureZValues) {
        const zLoad = zbuffer.mapAsync(GPUMapMode.READ);
        await Promise.all([cLoad, zLoad]);
        result.depthValues = new Float32Array(zbuffer.getMappedRange().slice());
        zbuffer.unmap();
      } else {
        await cLoad;
      }
      result.colorValues = new Uint32Array(colorBuffer.getMappedRange().slice());
      colorBuffer.unmap();
      result.generateSelection = (fx1, fy1, fx2, fy2) => generateSelectionWithData2(result, fx1, fy1, fx2, fy2);
      return result;
    };
  }
  var DEFAULT_VALUES85 = {
    // WebGPURenderWindow: null,
  };
  function extend87(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES85, initialValues);
    vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
    model._selectionPass = vtkWebGPUHardwareSelectionPass$1.newInstance();
    macro.setGet(publicAPI, model, ["_WebGPURenderWindow"]);
    macro.moveToProtected(publicAPI, model, ["WebGPURenderWindow"]);
    vtkWebGPUHardwareSelector(publicAPI, model);
  }
  var newInstance87 = macro.newInstance(extend87, "vtkWebGPUHardwareSelector");
  var vtkWebGPUHardwareSelector$1 = {
    newInstance: newInstance87,
    extend: extend87
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
  var CLASS_MAPPING2 = /* @__PURE__ */ Object.create(null);
  function registerOverride2(className, fn) {
    CLASS_MAPPING2[className] = fn;
  }
  function vtkWebGPUViewNodeFactory(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUViewNodeFactory");
  }
  var DEFAULT_VALUES86 = {};
  function extend88(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES86, initialValues);
    model.overrides = CLASS_MAPPING2;
    vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
    vtkWebGPUViewNodeFactory(publicAPI, model);
  }
  var newInstance88 = macro.newInstance(extend88, "vtkWebGPUViewNodeFactory");
  var vtkWebGPUViewNodeFactory$1 = {
    newInstance: newInstance88,
    extend: extend88
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderWindow.js
  var {
    vtkErrorMacro: vtkErrorMacro28
  } = macro;
  var SCREENSHOT_PLACEHOLDER2 = {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%"
  };
  function vtkWebGPURenderWindow(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPURenderWindow");
    publicAPI.getViewNodeFactory = () => model.myFactory;
    const previousSize = [0, 0];
    function updateWindow() {
      if (model.renderable) {
        if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
          previousSize[0] = model.size[0];
          previousSize[1] = model.size[1];
          model.canvas.setAttribute("width", model.size[0]);
          model.canvas.setAttribute("height", model.size[1]);
          publicAPI.recreateSwapChain();
        }
      }
      if (model.viewStream) {
        model.viewStream.setSize(model.size[0], model.size[1]);
      }
      model.canvas.style.display = model.useOffScreen ? "none" : "block";
      if (model.el) {
        model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
      }
      model.containerSize = null;
    }
    publicAPI.onModified(updateWindow);
    publicAPI.recreateSwapChain = () => {
      if (model.context) {
        model.context.unconfigure();
        model.presentationFormat = navigator.gpu.getPreferredCanvasFormat(model.adapter);
        model.context.configure({
          device: model.device.getHandle(),
          format: model.presentationFormat,
          alphaMode: "premultiplied",
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
          width: model.size[0],
          height: model.size[1]
        });
        model._configured = true;
      }
    };
    publicAPI.getCurrentTexture = () => model.context.getCurrentTexture();
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
        publicAPI.removeUnusedNodes();
        publicAPI.initialize();
      } else if (model.initialized) {
        if (!model._configured) {
          publicAPI.recreateSwapChain();
        }
        model.commandEncoder = model.device.createCommandEncoder();
      }
    };
    publicAPI.initialize = () => {
      if (!model.initializing) {
        model.initializing = true;
        if (!navigator.gpu) {
          vtkErrorMacro28("WebGPU is not enabled.");
          return;
        }
        publicAPI.create3DContextAsync().then(() => {
          model.initialized = true;
          if (model.deleted) {
            return;
          }
          publicAPI.invokeInitialized();
        });
      }
    };
    publicAPI.setContainer = (el) => {
      if (model.el && model.el !== el) {
        if (model.canvas.parentNode !== model.el) {
          vtkErrorMacro28("Error: canvas parent node does not match container");
        }
        model.el.removeChild(model.canvas);
        if (model.el.contains(model.bgImage)) {
          model.el.removeChild(model.bgImage);
        }
      }
      if (model.el !== el) {
        model.el = el;
        if (model.el) {
          model.el.appendChild(model.canvas);
          if (model.useBackgroundImage) {
            model.el.appendChild(model.bgImage);
          }
        }
        publicAPI.modified();
      }
    };
    publicAPI.getContainer = () => model.el;
    publicAPI.getContainerSize = () => {
      if (!model.containerSize && model.el) {
        const {
          width,
          height
        } = model.el.getBoundingClientRect();
        model.containerSize = [width, height];
      }
      return model.containerSize || model.size;
    };
    publicAPI.getFramebufferSize = () => model.size;
    publicAPI.create3DContextAsync = async () => {
      model.adapter = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (model.deleted) {
        return;
      }
      model.device = vtkWebGPUDevice$1.newInstance();
      model.device.initialize(await model.adapter.requestDevice());
      if (model.deleted) {
        model.device = null;
        return;
      }
      model.context = model.canvas.getContext("webgpu");
    };
    publicAPI.releaseGraphicsResources = () => {
      const rp = vtkRenderPass$1.newInstance();
      rp.setCurrentOperation("Release");
      rp.traverse(publicAPI, null);
      model.adapter = null;
      model.device = null;
      model.context = null;
      model.initialized = false;
      model.initializing = false;
    };
    publicAPI.setBackgroundImage = (img) => {
      model.bgImage.src = img.src;
    };
    publicAPI.setUseBackgroundImage = (value) => {
      model.useBackgroundImage = value;
      if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
        model.el.appendChild(model.bgImage);
      } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    };
    async function getCanvasDataURL() {
      let format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.imageFormat;
      const temporaryCanvas = document.createElement("canvas");
      const temporaryContext = temporaryCanvas.getContext("2d");
      temporaryCanvas.width = model.canvas.width;
      temporaryCanvas.height = model.canvas.height;
      const result = await publicAPI.getPixelsAsync();
      const imageData = new ImageData(result.colorValues, result.width, result.height);
      temporaryContext.putImageData(imageData, 0, 0);
      const mainBoundingClientRect = model.canvas.getBoundingClientRect();
      const renderWindow = model.renderable;
      const renderers = renderWindow.getRenderers();
      renderers.forEach((renderer) => {
        const viewProps = renderer.getViewProps();
        viewProps.forEach((viewProp) => {
          if (viewProp.getContainer) {
            const container = viewProp.getContainer();
            const canvasList = container.getElementsByTagName("canvas");
            for (let i = 0; i < canvasList.length; i++) {
              const currentCanvas = canvasList[i];
              const boundingClientRect = currentCanvas.getBoundingClientRect();
              const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
              const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
              temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
            }
          }
        });
      });
      const screenshot = temporaryCanvas.toDataURL(format2);
      temporaryCanvas.remove();
      publicAPI.invokeImageReady(screenshot);
    }
    publicAPI.captureNextImage = function() {
      let format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
      let {
        resetCamera: resetCamera2 = false,
        size = null,
        scale: scale7 = 1
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (model.deleted) {
        return null;
      }
      model.imageFormat = format2;
      const previous = model.notifyStartCaptureImage;
      model.notifyStartCaptureImage = true;
      model._screenshot = {
        size: !!size || scale7 !== 1 ? size || model.size.map((val) => val * scale7) : null
      };
      return new Promise((resolve, reject) => {
        const subscription = publicAPI.onImageReady((imageURL) => {
          if (model._screenshot.size === null) {
            model.notifyStartCaptureImage = previous;
            subscription.unsubscribe();
            if (model._screenshot.placeHolder) {
              model.size = model._screenshot.originalSize;
              publicAPI.modified();
              if (model._screenshot.cameras) {
                model._screenshot.cameras.forEach((_ref) => {
                  let {
                    restoreParamsFn,
                    arg
                  } = _ref;
                  return restoreParamsFn(arg);
                });
              }
              publicAPI.traverseAllPasses();
              model.el.removeChild(model._screenshot.placeHolder);
              model._screenshot.placeHolder.remove();
              model._screenshot = null;
            }
            resolve(imageURL);
          } else {
            const tmpImg = document.createElement("img");
            tmpImg.style = SCREENSHOT_PLACEHOLDER2;
            tmpImg.src = imageURL;
            model._screenshot.placeHolder = model.el.appendChild(tmpImg);
            model.canvas.style.display = "none";
            model._screenshot.originalSize = model.size;
            model.size = model._screenshot.size;
            model._screenshot.size = null;
            publicAPI.modified();
            if (resetCamera2) {
              const isUserResetCamera = resetCamera2 !== true;
              model._screenshot.cameras = model.renderable.getRenderers().map((renderer) => {
                const camera = renderer.getActiveCamera();
                const params = camera.get("focalPoint", "position", "parallelScale");
                return {
                  resetCameraArgs: isUserResetCamera ? {
                    renderer
                  } : void 0,
                  resetCameraFn: isUserResetCamera ? resetCamera2 : renderer.resetCamera,
                  restoreParamsFn: camera.set,
                  // "clone" the params so we don't keep refs to properties
                  arg: JSON.parse(JSON.stringify(params))
                };
              });
              model._screenshot.cameras.forEach((_ref2) => {
                let {
                  resetCameraFn,
                  resetCameraArgs
                } = _ref2;
                return resetCameraFn(resetCameraArgs);
              });
            }
            publicAPI.traverseAllPasses();
          }
        });
      });
    };
    publicAPI.traverseAllPasses = () => {
      if (model.deleted) {
        return;
      }
      if (!model.initialized) {
        publicAPI.initialize();
        const subscription = publicAPI.onInitialized(() => {
          subscription.unsubscribe();
          publicAPI.traverseAllPasses();
        });
      } else {
        if (model.renderPasses) {
          for (let index = 0; index < model.renderPasses.length; ++index) {
            model.renderPasses[index].traverse(publicAPI, null);
          }
        }
        if (model.commandEncoder) {
          model.device.submitCommandEncoder(model.commandEncoder);
          model.commandEncoder = null;
          if (model.notifyStartCaptureImage) {
            model.device.onSubmittedWorkDone().then(() => {
              getCanvasDataURL();
            });
          }
        }
      }
    };
    publicAPI.setViewStream = (stream) => {
      if (model.viewStream === stream) {
        return false;
      }
      if (model.subscription) {
        model.subscription.unsubscribe();
        model.subscription = null;
      }
      model.viewStream = stream;
      if (model.viewStream) {
        const mainRenderer = model.renderable.getRenderers()[0];
        mainRenderer.getBackgroundByReference()[3] = 0;
        publicAPI.setUseBackgroundImage(true);
        model.subscription = model.viewStream.onImageReady((e) => publicAPI.setBackgroundImage(e.image));
        model.viewStream.setSize(model.size[0], model.size[1]);
        model.viewStream.invalidateCache();
        model.viewStream.render();
        publicAPI.modified();
      }
      return true;
    };
    publicAPI.getUniquePropID = () => model.nextPropID++;
    publicAPI.getPropFromID = (id) => {
      for (let i = 0; i < model.children.length; i++) {
        const res = model.children[i].getPropFromID(id);
        if (res !== null) {
          return res;
        }
      }
      return null;
    };
    publicAPI.getPixelsAsync = async () => {
      const device = model.device;
      const texture = model.renderPasses[0].getOpaquePass().getColorTexture();
      const result = {
        width: texture.getWidth(),
        height: texture.getHeight()
      };
      result.colorBufferWidth = 32 * Math.floor((result.width + 31) / 32);
      result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 8;
      const colorBuffer = vtkWebGPUBuffer$1.newInstance();
      colorBuffer.setDevice(device);
      colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      const cmdEnc = model.device.createCommandEncoder();
      cmdEnc.copyTextureToBuffer({
        texture: texture.getHandle()
      }, {
        buffer: colorBuffer.getHandle(),
        bytesPerRow: 8 * result.colorBufferWidth,
        rowsPerImage: result.height
      }, {
        width: result.width,
        height: result.height,
        depthOrArrayLayers: 1
      });
      device.submitCommandEncoder(cmdEnc);
      const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
      await cLoad;
      result.colorValues = new Uint16Array(colorBuffer.getMappedRange().slice());
      colorBuffer.unmap();
      const tmparray = new Uint8ClampedArray(result.height * result.width * 4);
      for (let y = 0; y < result.height; y++) {
        for (let x = 0; x < result.width; x++) {
          const doffset = (y * result.width + x) * 4;
          const soffset = (y * result.colorBufferWidth + x) * 4;
          tmparray[doffset] = 255 * HalfFloat.fromHalf(result.colorValues[soffset]);
          tmparray[doffset + 1] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 1]);
          tmparray[doffset + 2] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 2]);
          tmparray[doffset + 3] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 3]);
        }
      }
      result.colorValues = tmparray;
      return result;
    };
    publicAPI.createSelector = () => {
      const ret = vtkWebGPUHardwareSelector$1.newInstance();
      ret.setWebGPURenderWindow(publicAPI);
      return ret;
    };
    const superSetSize = publicAPI.setSize;
    publicAPI.setSize = (width, height) => {
      const modified = superSetSize(width, height);
      if (modified) {
        publicAPI.invokeWindowResizeEvent({
          width,
          height
        });
      }
      return modified;
    };
    publicAPI.delete = macro.chain(publicAPI.delete, publicAPI.setViewStream);
  }
  var DEFAULT_VALUES87 = {
    initialized: false,
    context: null,
    adapter: null,
    device: null,
    canvas: null,
    cursorVisibility: true,
    cursor: "pointer",
    containerSize: null,
    renderPasses: [],
    notifyStartCaptureImage: false,
    imageFormat: "image/png",
    useOffScreen: false,
    useBackgroundImage: false,
    nextPropID: 1,
    xrSupported: false,
    presentationFormat: null
  };
  function extend89(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES87, initialValues);
    model.canvas = document.createElement("canvas");
    model.canvas.style.width = "100%";
    model.bgImage = new Image();
    model.bgImage.style.position = "absolute";
    model.bgImage.style.left = "0";
    model.bgImage.style.top = "0";
    model.bgImage.style.width = "100%";
    model.bgImage.style.height = "100%";
    model.bgImage.style.zIndex = "-1";
    vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
    model.myFactory = vtkWebGPUViewNodeFactory$1.newInstance();
    model.renderPasses[0] = vtkForwardPass$12.newInstance();
    if (!model.selector) {
      model.selector = vtkWebGPUHardwareSelector$1.newInstance();
      model.selector.setWebGPURenderWindow(publicAPI);
    }
    macro.event(publicAPI, model, "imageReady");
    macro.event(publicAPI, model, "initialized");
    macro.get(publicAPI, model, ["commandEncoder", "device", "presentationFormat", "useBackgroundImage", "xrSupported"]);
    macro.setGet(publicAPI, model, ["initialized", "context", "canvas", "device", "renderPasses", "notifyStartCaptureImage", "cursor", "useOffScreen"]);
    macro.setGetArray(publicAPI, model, ["size"], 2);
    macro.event(publicAPI, model, "windowResizeEvent");
    vtkWebGPURenderWindow(publicAPI, model);
  }
  var newInstance89 = macro.newInstance(extend89, "vtkWebGPURenderWindow");
  registerViewConstructor("WebGPU", newInstance89);
  registerOverride2("vtkRenderWindow", newInstance89);

  // node_modules/@kitware/vtk.js/Rendering/Misc/FullScreenRenderWindow.js
  var userParams = vtkURLExtract.extractURLParameters();
  var STYLE_CONTAINER = {
    margin: "0",
    padding: "0",
    position: "absolute",
    top: "0",
    left: "0",
    width: "100%",
    height: "100%",
    overflow: "hidden"
  };
  var STYLE_CONTROL_PANEL = {
    position: "absolute",
    left: "25px",
    top: "25px",
    backgroundColor: "white",
    borderRadius: "5px",
    listStyle: "none",
    padding: "5px 10px",
    margin: "0",
    display: "block",
    border: "solid 1px black",
    maxWidth: "calc(100% - 70px)",
    maxHeight: "calc(100% - 60px)",
    overflow: "auto"
  };
  function applyStyle(el, style) {
    Object.keys(style).forEach((key) => {
      el.style[key] = style[key];
    });
  }
  function vtkFullScreenRenderWindow(publicAPI, model) {
    model.classHierarchy.push("vtkFullScreenRenderWindow");
    const body = document.querySelector("body");
    if (!model.rootContainer) {
      model.rootContainer = body;
    }
    if (!model.container) {
      model.container = document.createElement("div");
      applyStyle(model.container, model.containerStyle || STYLE_CONTAINER);
      model.rootContainer.appendChild(model.container);
    }
    if (model.rootContainer === body) {
      document.documentElement.style.height = "100%";
      body.style.height = "100%";
      body.style.padding = "0";
      body.style.margin = "0";
    }
    model.renderWindow = vtkRenderWindow$1.newInstance();
    model.renderer = vtkRenderer$1.newInstance();
    model.renderWindow.addRenderer(model.renderer);
    model.apiSpecificRenderWindow = model.renderWindow.newAPISpecificView(userParams.viewAPI ?? model.defaultViewAPI);
    model.apiSpecificRenderWindow.setContainer(model.container);
    model.renderWindow.addView(model.apiSpecificRenderWindow);
    model.interactor = vtkRenderWindowInteractor$1.newInstance();
    model.interactor.setInteractorStyle(vtkInteractorStyleTrackballCamera$1.newInstance());
    model.interactor.setView(model.apiSpecificRenderWindow);
    model.interactor.initialize();
    model.interactor.bindEvents(model.container);
    publicAPI.setBackground = model.renderer.setBackground;
    publicAPI.removeController = () => {
      const el = model.controlContainer;
      if (el) {
        el.parentNode.removeChild(el);
      }
    };
    publicAPI.setControllerVisibility = (visible) => {
      model.controllerVisibility = visible;
      if (model.controlContainer) {
        if (visible) {
          model.controlContainer.style.display = "block";
        } else {
          model.controlContainer.style.display = "none";
        }
      }
    };
    publicAPI.toggleControllerVisibility = () => {
      publicAPI.setControllerVisibility(!model.controllerVisibility);
    };
    function handleKeypress(e) {
      if (String.fromCharCode(e.charCode) === "c") {
        publicAPI.toggleControllerVisibility();
      }
    }
    publicAPI.addController = (html) => {
      model.controlContainer = document.createElement("div");
      applyStyle(model.controlContainer, model.controlPanelStyle || STYLE_CONTROL_PANEL);
      model.rootContainer.appendChild(model.controlContainer);
      model.controlContainer.innerHTML = html;
      publicAPI.setControllerVisibility(model.controllerVisibility);
      model.rootContainer.addEventListener("keypress", handleKeypress);
    };
    publicAPI.setBackground(...model.background);
    publicAPI.addRepresentation = (representation) => {
      representation.getActors().forEach((actor) => {
        model.renderer.addActor(actor);
      });
    };
    publicAPI.removeRepresentation = (representation) => {
      representation.getActors().forEach((actor) => model.renderer.removeActor(actor));
    };
    publicAPI.delete = macro.chain(publicAPI.setContainer, model.apiSpecificRenderWindow.delete, () => {
      model.rootContainer?.removeEventListener("keypress", handleKeypress);
      window.removeEventListener("resize", publicAPI.resize);
    }, publicAPI.delete);
    publicAPI.resize = () => {
      const dims = model.container.getBoundingClientRect();
      const devicePixelRatio = window.devicePixelRatio || 1;
      model.apiSpecificRenderWindow.setSize(Math.floor(dims.width * devicePixelRatio), Math.floor(dims.height * devicePixelRatio));
      if (model.resizeCallback) {
        model.resizeCallback(dims);
      }
      model.renderWindow.render();
    };
    publicAPI.setResizeCallback = (cb) => {
      model.resizeCallback = cb;
      publicAPI.resize();
    };
    if (model.listenWindowResize) {
      window.addEventListener("resize", publicAPI.resize);
    }
    publicAPI.resize();
  }
  var DEFAULT_VALUES88 = {
    background: [0.32, 0.34, 0.43],
    containerStyle: null,
    controlPanelStyle: null,
    // defaultViewAPI: undefined,
    listenWindowResize: true,
    resizeCallback: null,
    controllerVisibility: true
  };
  function extend90(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES88, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["renderWindow", "renderer", "apiSpecificRenderWindow", "interactor", "rootContainer", "container", "controlContainer"]);
    vtkFullScreenRenderWindow(publicAPI, model);
  }
  var newInstance90 = macro.newInstance(extend90);
  var vtkFullScreenRenderWindow$1 = {
    newInstance: newInstance90,
    extend: extend90
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
  function vtkOpenGLCamera(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLCamera");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        model.context = model._openGLRenderWindow.getContext();
      }
    };
    publicAPI.opaquePass = (prepass) => {
      if (prepass) {
        const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
        model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
        model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      }
    };
    publicAPI.translucentPass = publicAPI.opaquePass;
    publicAPI.zBufferPass = publicAPI.opaquePass;
    publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
    publicAPI.volumePass = publicAPI.opaquePass;
    publicAPI.getKeyMatrices = (ren) => {
      if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
        mat4_exports.copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
        mat3_exports.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
        mat3_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat4_exports.transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
        const aspectRatio = model._openGLRenderer.getAspectRatio();
        mat4_exports.copy(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
        mat4_exports.transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
        mat4_exports.multiply(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
        model.keyMatrixTime.modified();
        model.lastRenderer = ren;
      }
      return model.keyMatrices;
    };
  }
  var DEFAULT_VALUES89 = {
    context: null,
    lastRenderer: null,
    keyMatrixTime: null,
    keyMatrices: null
  };
  function extend91(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES89, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatrixTime = {};
    obj(model.keyMatrixTime);
    model.keyMatrices = {
      normalMatrix: new Float64Array(9),
      vcpc: new Float64Array(16),
      wcvc: new Float64Array(16),
      wcpc: new Float64Array(16)
    };
    setGet(publicAPI, model, ["context", "keyMatrixTime"]);
    vtkOpenGLCamera(publicAPI, model);
  }
  var newInstance91 = newInstance(extend91);
  registerOverride("vtkCamera", newInstance91);

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
  var {
    vtkDebugMacro: vtkDebugMacro6
  } = macro$1;
  function vtkOpenGLRenderer(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLRenderer");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        publicAPI.updateLights();
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.renderable.getActiveCamera());
        publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps(), true);
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.updateLights = () => {
      let count = 0;
      const lights = model.renderable.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        if (lights[index].getSwitch() > 0) {
          count++;
        }
      }
      if (!count) {
        vtkDebugMacro6("No lights are on, creating one.");
        model.renderable.createLight();
      }
      return count;
    };
    publicAPI.zBufferPass = (prepass) => {
      if (prepass) {
        let clearMask = 0;
        const gl = model.context;
        if (!model.renderable.getTransparent()) {
          model.context.clearColor(1, 0, 0, 1);
          clearMask |= gl.COLOR_BUFFER_BIT;
        }
        if (!model.renderable.getPreserveDepthBuffer()) {
          gl.clearDepth(1);
          clearMask |= gl.DEPTH_BUFFER_BIT;
          model.context.depthMask(true);
        }
        const ts = publicAPI.getTiledSizeAndOrigin();
        gl.enable(gl.SCISSOR_TEST);
        gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
        gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
        gl.colorMask(true, true, true, true);
        if (clearMask) {
          gl.clear(clearMask);
        }
        gl.enable(gl.DEPTH_TEST);
      }
    };
    publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
    publicAPI.cameraPass = (prepass) => {
      if (prepass) {
        publicAPI.clear();
      }
    };
    publicAPI.getAspectRatio = () => {
      const size = model._parent.getSizeByReference();
      const viewport = model.renderable.getViewportByReference();
      return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
    };
    publicAPI.getTiledSizeAndOrigin = () => {
      const vport = model.renderable.getViewportByReference();
      const tileViewPort = [0, 0, 1, 1];
      const vpu = vport[0] - tileViewPort[0];
      const vpv = vport[1] - tileViewPort[1];
      const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
      const lowerLeftU = Math.round(ndvp[0]);
      const lowerLeftV = Math.round(ndvp[1]);
      const vpu2 = vport[2] - tileViewPort[0];
      const vpv2 = vport[3] - tileViewPort[1];
      const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
      let usize = Math.round(ndvp2[0]) - lowerLeftU;
      let vsize = Math.round(ndvp2[1]) - lowerLeftV;
      if (usize < 0) {
        usize = 0;
      }
      if (vsize < 0) {
        vsize = 0;
      }
      return {
        usize,
        vsize,
        lowerLeftU,
        lowerLeftV
      };
    };
    publicAPI.clear = () => {
      let clearMask = 0;
      const gl = model.context;
      if (!model.renderable.getTransparent()) {
        const background = model.renderable.getBackgroundByReference();
        gl.clearColor(background[0], background[1], background[2], background[3]);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        gl.depthMask(true);
      }
      gl.colorMask(true, true, true, true);
      const ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      if (clearMask) {
        gl.clear(clearMask);
      }
      gl.enable(gl.DEPTH_TEST);
    };
    publicAPI.releaseGraphicsResources = () => {
      if (model.selector !== null) {
        model.selector.releaseGraphicsResources();
      }
      if (model.renderable) {
        model.renderable.getViewProps().forEach((prop) => {
          prop.modified();
        });
      }
    };
    publicAPI.setOpenGLRenderWindow = (rw) => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };
  }
  var DEFAULT_VALUES90 = {
    context: null,
    _openGLRenderWindow: null,
    selector: null
  };
  function extend92(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES90, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    get(publicAPI, model, ["shaderCache"]);
    setGet(publicAPI, model, ["selector"]);
    moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
    vtkOpenGLRenderer(publicAPI, model);
  }
  var newInstance92 = newInstance(extend92, "vtkOpenGLRenderer");
  registerOverride("vtkRenderer", newInstance92);

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js
  function vtkOpenGLActor(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLActor");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
        model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
        model.context = model._openGLRenderWindow.getContext();
        publicAPI.prepareNodes();
        publicAPI.addMissingNodes(model.renderable.getTextures());
        publicAPI.addMissingNode(model.renderable.getMapper());
        publicAPI.removeUnusedNodes();
        model.ogltextures = null;
        model.activeTextures = null;
        for (let index = 0; index < model.children.length; index++) {
          const child = model.children[index];
          if (child.isA("vtkOpenGLTexture")) {
            if (!model.ogltextures) {
              model.ogltextures = [];
            }
            model.ogltextures.push(child);
          } else {
            model.oglmapper = child;
          }
        }
      }
    };
    publicAPI.traverseZBufferPass = (renderPass) => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };
    publicAPI.traverseOpaqueZBufferPass = (renderPass) => publicAPI.traverseOpaquePass(renderPass);
    publicAPI.traverseOpaquePass = (renderPass) => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };
    publicAPI.traverseTranslucentPass = (renderPass) => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };
    publicAPI.activateTextures = () => {
      if (!model.ogltextures) {
        return;
      }
      model.activeTextures = [];
      for (let index = 0; index < model.ogltextures.length; index++) {
        const child = model.ogltextures[index];
        child.render();
        if (child.getHandle()) {
          model.activeTextures.push(child);
        }
      }
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        if (model.renderable.getIsOpaque()) {
          renderPass.incrementOpaqueActorCount();
        } else {
          renderPass.incrementTranslucentActorCount();
        }
      }
    };
    publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
    publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(true);
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };
    publicAPI.translucentPass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(model._openGLRenderer.getSelector() && model.renderable.getNestedPickable());
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };
    publicAPI.getKeyMatrices = () => {
      if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
        model.renderable.computeMatrix();
        mat4_exports.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
        mat4_exports.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
        if (model.renderable.getIsIdentity()) {
          mat3_exports.identity(model.keyMatrices.normalMatrix);
        } else {
          mat3_exports.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);
          mat3_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
          mat3_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        }
        model.keyMatrixTime.modified();
      }
      return model.keyMatrices;
    };
  }
  var DEFAULT_VALUES91 = {
    context: null,
    keyMatrixTime: null,
    keyMatrices: null,
    activeTextures: null
  };
  function extend93(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES91, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatrixTime = {};
    obj(model.keyMatrixTime, {
      mtime: 0
    });
    model.keyMatrices = {
      normalMatrix: mat3_exports.identity(new Float64Array(9)),
      mcwc: mat4_exports.identity(new Float64Array(16))
    };
    setGet(publicAPI, model, ["context"]);
    get(publicAPI, model, ["activeTextures"]);
    vtkOpenGLActor(publicAPI, model);
  }
  var newInstance93 = newInstance(extend93);
  registerOverride("vtkActor", newInstance93);

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js
  function vtkOpenGLActor2D(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLActor2D");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
        model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
        model.context = model._openGLRenderWindow.getContext();
        publicAPI.prepareNodes();
        publicAPI.addMissingNodes(model.renderable.getTextures());
        publicAPI.addMissingNode(model.renderable.getMapper());
        publicAPI.removeUnusedNodes();
        model.ogltextures = null;
        model.activeTextures = null;
        for (let index = 0; index < model.children.length; index++) {
          const child = model.children[index];
          if (child.isA("vtkOpenGLTexture")) {
            if (!model.ogltextures) {
              model.ogltextures = [];
            }
            model.ogltextures.push(child);
          } else {
            model.oglmapper = child;
          }
        }
      }
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        renderPass.incrementOverlayActorCount();
      }
    };
    publicAPI.traverseOpaquePass = (renderPass) => {
      if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };
    publicAPI.traverseTranslucentPass = (renderPass) => {
      if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };
    publicAPI.traverseOverlayPass = (renderPass) => {
      if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };
    publicAPI.activateTextures = () => {
      if (!model.ogltextures) {
        return;
      }
      model.activeTextures = [];
      for (let index = 0; index < model.ogltextures.length; index++) {
        const child = model.ogltextures[index];
        child.render();
        if (child.getHandle()) {
          model.activeTextures.push(child);
        }
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(true);
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };
    publicAPI.translucentPass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(false);
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };
    publicAPI.overlayPass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(true);
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };
  }
  var DEFAULT_VALUES92 = {
    context: null,
    activeTextures: null
  };
  function extend94(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES92, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    setGet(publicAPI, model, ["context"]);
    get(publicAPI, model, ["activeTextures"]);
    vtkOpenGLActor2D(publicAPI, model);
  }
  var newInstance94 = newInstance(extend94);
  registerOverride("vtkActor2D", newInstance94);

  // node_modules/d3-array/src/ascending.js
  function ascending(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-array/src/descending.js
  function descending(a, b) {
    return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d, x) => ascending(f(d), x);
      delta = (d, x) => f(d) - x;
    } else {
      compare1 = f === ascending || f === descending ? f : zero3;
      compare2 = f;
      delta = f;
    }
    function left(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) <= 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center(a, x, lo = 0, hi = a.length) {
      const i = left(a, x, lo, hi - 1);
      return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }
    return { left, center, right };
  }
  function zero3() {
    return 0;
  }

  // node_modules/d3-array/src/number.js
  function number(x) {
    return x === null ? NaN : +x;
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number).center;
  var bisect_default = bisectRight;

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function tickSpec(start, stop, count) {
    const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start * inc);
      i2 = Math.round(stop * inc);
      if (i1 / inc < start) ++i1;
      if (i2 / inc > stop) --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start / inc);
      i2 = Math.round(stop / inc);
      if (i1 * inc < start) ++i1;
      if (i2 * inc > stop) --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
    return [i1, i2, inc];
  }
  function ticks(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    if (!(count > 0)) return [];
    if (start === stop) return [start];
    const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
    if (!(i2 >= i1)) return [];
    const n = i2 - i1 + 1, ticks2 = new Array(n);
    if (reverse) {
      if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
      else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
    } else {
      if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
      else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    return tickSpec(start, stop, count)[2];
  }
  function tickStep(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
    return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
  }

  // node_modules/d3-scale/src/init.js
  function initRange(domain, range) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range).domain(domain);
        break;
    }
    return this;
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend95(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend95(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max4 = Math.max(r, g, b), h = NaN, s = max4 - min4, l = (max4 + min4) / 2;
    if (s) {
      if (r === max4) h = (g - b) / s + (g < b) * 6;
      else if (g === max4) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }
  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend95(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default = (x) => () => x;

  // node_modules/d3-interpolate/src/color.js
  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }
  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }
  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = (function rgbGamma(y) {
    var color2 = gamma(y);
    function rgb2(start, end) {
      var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  })(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
      for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }
  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  // node_modules/d3-interpolate/src/array.js
  function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i) x[i] = value_default(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/date.js
  function date_default(a, b) {
    var d = /* @__PURE__ */ new Date();
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  // node_modules/d3-interpolate/src/number.js
  function number_default(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  // node_modules/d3-interpolate/src/object.js
  function object_default(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};
    for (k in b) {
      if (k in a) {
        i[k] = value_default(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero4(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs;
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm;
        else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero4(b) : (b = q.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
      return s.join("");
    });
  }

  // node_modules/d3-interpolate/src/value.js
  function value_default(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
  }

  // node_modules/d3-interpolate/src/round.js
  function round_default(a, b) {
    return a = +a, b = +b, function(t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }

  // node_modules/d3-scale/src/constant.js
  function constants(x) {
    return function() {
      return x;
    };
  }

  // node_modules/d3-scale/src/number.js
  function number2(x) {
    return +x;
  }

  // node_modules/d3-scale/src/continuous.js
  var unit = [0, 1];
  function identity6(x) {
    return x;
  }
  function normalize5(a, b) {
    return (b -= a = +a) ? function(x) {
      return (x - a) / b;
    } : constants(isNaN(b) ? NaN : 0.5);
  }
  function clamper(a, b) {
    var t;
    if (a > b) t = a, a = b, b = t;
    return function(x) {
      return Math.max(a, Math.min(b, x));
    };
  }
  function bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = normalize5(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize5(d0, d1), r0 = interpolate(r0, r1);
    return function(x) {
      return r0(d0(x));
    };
  }
  function polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++i < j) {
      d[i] = normalize5(domain[i], domain[i + 1]);
      r[i] = interpolate(range[i], range[i + 1]);
    }
    return function(x) {
      var i2 = bisect_default(domain, x, 1, j) - 1;
      return r[i2](d[i2](x));
    };
  }
  function copy6(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer() {
    var domain = unit, range = unit, interpolate = value_default, transform, untransform, unknown, clamp = identity6, piecewise, output, input;
    function rescale() {
      var n = Math.min(domain.length, range.length);
      if (clamp !== identity6) clamp = clamper(domain[0], domain[n - 1]);
      piecewise = n > 2 ? polymap : bimap;
      output = input = null;
      return scale7;
    }
    function scale7(x) {
      return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
    }
    scale7.invert = function(y) {
      return clamp(untransform((input || (input = piecewise(range, domain.map(transform), number_default)))(y)));
    };
    scale7.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
    };
    scale7.range = function(_) {
      return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };
    scale7.rangeRound = function(_) {
      return range = Array.from(_), interpolate = round_default, rescale();
    };
    scale7.clamp = function(_) {
      return arguments.length ? (clamp = _ ? true : identity6, rescale()) : clamp !== identity6;
    };
    scale7.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };
    scale7.unknown = function(_) {
      return arguments.length ? (unknown = _, scale7) : unknown;
    };
    return function(t, u) {
      transform = t, untransform = u;
      return rescale();
    };
  }
  function continuous() {
    return transformer()(identity6, identity6);
  }

  // node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x) {
    return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
  }
  function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
    var i, coefficient = x.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  // node_modules/d3-format/src/exponent.js
  function exponent_default(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
  }

  // node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width) {
      var i = value.length, t = [], j = 0, g = grouping[0], length4 = 0;
      while (i > 0 && g > 0) {
        if (length4 + g + 1 > width) g = Math.max(1, width - length4);
        t.push(value.substring(i -= g, i + g));
        if ((length4 += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }

  // node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0) i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i]) break out;
          if (i0 > 0) i0 = 0;
          break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  // node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
  }

  // node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x, p) => (x * 100).toFixed(p),
    "b": (x) => Math.round(x).toString(2),
    "c": (x) => x + "",
    "d": formatDecimal_default,
    "e": (x, p) => x.toExponential(p),
    "f": (x, p) => x.toFixed(p),
    "g": (x, p) => x.toPrecision(p),
    "o": (x) => Math.round(x).toString(8),
    "p": (x, p) => formatRounded_default(x * 100, p),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x) => Math.round(x).toString(16).toUpperCase(),
    "x": (x) => Math.round(x).toString(16)
  };

  // node_modules/d3-format/src/identity.js
  function identity_default(x) {
    return x;
  }

  // node_modules/d3-format/src/locale.js
  var map = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale2) {
    var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero5 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
      if (type === "n") comma = true, type = "g";
      else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
      if (zero5 || fill === "0" && align === "=") zero5 = true, fill = "0", align = "=";
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
      var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format2(value) {
        var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
          if (trim) value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
          valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero5) value = group(value, Infinity);
        var length4 = valuePrefix.length + value.length + valueSuffix.length, padding = length4 < width ? new Array(width - length4 + 1).join(fill) : "";
        if (comma && zero5) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length4 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length4);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
      return function(value2) {
        return f(k * value2) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // node_modules/d3-format/src/precisionFixed.js
  function precisionFixed_default(step) {
    return Math.max(0, -exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionPrefix.js
  function precisionPrefix_default(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionRound.js
  function precisionRound_default(step, max4) {
    step = Math.abs(step), max4 = Math.abs(max4) - step;
    return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
  }

  // node_modules/d3-scale/src/tickFormat.js
  function tickFormat(start, stop, count, specifier) {
    var step = tickStep(start, stop, count), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  // node_modules/d3-scale/src/linear.js
  function linearish(scale7) {
    var domain = scale7.domain;
    scale7.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale7.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale7.nice = function(count) {
      if (count == null) count = 10;
      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start, stop, count);
        if (step === prestep) {
          d[i0] = start;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale7;
    };
    return scale7;
  }
  function linear2() {
    var scale7 = continuous();
    scale7.copy = function() {
      return copy6(scale7, linear2());
    };
    initRange.apply(scale7, arguments);
    return linearish(scale7);
  }

  // node_modules/@kitware/vtk.js/Rendering/Core/CubeAxesActor.js
  var faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
  var faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];
  var edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];
  var edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];
  var faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];
  var ptv3 = new Float64Array(3);
  var pt2v3 = new Float64Array(3);
  var tmpv3 = new Float64Array(3);
  var tmp2v3 = new Float64Array(3);
  var xDir = new Float64Array(3);
  var yDir = new Float64Array(3);
  var invmat = new Float64Array(16);
  function applyTextStyle(ctx, style) {
    ctx.strokeStyle = style.strokeColor;
    ctx.lineWidth = style.strokeSize;
    ctx.fillStyle = style.fontColor;
    ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
  }
  function defaultGenerateTicks(dataBounds) {
    const ticks2 = [];
    const tickStrings = [];
    for (let i = 0; i < 3; i++) {
      const scale7 = linear2().domain([dataBounds[i * 2], dataBounds[i * 2 + 1]]);
      ticks2[i] = scale7.ticks(5);
      const format2 = scale7.tickFormat(5);
      tickStrings[i] = ticks2[i].map(format2);
    }
    return {
      ticks: ticks2,
      tickStrings
    };
  }
  function vtkCubeAxesActorHelper(publicAPI, model) {
    model.classHierarchy.push("vtkCubeAxesActorHelper");
    publicAPI.setRenderable = (renderable) => {
      if (model.renderable === renderable) {
        return;
      }
      model.renderable = renderable;
      model.tmActor.addTexture(model.renderable.getTmTexture());
      model.tmActor.setProperty(renderable.getProperty());
      model.tmActor.setParentProp(renderable);
      publicAPI.modified();
    };
    publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {
      const value = model.renderable.get_tmAtlas().get(text);
      if (!value) {
        return;
      }
      const coords = model.renderable.getTextPolyData().getPoints().getData();
      const size = model.lastSize;
      ptv3[0] = coords[pos * 3];
      ptv3[1] = coords[pos * 3 + 1];
      ptv3[2] = coords[pos * 3 + 2];
      vec3_exports.transformMat4(tmpv3, ptv3, cmat);
      tmpv3[0] += 0.1;
      vec3_exports.transformMat4(pt2v3, tmpv3, imat);
      vec3_exports.subtract(xDir, pt2v3, ptv3);
      tmpv3[0] -= 0.1;
      tmpv3[1] += 0.1;
      vec3_exports.transformMat4(pt2v3, tmpv3, imat);
      vec3_exports.subtract(yDir, pt2v3, ptv3);
      for (let i = 0; i < 3; i++) {
        xDir[i] /= 0.5 * 0.1 * size[0];
        yDir[i] /= 0.5 * 0.1 * size[1];
      }
      let ptIdx = results.ptIdx;
      let cellIdx = results.cellIdx;
      ptv3[0] = coords[pos * 3];
      ptv3[1] = coords[pos * 3 + 1];
      ptv3[2] = coords[pos * 3 + 2];
      if (dir[0] < -0.5) {
        vec3_exports.scale(tmpv3, xDir, dir[0] * offset - value.width);
      } else if (dir[0] > 0.5) {
        vec3_exports.scale(tmpv3, xDir, dir[0] * offset);
      } else {
        vec3_exports.scale(tmpv3, xDir, dir[0] * offset - value.width / 2);
      }
      vec3_exports.add(ptv3, ptv3, tmpv3);
      vec3_exports.scale(tmpv3, yDir, dir[1] * offset - value.height / 2);
      vec3_exports.add(ptv3, ptv3, tmpv3);
      results.points[ptIdx * 3] = ptv3[0];
      results.points[ptIdx * 3 + 1] = ptv3[1];
      results.points[ptIdx * 3 + 2] = ptv3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[0];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
      ptIdx++;
      vec3_exports.scale(tmpv3, xDir, value.width);
      vec3_exports.add(ptv3, ptv3, tmpv3);
      results.points[ptIdx * 3] = ptv3[0];
      results.points[ptIdx * 3 + 1] = ptv3[1];
      results.points[ptIdx * 3 + 2] = ptv3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[2];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
      ptIdx++;
      vec3_exports.scale(tmpv3, yDir, value.height);
      vec3_exports.add(ptv3, ptv3, tmpv3);
      results.points[ptIdx * 3] = ptv3[0];
      results.points[ptIdx * 3 + 1] = ptv3[1];
      results.points[ptIdx * 3 + 2] = ptv3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[4];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
      ptIdx++;
      vec3_exports.scale(tmpv3, xDir, value.width);
      vec3_exports.subtract(ptv3, ptv3, tmpv3);
      results.points[ptIdx * 3] = ptv3[0];
      results.points[ptIdx * 3 + 1] = ptv3[1];
      results.points[ptIdx * 3 + 2] = ptv3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[6];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
      ptIdx++;
      results.polys[cellIdx * 4] = 3;
      results.polys[cellIdx * 4 + 1] = ptIdx - 4;
      results.polys[cellIdx * 4 + 2] = ptIdx - 3;
      results.polys[cellIdx * 4 + 3] = ptIdx - 2;
      cellIdx++;
      results.polys[cellIdx * 4] = 3;
      results.polys[cellIdx * 4 + 1] = ptIdx - 4;
      results.polys[cellIdx * 4 + 2] = ptIdx - 2;
      results.polys[cellIdx * 4 + 3] = ptIdx - 1;
      results.ptIdx += 4;
      results.cellIdx += 2;
    };
    publicAPI.updateTexturePolyData = () => {
      const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);
      mat4_exports.transpose(cmat, cmat);
      const numLabels = model.renderable.getTextValues().length;
      const numPts = numLabels * 4;
      const numTris = numLabels * 2;
      const points = new Float64Array(numPts * 3);
      const polys = new Uint16Array(numTris * 4);
      const tcoords = new Float32Array(numPts * 2);
      mat4_exports.invert(invmat, cmat);
      const results = {
        ptIdx: 0,
        cellIdx: 0,
        polys,
        points,
        tcoords
      };
      let ptIdx = 0;
      let textIdx = 0;
      let axisIdx = 0;
      const coords = model.renderable.getTextPolyData().getPoints().getData();
      const textValues = model.renderable.getTextValues();
      while (ptIdx < coords.length / 3) {
        ptv3[0] = coords[ptIdx * 3];
        ptv3[1] = coords[ptIdx * 3 + 1];
        ptv3[2] = coords[ptIdx * 3 + 2];
        vec3_exports.transformMat4(tmpv3, ptv3, cmat);
        ptv3[0] = coords[ptIdx * 3 + 3];
        ptv3[1] = coords[ptIdx * 3 + 4];
        ptv3[2] = coords[ptIdx * 3 + 5];
        vec3_exports.transformMat4(tmp2v3, ptv3, cmat);
        vec3_exports.subtract(tmpv3, tmpv3, tmp2v3);
        const dir = [tmpv3[0], tmpv3[1]];
        normalize2D(dir);
        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);
        ptIdx += 2;
        textIdx++;
        for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {
          publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);
          ptIdx++;
          textIdx++;
        }
        axisIdx++;
      }
      const tcoordDA = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoords,
        name: "TextureCoordinates"
      });
      model.tmPolyData.getPointData().setTCoords(tcoordDA);
      model.tmPolyData.getPoints().setData(points, 3);
      model.tmPolyData.getPoints().modified();
      model.tmPolyData.getPolys().setData(polys, 1);
      model.tmPolyData.getPolys().modified();
      model.tmPolyData.modified();
    };
    publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
      if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
        model.lastSize[0] = size[0];
        model.lastSize[1] = size[1];
        model.lastAspectRatio = size[0] / size[1];
        model.forceUpdate = true;
      }
      model.camera = camera;
      publicAPI.updateTexturePolyData();
    };
  }
  var newCubeAxesActorHelper = macro.newInstance(function(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      renderable: null
    };
    Object.assign(model, {}, initialValues);
    macro.obj(publicAPI, model);
    model.tmPolyData = vtkPolyData$1.newInstance();
    model.tmMapper = vtkMapper$1.newInstance();
    model.tmMapper.setInputData(model.tmPolyData);
    model.tmActor = vtkActor$1.newInstance({
      parentProp: publicAPI
    });
    model.tmActor.setMapper(model.tmMapper);
    macro.setGet(publicAPI, model, ["renderable"]);
    macro.get(publicAPI, model, ["lastSize", "lastAspectRatio", "axisTextStyle", "tickTextStyle", "tmActor", "ticks"]);
    model.forceUpdate = false;
    model.lastRedrawTime = {};
    macro.obj(model.lastRedrawTime, {
      mtime: 0
    });
    model.lastRebuildTime = {};
    macro.obj(model.lastRebuildTime, {
      mtime: 0
    });
    model.lastSize = [-1, -1];
    model.lastTickBounds = [];
    vtkCubeAxesActorHelper(publicAPI, model);
  }, "vtkCubeAxesActorHelper");
  function vtkCubeAxesActor(publicAPI, model) {
    model.classHierarchy.push("vtkCubeAxesActor");
    publicAPI.setCamera = (cam) => {
      if (model.camera === cam) {
        return;
      }
      if (model.cameraModifiedSub) {
        model.cameraModifiedSub.unsubscribe();
        model.cameraModifiedSub = null;
      }
      model.camera = cam;
      if (cam) {
        model.cameraModifiedSub = cam.onModified(publicAPI.update);
      }
      publicAPI.update();
      publicAPI.modified();
    };
    publicAPI.computeFacesToDraw = () => {
      const cmat = model.camera.getViewMatrix();
      mat4_exports.transpose(cmat, cmat);
      let changed = false;
      const length4 = vtkBoundingBox.getDiagonalLength(model.dataBounds);
      const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180);
      for (let f = 0; f < 6; f++) {
        let drawit = false;
        const faceAxis = Math.floor(f / 2);
        const otherAxis1 = (faceAxis + 1) % 3;
        const otherAxis2 = (faceAxis + 2) % 3;
        if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {
          ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length4 * faceNormals[f][faceAxis];
          ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);
          ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);
          vec3_exports.transformMat4(tmpv3, ptv3, cmat);
          ptv3[faceAxis] = model.dataBounds[f];
          vec3_exports.transformMat4(tmp2v3, ptv3, cmat);
          vec3_exports.subtract(tmpv3, tmp2v3, tmpv3);
          vec3_exports.normalize(tmpv3, tmpv3);
          drawit = tmpv3[2] > faceDot;
          if (!model.camera.getParallelProjection()) {
            vec3_exports.normalize(tmp2v3, tmp2v3);
            drawit = vec3_exports.dot(tmp2v3, tmpv3) > faceDot;
          }
        }
        if (drawit !== model.lastFacesToDraw[f]) {
          model.lastFacesToDraw[f] = drawit;
          changed = true;
        }
      }
      return changed;
    };
    publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks2) => {
      let numPts = 0;
      let numLines = 0;
      numPts += 8;
      let numEdgesToDraw = 0;
      for (let e = 0; e < 12; e++) {
        if (edgesToDraw[e] > 0) {
          numEdgesToDraw++;
        }
      }
      numLines += numEdgesToDraw;
      if (model.gridLines) {
        for (let f = 0; f < 6; f++) {
          if (facesToDraw[f]) {
            numPts += ticks2[faceAxes[f][0]].length * 2 + ticks2[faceAxes[f][1]].length * 2;
            numLines += ticks2[faceAxes[f][0]].length + ticks2[faceAxes[f][1]].length;
          }
        }
      }
      const points = new Float64Array(numPts * 3);
      const lines = new Uint32Array(numLines * 3);
      let ptIdx = 0;
      let lineIdx = 0;
      for (let z = 0; z < 2; z++) {
        for (let y = 0; y < 2; y++) {
          for (let x = 0; x < 2; x++) {
            points[ptIdx * 3] = model.dataBounds[x];
            points[ptIdx * 3 + 1] = model.dataBounds[2 + y];
            points[ptIdx * 3 + 2] = model.dataBounds[4 + z];
            ptIdx++;
          }
        }
      }
      for (let e = 0; e < 12; e++) {
        if (edgesToDraw[e] > 0) {
          lines[lineIdx * 3] = 2;
          lines[lineIdx * 3 + 1] = edgePoints[e][0];
          lines[lineIdx * 3 + 2] = edgePoints[e][1];
          lineIdx++;
        }
      }
      if (model.gridLines) {
        for (let f = 0; f < 6; f++) {
          if (facesToDraw[f]) {
            const faceIdx = Math.floor(f / 2);
            let aticks = ticks2[faceAxes[f][0]];
            for (let t = 0; t < aticks.length; t++) {
              points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
              points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];
              ptIdx++;
              points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
              points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];
              ptIdx++;
              lines[lineIdx * 3] = 2;
              lines[lineIdx * 3 + 1] = ptIdx - 2;
              lines[lineIdx * 3 + 2] = ptIdx - 1;
              lineIdx++;
            }
            aticks = ticks2[faceAxes[f][1]];
            for (let t = 0; t < aticks.length; t++) {
              points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
              points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];
              ptIdx++;
              points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
              points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];
              ptIdx++;
              lines[lineIdx * 3] = 2;
              lines[lineIdx * 3 + 1] = ptIdx - 2;
              lines[lineIdx * 3 + 2] = ptIdx - 1;
              lineIdx++;
            }
          }
        }
      }
      model.polyData.getPoints().setData(points, 3);
      model.polyData.getPoints().modified();
      model.polyData.getLines().setData(lines, 1);
      model.polyData.getLines().modified();
      model.polyData.modified();
    };
    publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks2, tickStrings) => {
      let textPointCount = 0;
      for (let e = 0; e < 12; e++) {
        if (edgesToDraw[e] === 1) {
          textPointCount += 2;
          textPointCount += ticks2[edgeAxes[e]].length;
        }
      }
      const points = model.polyData.getPoints().getData();
      const textPoints = new Float64Array(textPointCount * 3);
      let ptIdx = 0;
      let textIdx = 0;
      let axisCount = 0;
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          for (let e = 0; e < 4; e++) {
            const edgeIdx = faceEdges[f][e];
            if (edgesToDraw[edgeIdx] === 1) {
              const edgeAxis = edgeAxes[edgeIdx];
              const ptIdx1 = edgePoints[edgeIdx][0] * 3;
              const ptIdx2 = edgePoints[edgeIdx][1] * 3;
              textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);
              textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);
              textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);
              ptIdx++;
              const faceIdx = Math.floor(f / 2);
              textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);
              textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);
              ptIdx++;
              model.textValues[textIdx] = model.axisLabels[edgeAxis];
              textIdx++;
              const otherAxis1 = (edgeAxis + 1) % 3;
              const otherAxis2 = (edgeAxis + 2) % 3;
              const aticks = ticks2[edgeAxis];
              const atickStrings = tickStrings[edgeAxis];
              model.tickCounts[axisCount] = aticks.length;
              for (let t = 0; t < aticks.length; t++) {
                textPoints[ptIdx * 3 + edgeAxis] = aticks[t];
                textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];
                textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];
                ptIdx++;
                model.textValues[textIdx] = atickStrings[t];
                textIdx++;
              }
              axisCount++;
            }
          }
        }
      }
      model.textPolyData.getPoints().setData(textPoints, 3);
      model.textPolyData.modified();
    };
    publicAPI.update = () => {
      if (!model.camera) {
        return;
      }
      const facesChanged = publicAPI.computeFacesToDraw();
      const facesToDraw = model.lastFacesToDraw;
      let boundsChanged = false;
      for (let i = 0; i < 6; i++) {
        if (model.dataBounds[i] !== model.lastTickBounds[i]) {
          boundsChanged = true;
          model.lastTickBounds[i] = model.dataBounds[i];
        }
      }
      if (facesChanged || boundsChanged || model.forceUpdate) {
        const edgesToDraw = new Array(12).fill(0);
        for (let f = 0; f < 6; f++) {
          if (facesToDraw[f]) {
            for (let e = 0; e < 4; e++) {
              edgesToDraw[faceEdges[f][e]]++;
            }
          }
        }
        const t = model.generateTicks(model.dataBounds);
        publicAPI.updatePolyData(facesToDraw, edgesToDraw, t.ticks);
        publicAPI.updateTextData(facesToDraw, edgesToDraw, t.ticks, t.tickStrings);
        if (boundsChanged || model.forceUpdate) {
          publicAPI.updateTextureAtlas(t.tickStrings);
        }
      }
      model.forceUpdate = false;
    };
    publicAPI.updateTextureAtlas = (tickStrings) => {
      model.tmContext.textBaseline = "bottom";
      model.tmContext.textAlign = "left";
      model._tmAtlas.clear();
      let maxWidth = 0;
      let totalHeight = 1;
      for (let i = 0; i < 3; i++) {
        if (!model._tmAtlas.has(model.axisLabels[i])) {
          applyTextStyle(model.tmContext, model.axisTextStyle);
          const metrics = model.tmContext.measureText(model.axisLabels[i]);
          const entry = {
            height: metrics.actualBoundingBoxAscent + 2,
            startingHeight: totalHeight,
            width: metrics.width + 2,
            textStyle: model.axisTextStyle
          };
          model._tmAtlas.set(model.axisLabels[i], entry);
          totalHeight += entry.height;
          if (maxWidth < entry.width) {
            maxWidth = entry.width;
          }
        }
        applyTextStyle(model.tmContext, model.tickTextStyle);
        for (let t = 0; t < tickStrings[i].length; t++) {
          if (!model._tmAtlas.has(tickStrings[i][t])) {
            const metrics = model.tmContext.measureText(tickStrings[i][t]);
            const entry = {
              height: metrics.actualBoundingBoxAscent + 2,
              startingHeight: totalHeight,
              width: metrics.width + 2,
              textStyle: model.tickTextStyle
            };
            model._tmAtlas.set(tickStrings[i][t], entry);
            totalHeight += entry.height;
            if (maxWidth < entry.width) {
              maxWidth = entry.width;
            }
          }
        }
      }
      maxWidth = nearestPowerOfTwo(maxWidth);
      totalHeight = nearestPowerOfTwo(totalHeight);
      model._tmAtlas.forEach((value) => {
        value.tcoords = [0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0, (totalHeight - value.startingHeight) / totalHeight];
      });
      model.tmCanvas.width = maxWidth;
      model.tmCanvas.height = totalHeight;
      model.tmContext.textBaseline = "bottom";
      model.tmContext.textAlign = "left";
      model.tmContext.clearRect(0, 0, maxWidth, totalHeight);
      model._tmAtlas.forEach((value, key) => {
        applyTextStyle(model.tmContext, value.textStyle);
        model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
      });
      model.tmTexture.setCanvas(model.tmCanvas);
      model.tmTexture.modified();
    };
    publicAPI.onModified(() => {
      model.forceUpdate = true;
      publicAPI.update();
    });
    publicAPI.setTickTextStyle = (tickStyle) => {
      model.tickTextStyle = {
        ...model.tickTextStyle,
        ...tickStyle
      };
      publicAPI.modified();
    };
    publicAPI.setAxisTextStyle = (axisStyle) => {
      model.axisTextStyle = {
        ...model.axisTextStyle,
        ...axisStyle
      };
      publicAPI.modified();
    };
    publicAPI.get_tmAtlas = () => model._tmAtlas;
    publicAPI.getBounds = () => {
      publicAPI.update();
      vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());
      vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);
      return model.bounds;
    };
    const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);
    publicAPI.setProperty = (p) => _setProp(p)[0];
  }
  function defaultValues3(publicAPI, model, initialValues) {
    return {
      boundsScaleFactor: 1.3,
      camera: null,
      dataBounds: [...vtkBoundingBox.INIT_BOUNDS],
      faceVisibilityAngle: 8,
      gridLines: true,
      axisLabels: null,
      axisTitlePixelOffset: 35,
      tickLabelPixelOffset: 12,
      generateTicks: defaultGenerateTicks,
      ...initialValues,
      axisTextStyle: {
        fontColor: "white",
        fontStyle: "normal",
        fontSize: 18,
        fontFamily: "serif",
        ...initialValues?.axisTextStyle
      },
      tickTextStyle: {
        fontColor: "white",
        fontStyle: "normal",
        fontSize: 14,
        fontFamily: "serif",
        ...initialValues?.tickTextStyle
      }
    };
  }
  function extend96(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    vtkActor$1.extend(publicAPI, model, defaultValues3(publicAPI, model, initialValues));
    model.lastFacesToDraw = [false, false, false, false, false, false];
    model.axisLabels = ["X-Axis", "Y-Axis", "Z-Axis"];
    model.tickCounts = [];
    model.textValues = [];
    model.lastTickBounds = [];
    model.tmCanvas = document.createElement("canvas");
    model.tmContext = model.tmCanvas.getContext("2d");
    model._tmAtlas = /* @__PURE__ */ new Map();
    model.tmTexture = vtkTexture$1.newInstance({
      resizable: true
    });
    model.tmTexture.setInterpolate(false);
    publicAPI.getProperty().setDiffuse(0);
    publicAPI.getProperty().setAmbient(1);
    model.gridMapper = vtkMapper$1.newInstance();
    model.polyData = vtkPolyData$1.newInstance();
    model.gridMapper.setInputData(model.polyData);
    model.gridActor = vtkActor$1.newInstance();
    model.gridActor.setMapper(model.gridMapper);
    model.gridActor.setProperty(publicAPI.getProperty());
    model.gridActor.setParentProp(publicAPI);
    model.textPolyData = vtkPolyData$1.newInstance();
    macro.setGet(publicAPI, model, ["axisTitlePixelOffset", "boundsScaleFactor", "faceVisibilityAngle", "gridLines", "tickLabelPixelOffset", "generateTicks"]);
    macro.setGetArray(publicAPI, model, ["dataBounds"], 6);
    macro.setGetArray(publicAPI, model, ["axisLabels"], 3);
    macro.get(publicAPI, model, ["axisTextStyle", "tickTextStyle", "camera", "tmTexture", "textValues", "textPolyData", "tickCounts", "gridActor"]);
    vtkCubeAxesActor(publicAPI, model);
  }
  var newInstance95 = macro.newInstance(extend96, "vtkCubeAxesActor");
  var vtkCubeAxesActor$1 = {
    newInstance: newInstance95,
    extend: extend96,
    newCubeAxesActorHelper,
    defaultGenerateTicks
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/CubeAxesActor.js
  function vtkOpenGLCubeAxesActor(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLCubeAxesActor");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        if (!model.CubeAxesActorHelper.getRenderable()) {
          model.CubeAxesActorHelper.setRenderable(model.renderable);
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
        publicAPI.addMissingNode(model.renderable.getGridActor());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
        const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
        model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
      }
    };
  }
  var DEFAULT_VALUES93 = {};
  function extend97(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES93, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();
    vtkOpenGLCubeAxesActor(publicAPI, model);
  }
  var newInstance96 = newInstance(extend97, "vtkOpenGLCubeAxesActor");
  registerOverride("vtkCubeAxesActor", newInstance96);

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js
  var vtkPolyDataVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n";

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
  var vtkPolyDataFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
  function implementReplaceShaderCoincidentOffset(publicAPI, model) {
    publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      if (cp && (cp.factor !== 0 || cp.offset !== 0)) {
        let FSSource = shaders.Fragment;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Coincident::Dec", ["uniform float cfactor;", "uniform float coffset;"]).result;
        if (model.context.getExtension("EXT_frag_depth")) {
          if (cp.factor !== 0) {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
          } else {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result;
          }
        }
        if (model._openGLRenderWindow.getWebgl2()) {
          if (cp.factor !== 0) {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
          } else {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result;
          }
        }
        shaders.Fragment = FSSource;
      }
    };
  }
  function implementBuildShadersWithReplacements(publicAPI, model) {
    publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {
      let shaderReplacements = null;
      if (viewSpec) {
        shaderReplacements = viewSpec.ShaderReplacements;
      }
      if (shaderReplacements) {
        for (let i = 0; i < shaderReplacements.length; i++) {
          const currReplacement = shaderReplacements[i];
          if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {
            const shaderType = currReplacement.shaderType;
            const ssrc = shaders[shaderType];
            const substituteRes = vtkShaderProgram$1.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);
            shaders[shaderType] = substituteRes.result;
          }
        }
      }
    };
    publicAPI.buildShaders = (shaders, ren, actor) => {
      publicAPI.getReplacedShaderTemplate(shaders, ren, actor);
      model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;
      if (model.lastRenderPassShaderReplacement) {
        model.lastRenderPassShaderReplacement(shaders);
      }
      const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;
      publicAPI.applyShaderReplacements(shaders, openGLSpec, true);
      publicAPI.replaceShaderValues(shaders, ren, actor);
      publicAPI.applyShaderReplacements(shaders, openGLSpec);
    };
    publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {
      const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;
      publicAPI.getShaderTemplate(shaders, ren, actor);
      let vertexShaderCode = shaders.Vertex;
      if (openGLSpecProp) {
        const vertexSpecProp = openGLSpecProp.VertexShaderCode;
        if (vertexSpecProp !== void 0 && vertexSpecProp !== "") {
          vertexShaderCode = vertexSpecProp;
        }
      }
      shaders.Vertex = vertexShaderCode;
      let fragmentShaderCode = shaders.Fragment;
      if (openGLSpecProp) {
        const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
        if (fragmentSpecProp !== void 0 && fragmentSpecProp !== "") {
          fragmentShaderCode = fragmentSpecProp;
        }
      }
      shaders.Fragment = fragmentShaderCode;
      let geometryShaderCode = shaders.Geometry;
      if (openGLSpecProp) {
        const geometrySpecProp = openGLSpecProp.GeometryShaderCode;
        if (geometrySpecProp !== void 0) {
          geometryShaderCode = geometrySpecProp;
        }
      }
      shaders.Geometry = geometryShaderCode;
    };
  }
  var vtkReplacementShaderMapper = {
    implementReplaceShaderCoincidentOffset,
    implementBuildShadersWithReplacements
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js
  var {
    FieldAssociations: FieldAssociations6
  } = vtkDataSet$1;
  var {
    primTypes: primTypes2
  } = vtkHelper;
  var {
    Representation: Representation6,
    Shading: Shading2
  } = vtkProperty$1;
  var {
    ScalarMode: ScalarMode3
  } = vtkMapper$1;
  var {
    Filter: Filter3,
    Wrap: Wrap3
  } = vtkOpenGLTexture$1;
  var {
    vtkErrorMacro: vtkErrorMacro29
  } = macro$1;
  var StartEvent = {
    type: "StartEvent"
  };
  var EndEvent = {
    type: "EndEvent"
  };
  var {
    CoordinateSystem: CoordinateSystem3
  } = vtkProp$1;
  function getPickState(renderer) {
    const selector = renderer.getSelector();
    if (selector) {
      return selector.getCurrentPass();
    }
    return PassTypes.MIN_KNOWN_PASS - 1;
  }
  function vtkOpenGLPolyDataMapper(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLPolyDataMapper");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model.currentRenderPass = null;
        model.openGLActor = publicAPI.getFirstAncestorOfType("vtkOpenGLActor");
        model._openGLRenderer = model.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer");
        model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
        model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
      }
    };
    publicAPI.translucentPass = (prepass, renderPass) => {
      if (prepass) {
        model.currentRenderPass = renderPass;
        publicAPI.render();
      }
    };
    publicAPI.zBufferPass = (prepass) => {
      if (prepass) {
        model.haveSeenDepthRequest = true;
        model.renderDepth = true;
        publicAPI.render();
        model.renderDepth = false;
      }
    };
    publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
    publicAPI.opaquePass = (prepass) => {
      if (prepass) {
        publicAPI.render();
      }
    };
    publicAPI.render = () => {
      const ctx = model._openGLRenderWindow.getContext();
      if (model.context !== ctx) {
        model.context = ctx;
        for (let i = primTypes2.Start; i < primTypes2.End; i++) {
          model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
        }
      }
      const actor = model.openGLActor.getRenderable();
      const ren = model._openGLRenderer.getRenderable();
      publicAPI.renderPiece(ren, actor);
    };
    publicAPI.getShaderTemplate = (shaders, ren, actor) => {
      shaders.Vertex = vtkPolyDataVS;
      shaders.Fragment = vtkPolyDataFS;
      shaders.Geometry = "";
    };
    publicAPI.replaceShaderColor = (shaders, ren, actor) => {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      let colorDec = ["uniform float ambient;", "uniform float diffuse;", "uniform float specular;", "uniform float opacityUniform; // the fragment opacity", "uniform vec3 ambientColorUniform;", "uniform vec3 diffuseColorUniform;"];
      if (lastLightComplexity) {
        colorDec = colorDec.concat(["uniform vec3 specularColorUniform;", "uniform float specularPowerUniform;"]);
      }
      let colorImpl = ["vec3 ambientColor;", "  vec3 diffuseColor;", "  float opacity;"];
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(["  vec3 specularColor;", "  float specularPower;"]);
      }
      colorImpl = colorImpl.concat(["  ambientColor = ambientColorUniform;", "  diffuseColor = diffuseColorUniform;", "  opacity = opacityUniform;"]);
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(["  specularColor = specularColorUniform;", "  specularPower = specularPowerUniform;"]);
      }
      if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
        colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 scalarColor;", "varying vec4 vertexColorVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput =  scalarColor;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
      }
      if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  ambientColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"])).result;
      } else {
        if ((model.renderable.getAreScalarsMappedFromCells() || model.renderable.getInterpolateScalarsBeforeMapping()) && model.renderable.getColorCoordinates() && !model.drawingEdges) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);", "  diffuseColor = texColor.rgb;", "  ambientColor = texColor.rgb;", "  opacity = opacity*texColor.a;"])).result;
        } else {
          if (actor.getBackfaceProperty() && !model.drawingEdges) {
            colorDec = colorDec.concat(["uniform float opacityUniformBF; // the fragment opacity", "uniform float ambientIntensityBF; // the material ambient", "uniform float diffuseIntensityBF; // the material diffuse", "uniform vec3 ambientColorUniformBF; // ambient material color", "uniform vec3 diffuseColorUniformBF; // diffuse material color"]);
            if (lastLightComplexity) {
              colorDec = colorDec.concat(["uniform float specularIntensityBF; // the material specular intensity", "uniform vec3 specularColorUniformBF; // intensity weighted color", "uniform float specularPowerUniformBF;"]);
              colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  specularColor = specularIntensityBF * specularColorUniformBF;", "  specularPower = specularPowerUniformBF;", "  opacity = opacityUniformBF; }"]);
            } else {
              colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  opacity = opacityUniformBF; }"]);
            }
          }
          if (model.haveCellScalars && !model.drawingEdges) {
            colorDec = colorDec.concat(["uniform samplerBuffer texture1;"]);
          }
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
        }
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderLight = (shaders, ren, actor) => {
      let FSSource = shaders.Fragment;
      const shadowFactor = "";
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      const lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
      let sstring = [];
      switch (lastLightComplexity) {
        case 0:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);", "  //VTK::Light::Impl"], false).result;
          break;
        case 1:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  float df = max(0.0, normalVCVSOutput.z);", "  float sf = pow(df, specularPower);", "  vec3 diffuseL = df * diffuseColor;", "  vec3 specularL = sf * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"], false).result;
          break;
        case 2:
          for (let lc = 0; lc < lastLightCount; ++lc) {
            sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);
          }
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
          sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  float df;"];
          for (let lc = 0; lc < lastLightCount; ++lc) {
            sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, "    {", `    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, "    }"]);
          }
          sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
          break;
        case 3:
          for (let lc = 0; lc < lastLightCount; ++lc) {
            sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);
          }
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
          sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  vec3 vertLightDirectionVC;", "  float attenuation;", "  float df;"];
          for (let lc = 0; lc < lastLightCount; ++lc) {
            sstring = sstring.concat(["  attenuation = 1.0;", `  if (lightPositional${lc} == 0)`, "    {", `      vertLightDirectionVC = lightDirectionVC${lc};`, "    }", "  else", "    {", `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, "    float distanceVC = length(vertLightDirectionVC);", "    vertLightDirectionVC = normalize(vertLightDirectionVC);", "    attenuation = 1.0 /", `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, "    // per OpenGL standard cone angle is 90 or less for a spot light", `    if (lightConeAngle${lc} <= 90.0)`, "      {", `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, "      // if inside the cone", `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, "        {", `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, "        }", "      else", "        {", "        attenuation = 0.0;", "        }", "      }", "    }", "    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));", `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, "    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)", "      {", `      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${lc},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, "    }"]);
          }
          sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
          break;
        default:
          vtkErrorMacro29("bad light complexity");
      }
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity > 0) {
        let VSSource = shaders.Vertex;
        let GSSource = shaders.Geometry;
        let FSSource = shaders.Fragment;
        if (model.lastBoundBO.getCABO().getNormalOffset()) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Dec", ["attribute vec3 normalMC;", "uniform mat3 normalMatrix;", "varying vec3 normalVCVSOutput;"]).result;
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Impl", ["normalVCVSOutput = normalMatrix * normalMC;"]).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Dec", ["in vec3 normalVCVSOutput[];", "out vec3 normalVCGSOutput;"]).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Impl", ["normalVCGSOutput = normalVCVSOutput[i];"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["varying vec3 normalVCVSOutput;"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
            "vec3 normalVCVSOutput = normalize(normalVCVSOutput);",
            //  if (!gl_FrontFacing) does not work in intel hd4000 mac
            //  if (int(gl_FrontFacing) == 0) does not work on mesa
            "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"
          ]).result;
        } else {
          if (model.haveCellNormals) {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform mat3 normalMatrix;", "uniform samplerBuffer textureN;"]).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput = normalize(normalMatrix *", "    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);", "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result;
          } else {
            if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {
              FSSource = vtkShaderProgram$1.substitute(
                FSSource,
                "//VTK::UniformFlow::Impl",
                ["  vec3 fdx = dFdx(vertexVC.xyz);", "  vec3 fdy = dFdy(vertexVC.xyz);", "  //VTK::UniformFlow::Impl"]
                // For further replacements
              ).result;
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput;", "  if (abs(fdx.x) > 0.0)", "    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }", "  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result;
            } else {
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform int cameraParallel;"]).result;
              FSSource = vtkShaderProgram$1.substitute(
                FSSource,
                "//VTK::UniformFlow::Impl",
                [
                  // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',
                  // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',
                  "  vec3 fdx = dFdx(vertexVC.xyz);",
                  "  vec3 fdy = dFdy(vertexVC.xyz);",
                  "  //VTK::UniformFlow::Impl"
                ]
                // For further replacements
              ).result;
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
                "  fdx = normalize(fdx);",
                "  fdy = normalize(fdy);",
                "  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));",
                // the code below is faster, but does not work on some devices
                // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',
                "  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }",
                "  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"
              ]).result;
            }
          }
        }
        shaders.Vertex = VSSource;
        shaders.Geometry = GSSource;
        shaders.Fragment = FSSource;
      }
    };
    publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
      model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity > 0) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vertexVCVSOutput = MCVCMatrix * vertexMC;", "  gl_Position = MCPCMatrix * vertexMC;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Dec", ["in vec4 vertexVCVSOutput[];", "out vec4 vertexVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Impl", ["vertexVCGSOutput = vertexVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", ["vec4 vertexVC = vertexVCVSOutput;"]).result;
      } else {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
      if (model.lastBoundBO.getCABO().getTCoordOffset()) {
        let VSSource = shaders.Vertex;
        let GSSource = shaders.Geometry;
        let FSSource = shaders.Fragment;
        if (model.drawingEdges) {
          return;
        }
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
        const tus = model.openGLActor.getActiveTextures();
        let tNumComp = 2;
        let tcdim = 2;
        if (tus && tus.length > 0) {
          tNumComp = tus[0].getComponents();
          if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {
            tcdim = 3;
          }
        }
        if (model.renderable.getColorTextureMap()) {
          tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();
          tcdim = 2;
        }
        if (tcdim === 2) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput[];", "out vec2 tcoordVCGSOutput;"]).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec2 tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
          if (tus && tus.length >= 1) {
            switch (tNumComp) {
              case 1:
                FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
                break;
              case 2:
                FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
                break;
              default:
                FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
            }
          }
        } else {
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec3 tcoordVCVSOutput[];", "out vec3 tcoordVCGSOutput;"]).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec3 tcoordVCVSOutput;", "uniform samplerCube texture1;"]).result;
          switch (tNumComp) {
            case 1:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
              break;
            case 2:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
              break;
            default:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
          }
        }
        shaders.Vertex = VSSource;
        shaders.Geometry = GSSource;
        shaders.Fragment = FSSource;
      }
    };
    publicAPI.replaceShaderClip = (shaders, ren, actor) => {
      let VSSource = shaders.Vertex;
      let FSSource = shaders.Fragment;
      if (model.renderable.getNumberOfClippingPlanes()) {
        const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
      }
      shaders.Vertex = VSSource;
      shaders.Fragment = FSSource;
    };
    publicAPI.getCoincidentParameters = (ren, actor) => {
      let cp = {
        factor: 0,
        offset: 0
      };
      const prop = actor.getProperty();
      if (
        // backwards compat with code that (errorneously) set this to boolean
        // eslint-disable-next-line eqeqeq
        model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset || prop.getEdgeVisibility() && prop.getRepresentation() === Representation6.SURFACE
      ) {
        const primType = model.lastBoundBO.getPrimitiveType();
        if (primType === primTypes2.Points || prop.getRepresentation() === Representation6.POINTS) {
          cp = model.renderable.getCoincidentTopologyPointOffsetParameter();
        } else if (primType === primTypes2.Lines || prop.getRepresentation() === Representation6.WIREFRAME) {
          cp = model.renderable.getCoincidentTopologyLineOffsetParameters();
        } else if (primType === primTypes2.Tris || primType === primTypes2.TriStrips) {
          cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
        }
        if (primType === primTypes2.TrisEdges || primType === primTypes2.TriStripsEdges) {
          cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
          cp.factor /= 2;
          cp.offset /= 2;
        }
      }
      const selector = model._openGLRenderer.getSelector();
      if (selector && selector.getFieldAssociation() === FieldAssociations6.FIELD_ASSOCIATION_POINTS) {
        cp.offset -= 2;
      }
      return cp;
    };
    publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
      let FSSource = shaders.Fragment;
      let VSSource = shaders.Vertex;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["uniform int picking;", "//VTK::Picking::Dec"]).result;
      if (!model._openGLRenderer.getSelector()) {
        return;
      }
      if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Dec", ["flat out int vertexIDVSOutput;\n", "uniform int VertexIDOffset;\n"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Impl", "  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", "flat in int vertexIDVSOutput;\n").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", ["  int idx = vertexIDVSOutput;", "//VTK::Picking::Impl"]).result;
      }
      switch (model.lastSelectionState) {
        case PassTypes.ID_LOW24:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;
          break;
        case PassTypes.ID_HIGH24:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;
          break;
        default:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", "uniform vec3 mapperIndex;").result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
      }
      shaders.Fragment = FSSource;
      shaders.Vertex = VSSource;
    };
    publicAPI.replaceShaderValues = (shaders, ren, actor) => {
      publicAPI.replaceShaderColor(shaders, ren, actor);
      publicAPI.replaceShaderNormal(shaders, ren, actor);
      publicAPI.replaceShaderLight(shaders, ren, actor);
      publicAPI.replaceShaderTCoord(shaders, ren, actor);
      publicAPI.replaceShaderPicking(shaders, ren, actor);
      publicAPI.replaceShaderClip(shaders, ren, actor);
      publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
      publicAPI.replaceShaderPositionVC(shaders, ren, actor);
      if (model.haveSeenDepthRequest) {
        let FSSource = shaders.Fragment;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
        shaders.Fragment = FSSource;
      }
    };
    publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
      let lightComplexity = 0;
      let numberOfLights = 0;
      const primType = cellBO.getPrimitiveType();
      const poly = model.currentInput;
      let needLighting = false;
      const pointNormals = poly.getPointData().getNormals();
      const cellNormals = poly.getCellData().getNormals();
      const flat = actor.getProperty().getInterpolation() === Shading2.FLAT;
      const representation = actor.getProperty().getRepresentation();
      const mode = cellBO.getOpenGLMode(representation, primType);
      if (mode === model.context.TRIANGLES) {
        needLighting = true;
      } else if (cellNormals && !pointNormals) {
        needLighting = true;
      } else if (!flat && pointNormals) {
        needLighting = true;
      } else if (!flat && mode === model.context.LINES) {
        needLighting = true;
      }
      if (actor.getProperty().getLighting() && needLighting) {
        lightComplexity = 0;
        const lights = ren.getLightsByReference();
        for (let index = 0; index < lights.length; ++index) {
          const light = lights[index];
          const status = light.getSwitch();
          if (status > 0) {
            numberOfLights++;
            if (lightComplexity === 0) {
              lightComplexity = 1;
            }
          }
          if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
            lightComplexity = 2;
          }
          if (lightComplexity < 3 && light.getPositional()) {
            lightComplexity = 3;
          }
        }
      }
      let needRebuild = false;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      const lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
      if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {
        model.lastBoundBO.set({
          lastLightComplexity: lightComplexity
        }, true);
        model.lastBoundBO.set({
          lastLightCount: numberOfLights
        }, true);
        needRebuild = true;
      }
      if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
        needRebuild = true;
      }
      if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {
        model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
        return true;
      }
      return false;
    };
    publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
      const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
      if (listCallbacks) {
        listCallbacks.forEach((object) => {
          object.callback(object.userData, cellBO, ren, actor);
        });
      }
    };
    publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
      if (cellBO.getProgram().isUniformUsed("PrimitiveIDOffset")) {
        cellBO.getProgram().setUniformi("PrimitiveIDOffset", model.primitiveIDOffset);
      }
      if (cellBO.getProgram().isUniformUsed("VertexIDOffset")) {
        cellBO.getProgram().setUniformi("VertexIDOffset", model.vertexIDOffset);
      }
      if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
        const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
        if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
            vtkErrorMacro29("Error setting vertexMC in shader VAO.");
          }
        }
        if (cellBO.getProgram().isAttributeUsed("normalMC") && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "normalMC", cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
            vtkErrorMacro29("Error setting normalMC in shader VAO.");
          }
        } else {
          cellBO.getVAO().removeAttributeArray("normalMC");
        }
        model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
          if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
            if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
              vtkErrorMacro29(`Error setting ${attrName}MC in shader VAO.`);
            }
          }
        });
        if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
            vtkErrorMacro29("Error setting tcoordMC in shader VAO.");
          }
        } else {
          cellBO.getVAO().removeAttributeArray("tcoordMC");
        }
        if (cellBO.getProgram().isAttributeUsed("scalarColor") && cellBO.getCABO().getColorComponents()) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "scalarColor", cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
            vtkErrorMacro29("Error setting scalarColor in shader VAO.");
          }
        } else {
          cellBO.getVAO().removeAttributeArray("scalarColor");
        }
        cellBO.getAttributeUpdateTime().modified();
      }
      if (model.renderable.getNumberOfClippingPlanes()) {
        const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
        const planeEquations = [];
        const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
        const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
        const mat = inverseShiftScaleMatrix ? mat4_exports.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();
        if (inverseShiftScaleMatrix) {
          mat4_exports.transpose(mat, mat);
          mat4_exports.multiply(mat, mat, inverseShiftScaleMatrix);
          mat4_exports.transpose(mat, mat);
        }
        for (let i = 0; i < numClipPlanes; i++) {
          const planeEquation = [];
          model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);
          for (let j = 0; j < 4; j++) {
            planeEquations.push(planeEquation[j]);
          }
        }
        cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
        cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
      }
      if (model.internalColorTexture && cellBO.getProgram().isUniformUsed("texture1")) {
        cellBO.getProgram().setUniformi("texture1", model.internalColorTexture.getTextureUnit());
      }
      const tus = model.openGLActor.getActiveTextures();
      if (tus) {
        for (let index = 0; index < tus.length; ++index) {
          const tex = tus[index];
          const texUnit = tex.getTextureUnit();
          const tname = `texture${texUnit + 1}`;
          if (cellBO.getProgram().isUniformUsed(tname)) {
            cellBO.getProgram().setUniformi(tname, texUnit);
          }
        }
      }
      if (model.haveSeenDepthRequest) {
        cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
      }
      if (cellBO.getProgram().isUniformUsed("coffset")) {
        const cp = publicAPI.getCoincidentParameters(ren, actor);
        cellBO.getProgram().setUniformf("coffset", cp.offset);
        if (cellBO.getProgram().isUniformUsed("cfactor")) {
          cellBO.getProgram().setUniformf("cfactor", cp.factor);
        }
      }
      cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
      const selector = model._openGLRenderer.getSelector();
      cellBO.getProgram().setUniform3fArray("mapperIndex", selector ? selector.getPropColorValue() : [0, 0, 0]);
      cellBO.getProgram().setUniformi("picking", selector ? selector.getCurrentPass() + 1 : 0);
    };
    publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity < 2) {
        return;
      }
      const program = cellBO.getProgram();
      let numberOfLights = 0;
      const lights = ren.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        const light = lights[index];
        const status = light.getSwitch();
        if (status > 0) {
          const dColor = light.getColorByReference();
          const intensity = light.getIntensity();
          model.lightColor[0] = dColor[0] * intensity;
          model.lightColor[1] = dColor[1] * intensity;
          model.lightColor[2] = dColor[2] * intensity;
          const ld = light.getDirection();
          const transform = ren.getActiveCamera().getViewMatrix();
          const newLightDirection = [...ld];
          if (light.lightTypeIsSceneLight()) {
            newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];
            newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];
            newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];
            normalize4(newLightDirection);
          }
          model.lightDirection[0] = newLightDirection[0];
          model.lightDirection[1] = newLightDirection[1];
          model.lightDirection[2] = newLightDirection[2];
          normalize4(model.lightDirection);
          program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);
          program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);
          numberOfLights++;
        }
      }
      if (lastLightComplexity < 3) {
        return;
      }
      const cam = ren.getActiveCamera();
      const viewTF = cam.getViewMatrix();
      mat4_exports.transpose(viewTF, viewTF);
      numberOfLights = 0;
      for (let index = 0; index < lights.length; ++index) {
        const light = lights[index];
        const status = light.getSwitch();
        if (status > 0) {
          const lp = light.getTransformedPosition();
          const np = new Float64Array(3);
          vec3_exports.transformMat4(np, lp, viewTF);
          program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());
          program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());
          program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());
          program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());
          program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);
          numberOfLights++;
        }
      }
    };
    function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
      matrixType.identity(tmpMat);
      return matrixArray.reduce((res, matrix, index) => {
        if (index === 0) {
          return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
        }
        return matrix ? matrixType.multiply(res, res, matrix) : res;
      }, tmpMat);
    }
    publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
      const program = cellBO.getProgram();
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const cam = ren.getActiveCamera();
      const camm = model.openGLCamera.getKeyMatrixTime().getMTime();
      const progm = program.getLastCameraMTime();
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const actorIsIdentity = actor.getIsIdentity();
      const actMats = actorIsIdentity ? {
        mcwc: null,
        normalMatrix: null
      } : model.openGLActor.getKeyMatrices();
      if (actor.getCoordinateSystem() === CoordinateSystem3.DISPLAY) {
        const size = model._openGLRenderer.getTiledSizeAndOrigin();
        mat4_exports.identity(model.tmpMat4);
        model.tmpMat4[0] = 2 / size.usize;
        model.tmpMat4[12] = -1;
        model.tmpMat4[5] = 2 / size.vsize;
        model.tmpMat4[13] = -1;
        mat4_exports.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
        program.setUniformMatrix("MCPCMatrix", model.tmpMat4);
      } else {
        program.setUniformMatrix("MCPCMatrix", safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
      }
      if (program.isUniformUsed("MCVCMatrix")) {
        program.setUniformMatrix("MCVCMatrix", safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
      }
      if (program.isUniformUsed("normalMatrix")) {
        program.setUniformMatrix3x3("normalMatrix", safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3_exports, model.tmpMat3));
      }
      if (progm !== camm) {
        if (program.isUniformUsed("cameraParallel")) {
          program.setUniformi("cameraParallel", cam.getParallelProjection());
        }
        program.setLastCameraMTime(camm);
      }
      if (!actorIsIdentity) {
        program.setLastCameraMTime(0);
      }
    };
    publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
      const program = cellBO.getProgram();
      let ppty = actor.getProperty();
      let opacity = ppty.getOpacity();
      let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();
      let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();
      let aIntensity = model.drawingEdges ? 1 : ppty.getAmbient();
      let dIntensity = model.drawingEdges ? 0 : ppty.getDiffuse();
      let sIntensity = model.drawingEdges ? 0 : ppty.getSpecular();
      const specularPower = ppty.getSpecularPower();
      program.setUniformf("opacityUniform", opacity);
      program.setUniform3fArray("ambientColorUniform", aColor);
      program.setUniform3fArray("diffuseColorUniform", dColor);
      program.setUniformf("ambient", aIntensity);
      program.setUniformf("diffuse", dIntensity);
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity < 1) {
        return;
      }
      let sColor = ppty.getSpecularColorByReference();
      program.setUniform3fArray("specularColorUniform", sColor);
      program.setUniformf("specularPowerUniform", specularPower);
      program.setUniformf("specular", sIntensity);
      if (program.isUniformUsed("ambientIntensityBF")) {
        ppty = actor.getBackfaceProperty();
        opacity = ppty.getOpacity();
        aColor = ppty.getAmbientColor();
        aIntensity = ppty.getAmbient();
        dColor = ppty.getDiffuseColor();
        dIntensity = ppty.getDiffuse();
        sColor = ppty.getSpecularColor();
        sIntensity = ppty.getSpecular();
        program.setUniformf("ambientIntensityBF", aIntensity);
        program.setUniformf("diffuseIntensityBF", dIntensity);
        program.setUniformf("opacityUniformBF", opacity);
        program.setUniform3fArray("ambientColorUniformBF", aColor);
        program.setUniform3fArray("diffuseColorUniformBF", dColor);
        if (lastLightComplexity < 1) {
          return;
        }
        program.setUniformf("specularIntensityBF", sIntensity);
        program.setUniform3fArray("specularColorUniformBF", sColor);
        program.setUniformf("specularPowerUniformBF", specularPower);
      }
    };
    publicAPI.updateMaximumPointCellIds = (ren, actor) => {
      const selector = model._openGLRenderer.getSelector();
      if (!selector) {
        return;
      }
      if (model.selectionWebGLIdsToVTKIds?.points?.length) {
        const length4 = model.selectionWebGLIdsToVTKIds.points.length;
        selector.setMaximumPointId(length4 - 1);
      }
      if (model.selectionWebGLIdsToVTKIds?.cells?.length) {
        const length4 = model.selectionWebGLIdsToVTKIds.cells.length;
        selector.setMaximumCellId(length4 - 1);
      }
      const fieldAssociation = selector.getFieldAssociation();
      if (fieldAssociation === FieldAssociations6.FIELD_ASSOCIATION_POINTS) {
        model.pointPicking = true;
      }
    };
    publicAPI.renderPieceStart = (ren, actor) => {
      model.primitiveIDOffset = 0;
      model.vertexIDOffset = 0;
      const picking = getPickState(model._openGLRenderer);
      if (model.lastSelectionState !== picking) {
        model.selectionStateChanged.modified();
        model.lastSelectionState = picking;
      }
      if (model._openGLRenderer.getSelector()) {
        switch (picking) {
          default:
            model._openGLRenderer.getSelector().renderProp(actor);
        }
      }
      publicAPI.updateBufferObjects(ren, actor);
      if (model.renderable.getColorTextureMap()) {
        model.internalColorTexture.activate();
      }
      model.lastBoundBO = null;
    };
    publicAPI.renderPieceDraw = (ren, actor) => {
      const representation = actor.getProperty().getRepresentation();
      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation6.SURFACE;
      const selector = model._openGLRenderer.getSelector();
      const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations6.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24);
      for (let i = primTypes2.Start; i < primTypes2.End; i++) {
        model.primitives[i].setPointPicking(pointPicking);
        const cabo = model.primitives[i].getCABO();
        if (cabo.getElementCount()) {
          model.drawingEdges = drawSurfaceWithEdges && (i === primTypes2.TrisEdges || i === primTypes2.TriStripsEdges);
          if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {
            model.lastBoundBO = model.primitives[i];
            model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
            model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();
          }
        }
      }
    };
    publicAPI.renderPieceFinish = (ren, actor) => {
      if (model.LastBoundBO) {
        model.LastBoundBO.getVAO().release();
      }
      if (model.renderable.getColorTextureMap()) {
        model.internalColorTexture.deactivate();
      }
    };
    publicAPI.renderPiece = (ren, actor) => {
      publicAPI.invokeEvent(StartEvent);
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      model.currentInput = model.renderable.getInputData();
      publicAPI.invokeEvent(EndEvent);
      if (!model.currentInput) {
        vtkErrorMacro29("No input!");
        return;
      }
      if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
        return;
      }
      const gl = model.context;
      const backfaceCulling = actor.getProperty().getBackfaceCulling();
      const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
      if (!backfaceCulling && !frontfaceCulling) {
        model._openGLRenderWindow.disableCullFace();
      } else if (frontfaceCulling) {
        model._openGLRenderWindow.enableCullFace();
        gl.cullFace(gl.FRONT);
      } else {
        model._openGLRenderWindow.enableCullFace();
        gl.cullFace(gl.BACK);
      }
      publicAPI.renderPieceStart(ren, actor);
      publicAPI.renderPieceDraw(ren, actor);
      publicAPI.renderPieceFinish(ren, actor);
    };
    publicAPI.updateBufferObjects = (ren, actor) => {
      if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
        publicAPI.buildBufferObjects(ren, actor);
      }
      publicAPI.updateMaximumPointCellIds();
    };
    publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
      const vmtime = model.VBOBuildTime.getMTime();
      if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {
        return true;
      }
      return false;
    };
    publicAPI.buildBufferObjects = (ren, actor) => {
      const poly = model.currentInput;
      if (poly === null) {
        return;
      }
      model.renderable.mapScalars(poly, 1);
      const c = model.renderable.getColorMapColors();
      model.haveCellScalars = false;
      const scalarMode = model.renderable.getScalarMode();
      if (model.renderable.getScalarVisibility()) {
        if ((scalarMode === ScalarMode3.USE_CELL_DATA || scalarMode === ScalarMode3.USE_CELL_FIELD_DATA || scalarMode === ScalarMode3.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode3.USE_POINT_FIELD_DATA && c) {
          model.haveCellScalars = true;
        }
      }
      let n = actor.getProperty().getInterpolation() !== Shading2.FLAT ? poly.getPointData().getNormals() : null;
      if (n === null && poly.getCellData().getNormals()) {
        model.haveCellNormals = true;
        n = poly.getCellData().getNormals();
      }
      const representation = actor.getProperty().getRepresentation();
      let tcoords = poly.getPointData().getTCoords();
      if (!model.openGLActor.getActiveTextures()) {
        tcoords = null;
      }
      let useTCoordsPerCell = false;
      if (model.renderable.getColorCoordinates()) {
        tcoords = model.renderable.getColorCoordinates();
        useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();
        if (!model.internalColorTexture) {
          model.internalColorTexture = vtkOpenGLTexture$1.newInstance({
            resizable: true
          });
        }
        const tex = model.internalColorTexture;
        tex.setMinificationFilter(Filter3.NEAREST);
        tex.setMagnificationFilter(Filter3.NEAREST);
        tex.setWrapS(Wrap3.CLAMP_TO_EDGE);
        tex.setWrapT(Wrap3.CLAMP_TO_EDGE);
        tex.setOpenGLRenderWindow(model._openGLRenderWindow);
        const input = model.renderable.getColorTextureMap();
        const ext = input.getExtent();
        const inScalars = input.getPointData().getScalars();
        tex.create2DFromRaw({
          width: ext[1] - ext[0] + 1,
          height: ext[3] - ext[2] + 1,
          numComps: inScalars.getNumberOfComponents(),
          dataType: inScalars.getDataType(),
          data: inScalars.getData()
        });
        tex.activate();
        tex.sendParameters();
        tex.deactivate();
      }
      const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}E${actor.getProperty().getEdgeVisibility()}F${tcoords ? tcoords.getMTime() : 1}`;
      if (model.VBOBuildString !== toString) {
        const points = poly.getPoints();
        const options = {
          points,
          normals: n,
          tcoords,
          colors: c,
          cellOffset: 0,
          vertexOffset: 0,
          // Used to keep track of vertex ids across primitives for selection
          useTCoordsPerCell,
          haveCellScalars: model.haveCellScalars,
          haveCellNormals: model.haveCellNormals,
          customAttributes: model.renderable.getCustomShaderAttributes().map((arrayName) => poly.getPointData().getArrayByName(arrayName))
        };
        if (model.renderable.getPopulateSelectionSettings()) {
          model.selectionWebGLIdsToVTKIds = {
            points: null,
            cells: null
          };
        }
        const primitives = [{
          inRep: "verts",
          cells: poly.getVerts()
        }, {
          inRep: "lines",
          cells: poly.getLines()
        }, {
          inRep: "polys",
          cells: poly.getPolys()
        }, {
          inRep: "strips",
          cells: poly.getStrips()
        }, {
          inRep: "polys",
          cells: poly.getPolys()
        }, {
          inRep: "strips",
          cells: poly.getStrips()
        }];
        const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation6.SURFACE;
        for (let i = primTypes2.Start; i < primTypes2.End; i++) {
          if (i !== primTypes2.TrisEdges && i !== primTypes2.TriStripsEdges) {
            options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);
            options.vertexOffset += model.primitives[i].getCABO().getElementCount();
          } else {
            if (drawSurfaceWithEdges) {
              model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation6.WIREFRAME, {
                ...options,
                tcoords: null,
                colors: null,
                haveCellScalars: false,
                haveCellNormals: false
              });
            } else {
              model.primitives[i].releaseGraphicsResources();
            }
          }
        }
        if (model.renderable.getPopulateSelectionSettings()) {
          model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);
        }
        model.VBOBuildString = toString;
      }
      model.VBOBuildTime.modified();
    };
    publicAPI.getAllocatedGPUMemoryInBytes = () => {
      let memUsed = 0;
      model.primitives.forEach((prim) => {
        memUsed += prim.getAllocatedGPUMemoryInBytes();
      });
      return memUsed;
    };
  }
  var DEFAULT_VALUES94 = {
    context: null,
    VBOBuildTime: 0,
    VBOBuildString: null,
    primitives: null,
    primTypes: null,
    shaderRebuildString: null,
    tmpMat4: null,
    ambientColor: [],
    // used internally
    diffuseColor: [],
    // used internally
    specularColor: [],
    // used internally
    lightColor: [],
    // used internally
    lightDirection: [],
    // used internally
    lastHaveSeenDepthRequest: false,
    haveSeenDepthRequest: false,
    lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,
    selectionStateChanged: null,
    selectionWebGLIdsToVTKIds: null,
    pointPicking: false
  };
  function extend98(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES94, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
    vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
    model.primitives = [];
    model.primTypes = primTypes2;
    model.tmpMat3 = mat3_exports.identity(new Float64Array(9));
    model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
    for (let i = primTypes2.Start; i < primTypes2.End; i++) {
      model.primitives[i] = vtkHelper.newInstance();
      model.primitives[i].setPrimitiveType(i);
      model.primitives[i].set({
        lastLightComplexity: 0,
        lastLightCount: 0,
        lastSelectionPass: false
      }, true);
    }
    setGet(publicAPI, model, ["context"]);
    model.VBOBuildTime = {};
    obj(model.VBOBuildTime, {
      mtime: 0
    });
    model.selectionStateChanged = {};
    obj(model.selectionStateChanged, {
      mtime: 0
    });
    vtkOpenGLPolyDataMapper(publicAPI, model);
  }
  var newInstance97 = newInstance(extend98, "vtkOpenGLPolyDataMapper");
  registerOverride("vtkMapper", newInstance97);

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DFS.glsl.js
  var vtkPolyData2DFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n";

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DVS.glsl.js
  var vtkPolyData2DVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n";

  // node_modules/@kitware/vtk.js/Rendering/Core/Property2D/Constants.js
  var DisplayLocation = {
    BACKGROUND: 0,
    FOREGROUND: 1
  };
  var Constants14 = {
    DisplayLocation
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper2D.js
  var {
    primTypes: primTypes3
  } = vtkHelper;
  var {
    Filter: Filter4,
    Wrap: Wrap4
  } = vtkOpenGLTexture$1;
  var {
    vtkErrorMacro: vtkErrorMacro30
  } = macro$1;
  var StartEvent2 = {
    type: "StartEvent"
  };
  var EndEvent2 = {
    type: "EndEvent"
  };
  function vtkOpenGLPolyDataMapper2D(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLPolyDataMapper2D");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model.openGLActor2D = publicAPI.getFirstAncestorOfType("vtkOpenGLActor2D");
        model._openGLRenderer = model.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer");
        model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
        model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
      }
    };
    publicAPI.overlayPass = (prepass) => {
      if (prepass) {
        publicAPI.render();
      }
    };
    publicAPI.getShaderTemplate = (shaders, ren, actor) => {
      shaders.Vertex = vtkPolyData2DVS;
      shaders.Fragment = vtkPolyData2DFS;
      shaders.Geometry = "";
    };
    publicAPI.render = () => {
      const ctx = model._openGLRenderWindow.getContext();
      if (model.context !== ctx) {
        model.context = ctx;
        for (let i = primTypes3.Start; i < primTypes3.End; i++) {
          model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
        }
      }
      const actor = model.openGLActor2D.getRenderable();
      const ren = model._openGLRenderer.getRenderable();
      publicAPI.renderPiece(ren, actor);
    };
    publicAPI.renderPiece = (ren, actor) => {
      publicAPI.invokeEvent(StartEvent2);
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      model.currentInput = model.renderable.getInputData();
      publicAPI.invokeEvent(EndEvent2);
      if (!model.currentInput) {
        vtkErrorMacro30("No input!");
        return;
      }
      if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
        return;
      }
      const gl = model.context;
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
      publicAPI.renderPieceStart(ren, actor);
      publicAPI.renderPieceDraw(ren, actor);
      publicAPI.renderPieceFinish(ren, actor);
    };
    publicAPI.renderPieceStart = (ren, actor) => {
      model.primitiveIDOffset = 0;
      if (model._openGLRenderer.getSelector()) {
        switch (model._openGLRenderer.getSelector().getCurrentPass()) {
          default:
            model._openGLRenderer.getSelector().renderProp(actor);
        }
      }
      if (model.renderable.getColorTextureMap()) {
        model.internalColorTexture.activate();
      }
      publicAPI.updateBufferObjects(ren, actor);
      model.lastBoundBO = null;
    };
    publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
      if (cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
        return true;
      }
      return false;
    };
    publicAPI.updateBufferObjects = (ren, actor) => {
      if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
        publicAPI.buildBufferObjects(ren, actor);
      }
    };
    publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
      const vmtime = model.VBOBuildTime.getMTime();
      if (vmtime < publicAPI.getMTime() || vmtime < model._openGLRenderWindow.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime() || model.renderable.getTransformCoordinate() && vmtime < ren.getMTime()) {
        return true;
      }
      return false;
    };
    publicAPI.buildBufferObjects = (ren, actor) => {
      const poly = model.currentInput;
      if (poly === null) {
        return;
      }
      model.renderable.mapScalars(poly, actor.getProperty().getOpacity());
      const c = model.renderable.getColorMapColors();
      const representation = actor.getProperty().getRepresentation();
      let tcoords = poly.getPointData().getTCoords();
      if (!model.openGLActor2D.getActiveTextures()) {
        tcoords = null;
      }
      let useTCoordsPerCell = false;
      if (model.renderable.getColorCoordinates()) {
        tcoords = model.renderable.getColorCoordinates();
        useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();
        if (!model.internalColorTexture) {
          model.internalColorTexture = vtkOpenGLTexture$1.newInstance({
            resizable: true
          });
        }
        const tex = model.internalColorTexture;
        tex.setMinificationFilter(Filter4.NEAREST);
        tex.setMagnificationFilter(Filter4.NEAREST);
        tex.setWrapS(Wrap4.CLAMP_TO_EDGE);
        tex.setWrapT(Wrap4.CLAMP_TO_EDGE);
        tex.setOpenGLRenderWindow(model._openGLRenderWindow);
        const input = model.renderable.getColorTextureMap();
        const ext = input.getExtent();
        const inScalars = input.getPointData().getScalars();
        tex.create2DFromRaw({
          width: ext[1] - ext[0] + 1,
          height: ext[3] - ext[2] + 1,
          numComps: inScalars.getNumberOfComponents(),
          dataType: inScalars.getDataType(),
          data: inScalars.getData()
        });
        tex.activate();
        tex.sendParameters();
        tex.deactivate();
      }
      const transformCoordinate = model.renderable.getTransformCoordinate();
      const view = ren.getRenderWindow().getViews()[0];
      const vsize = view.getViewportSize(ren);
      const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}C${c ? c.getMTime() : 1}D${tcoords ? tcoords.getMTime() : 1}E${transformCoordinate ? ren.getMTime() : 1}F${vsize}`;
      if (model.VBOBuildString !== toString) {
        let points = poly.getPoints();
        if (transformCoordinate) {
          const p = vtkPoints$1.newInstance();
          const numPts = points.getNumberOfPoints();
          p.setNumberOfPoints(numPts);
          const point = [];
          for (let i = 0; i < numPts; ++i) {
            points.getPoint(i, point);
            transformCoordinate.setValue(point);
            const v = transformCoordinate.getComputedDoubleViewportValue(ren);
            p.setPoint(i, v[0], v[1], 0);
          }
          points = p;
        }
        const options = {
          points,
          tcoords,
          colors: c,
          cellOffset: 0,
          useTCoordsPerCell,
          haveCellScalars: model.renderable.getAreScalarsMappedFromCells(),
          customAttributes: model.renderable.getCustomShaderAttributes().map((arrayName) => poly.getPointData().getArrayByName(arrayName))
        };
        options.cellOffset += model.primitives[primTypes3.Points].getCABO().createVBO(poly.getVerts(), "verts", representation, options);
        options.cellOffset += model.primitives[primTypes3.Lines].getCABO().createVBO(poly.getLines(), "lines", representation, options);
        options.cellOffset += model.primitives[primTypes3.Tris].getCABO().createVBO(poly.getPolys(), "polys", representation, options);
        options.cellOffset += model.primitives[primTypes3.TriStrips].getCABO().createVBO(poly.getStrips(), "strips", representation, options);
        model.VBOBuildTime.modified();
        model.VBOBuildString = toString;
      }
    };
    publicAPI.renderPieceDraw = (ren, actor) => {
      const representation = actor.getProperty().getRepresentation();
      const gl = model.context;
      gl.depthMask(true);
      for (let i = primTypes3.Start; i < primTypes3.End; i++) {
        const cabo = model.primitives[i].getCABO();
        if (cabo.getElementCount()) {
          model.lastBoundBO = model.primitives[i];
          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
        }
      }
    };
    publicAPI.renderPieceFinish = (ren, actor) => {
      if (model.lastBoundBO) {
        model.lastBoundBO.getVAO().release();
      }
      if (model.renderable.getColorTextureMap()) {
        model.internalColorTexture.deactivate();
      }
    };
    publicAPI.replaceShaderValues = (shaders, ren, actor) => {
      publicAPI.replaceShaderColor(shaders, ren, actor);
      publicAPI.replaceShaderTCoord(shaders, ren, actor);
      publicAPI.replaceShaderPicking(shaders, ren, actor);
      publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    };
    publicAPI.replaceShaderColor = (shaders, ren, actor) => {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      let colorDec = ["uniform vec3 diffuseColorUniform;", "uniform float opacityUniform;"];
      let colorImpl = ["vec3 diffuseColor = diffuseColorUniform;", "float opacity = opacityUniform;"];
      if (model.lastBoundBO.getCABO().getColorComponents() !== 0) {
        colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 scalarColor;", "varying vec4 vertexColorVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput =  scalarColor;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"])).result;
      } else if (model.renderable.getAreScalarsMappedFromCells()) {
        colorImpl = colorImpl.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);", "  diffuseColor = texColor.rgb;", "  opacity = opacity*texColor.a;"]);
      }
      colorImpl = colorImpl.concat(["gl_FragData[0] = vec4(diffuseColor, opacity);"]);
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
      if (model.lastBoundBO.getCABO().getTCoordOffset()) {
        let VSSource = shaders.Vertex;
        let GSSource = shaders.Geometry;
        let FSSource = shaders.Fragment;
        const tcdim = model.lastBoundBO.getCABO().getTCoordComponents();
        if (tcdim === 1) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", ["in float tcoordMC;", "out float tcoordVCVSOutput;"]).result;
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", ["tcoordVCVSOutput = tcoordMC;"]).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in float tcoordVCVSOutput[];\n", "out float tcoordVCGSOutput;"]).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, ["//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["in float tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result;
        } else if (tcdim === 2) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordMC;", "out vec2 tcoordVCVSOutput;"]).result;
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", ["tcoordVCVSOutput = tcoordMC;"]).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput[];\n", "out vec2 tcoordVCGSOutput;"]).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", ["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result;
        }
        if (model.renderable.getAreScalarsMappedFromCells()) {
          GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PrimID::Impl", ["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result;
        }
        shaders.Vertex = VSSource;
        shaders.Geometry = GSSource;
        shaders.Fragment = FSSource;
      }
    };
    publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["uniform vec3 mapperIndex;", "uniform int picking;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
      model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
    };
    publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
      const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
      if (listCallbacks) {
        listCallbacks.forEach((object) => {
          object.callback(object.userData, cellBO, ren, actor);
        });
      }
    };
    publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
      if (cellBO.getProgram().isUniformUsed("PrimitiveIDOffset")) {
        cellBO.getProgram().setUniformi("PrimitiveIDOffset", model.primitiveIDOffset);
      }
      if (cellBO.getProgram().isAttributeUsed("vertexWC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexWC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro30("Error setting vertexWC in shader VAO.");
        }
      }
      if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
        model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
          if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
            if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
              vtkErrorMacro30(`Error setting ${attrName}MC in shader VAO.`);
            }
          }
        });
        if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
            vtkErrorMacro30("Error setting tcoordMC in shader VAO.");
          }
        } else {
          cellBO.getVAO().removeAttributeArray("tcoordMC");
        }
        if (cellBO.getProgram().isAttributeUsed("scalarColor") && cellBO.getCABO().getColorComponents()) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "scalarColor", cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
            vtkErrorMacro30("Error setting scalarColor in shader VAO.");
          }
        } else {
          cellBO.getVAO().removeAttributeArray("scalarColor");
        }
        if (model.internalColorTexture && cellBO.getProgram().isUniformUsed("texture1")) {
          const texUnit = model.internalColorTexture.getTextureUnit();
          if (texUnit > -1) {
            cellBO.getProgram().setUniformi("texture1", model.internalColorTexture.getTextureUnit());
          }
        }
        const tus = model.openGLActor2D.getActiveTextures();
        if (tus) {
          for (let index = 0; index < tus.length; ++index) {
            const tex = tus[index];
            const texUnit = tex.getTextureUnit();
            const tname = `texture${texUnit + 1}`;
            if (cellBO.getProgram().isUniformUsed(tname)) {
              cellBO.getProgram().setUniformi(tname, texUnit);
            }
          }
        }
        cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
        const selector = model._openGLRenderer.getSelector();
        cellBO.getProgram().setUniform3fArray("mapperIndex", selector ? selector.getPropColorValue() : [0, 0, 0]);
        cellBO.getProgram().setUniformi("picking", selector ? selector.getCurrentPass() + 1 : 0);
      }
    };
    publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
      const c = model.renderable.getColorMapColors();
      if (!c || c.getNumberOfComponents() === 0) {
        const program = cellBO.getProgram();
        const ppty = actor.getProperty();
        const opacity = ppty.getOpacity();
        program.setUniformf("opacityUniform", opacity);
        const dColor = ppty.getColor();
        program.setUniform3fArray("diffuseColorUniform", dColor);
      }
    };
    publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
    };
    function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
      matrixType.identity(tmpMat);
      return matrixArray.reduce((res, matrix, index) => {
        if (index === 0) {
          return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
        }
        return matrix ? matrixType.multiply(res, res, matrix) : res;
      }, tmpMat);
    }
    publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
      const program = cellBO.getProgram();
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const view = ren.getRenderWindow().getViews()[0];
      const size = view.getViewportSize(ren);
      const vport = ren.getViewport();
      const actorPos = actor.getActualPositionCoordinate().getComputedDoubleViewportValue(ren);
      const tileViewport = [0, 0, 1, 1];
      const visVP = [0, 0, 1, 1];
      visVP[0] = vport[0] >= tileViewport[0] ? vport[0] : tileViewport[0];
      visVP[1] = vport[1] >= tileViewport[1] ? vport[1] : tileViewport[1];
      visVP[2] = vport[2] <= tileViewport[2] ? vport[2] : tileViewport[2];
      visVP[3] = vport[3] <= tileViewport[3] ? vport[3] : tileViewport[3];
      if (visVP[0] >= visVP[2]) {
        return;
      }
      if (visVP[1] >= visVP[3]) {
        return;
      }
      size[0] = round3(size[0] * (visVP[2] - visVP[0]) / (vport[2] - vport[0]));
      size[1] = round3(size[1] * (visVP[3] - visVP[1]) / (vport[3] - vport[1]));
      const winSize = model._openGLRenderer.getParent().getSize();
      const xoff = round3(actorPos[0] - (visVP[0] - vport[0]) * winSize[0]);
      const yoff = round3(actorPos[1] - (visVP[1] - vport[1]) * winSize[1]);
      const left = -xoff;
      let right = -xoff + size[0];
      const bottom = -yoff;
      let top = -yoff + size[1];
      if (left === right) {
        right = left + 1;
      }
      if (bottom === top) {
        top = bottom + 1;
      }
      const tmpMat42 = mat4_exports.identity(new Float64Array(16));
      tmpMat42[0] = 2 / (right - left);
      tmpMat42[1 * 4 + 1] = 2 / (top - bottom);
      tmpMat42[0 * 4 + 3] = -1 * (right + left) / (right - left);
      tmpMat42[1 * 4 + 3] = -1 * (top + bottom) / (top - bottom);
      tmpMat42[2 * 4 + 2] = 0;
      tmpMat42[2 * 4 + 3] = actor.getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? -1 : 1;
      tmpMat42[3 * 4 + 3] = 1;
      mat4_exports.transpose(tmpMat42, tmpMat42);
      program.setUniformMatrix("WCVCMatrix", safeMatrixMultiply([tmpMat42, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    };
    publicAPI.getAllocatedGPUMemoryInBytes = () => {
      let memUsed = 0;
      model.primitives.forEach((prim) => {
        memUsed += prim.getAllocatedGPUMemoryInBytes();
      });
      return memUsed;
    };
  }
  var DEFAULT_VALUES95 = {
    context: null,
    VBOBuildTime: 0,
    VBOBuildString: null,
    primitives: null,
    primTypes: null,
    shaderRebuildString: null
  };
  function extend99(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES95, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
    vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
    model.primitives = [];
    model.primTypes = primTypes3;
    model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
    for (let i = primTypes3.Start; i < primTypes3.End; i++) {
      model.primitives[i] = vtkHelper.newInstance();
      model.primitives[i].setPrimitiveType(i);
      model.primitives[i].set({
        lastLightComplexity: 0,
        lastLightCount: 0,
        lastSelectionPass: false
      }, true);
    }
    setGet(publicAPI, model, ["context"]);
    model.VBOBuildTime = {};
    obj(model.VBOBuildTime, {
      mtime: 0
    });
    vtkOpenGLPolyDataMapper2D(publicAPI, model);
  }
  var newInstance98 = newInstance(extend99, "vtkOpenGLPolyDataMapper2D");
  registerOverride("vtkMapper2D", newInstance98);

  // node_modules/@kitware/vtk.js/Rendering/Core/ScalarBarActor.js
  var {
    VectorMode: VectorMode4
  } = vtkScalarsToColors$1;
  function applyTextStyle2(ctx, style) {
    ctx.strokeStyle = style.strokeColor;
    ctx.lineWidth = style.strokeSize;
    ctx.fillStyle = style.fontColor;
    ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
  }
  function defaultAutoLayout(publicAPI, model) {
    return (helper) => {
      const lastSize = helper.getLastSize();
      const xAxisAdjust = (lastSize[0] / 700) ** 0.8;
      const yAxisAdjust = (lastSize[1] / 700) ** 0.8;
      const minAdjust = Math.min(xAxisAdjust, yAxisAdjust);
      const axisTextStyle = helper.getAxisTextStyle();
      const tickTextStyle = helper.getTickTextStyle();
      Object.assign(axisTextStyle, model.axisTextStyle);
      Object.assign(tickTextStyle, model.tickTextStyle);
      axisTextStyle.fontSize = Math.max(24 * minAdjust, 12);
      if (helper.getLastAspectRatio() > 1) {
        tickTextStyle.fontSize = Math.max(20 * minAdjust, 10);
      } else {
        tickTextStyle.fontSize = Math.max(16 * minAdjust, 10);
      }
      const textSizes = helper.updateTextureAtlas();
      helper.setTopTitle(false);
      const boxSize = helper.getBoxSizeByReference();
      if (helper.getLastAspectRatio() > 1) {
        helper.setTickLabelPixelOffset(0.3 * tickTextStyle.fontSize);
        if (textSizes.titleWidth <= textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) {
          helper.setTopTitle(true);
          helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
          boxSize[0] = 2 * (textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
          helper.setBoxPosition([0.98 - boxSize[0], -0.92]);
        } else {
          helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
          boxSize[0] = 2 * (textSizes.titleHeight + helper.getAxisTitlePixelOffset() + textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
          helper.setBoxPosition([0.99 - boxSize[0], -0.92]);
        }
        boxSize[1] = Math.max(1.2, Math.min(1.84 / yAxisAdjust, 1.84));
      } else {
        helper.setAxisTitlePixelOffset(1.2 * tickTextStyle.fontSize);
        helper.setTickLabelPixelOffset(0.1 * tickTextStyle.fontSize);
        const titleHeight = (
          // total offset from top of bar (includes ticks)
          2 * (0.8 * tickTextStyle.fontSize + textSizes.titleHeight + helper.getAxisTitlePixelOffset()) / lastSize[1]
        );
        const tickWidth = 2 * textSizes.tickWidth / lastSize[0];
        boxSize[0] = Math.min(1.9, Math.max(1.4, 1.4 * tickWidth * (helper.getTicks().length + 3)));
        boxSize[1] = titleHeight;
        helper.setBoxPosition([-0.5 * boxSize[0], -0.97]);
      }
      helper.recomputeBarSegments(textSizes);
    };
  }
  function defaultGenerateTicks2(publicApi, model) {
    return (helper) => {
      const lastTickBounds = helper.getLastTickBounds();
      const scale7 = linear2().domain([lastTickBounds[0], lastTickBounds[1]]);
      const ticks2 = scale7.ticks(5);
      const format2 = scale7.tickFormat(5);
      helper.setTicks(ticks2);
      helper.setTickStrings(ticks2.map(format2));
    };
  }
  function vtkScalarBarActorHelper(publicAPI, model) {
    model.classHierarchy.push("vtkScalarBarActorHelper");
    publicAPI.setRenderable = (renderable) => {
      if (model.renderable === renderable) {
        return;
      }
      model.renderable = renderable;
      model.barActor.setProperty(renderable.getProperty());
      model.barActor.setParentProp(renderable);
      model.barActor.setCoordinateSystemToDisplay();
      model.tmActor.setProperty(renderable.getProperty());
      model.tmActor.setParentProp(renderable);
      model.tmActor.setCoordinateSystemToDisplay();
      model.generateTicks = renderable.generateTicks;
      model.axisTextStyle = {
        ...renderable.getAxisTextStyle()
      };
      model.tickTextStyle = {
        ...renderable.getTickTextStyle()
      };
      publicAPI.modified();
    };
    publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
      if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
        model.lastSize[0] = size[0];
        model.lastSize[1] = size[1];
        model.lastAspectRatio = size[0] / size[1];
        model.forceUpdate = true;
      }
      const scalarsToColors = model.renderable.getScalarsToColors();
      if (!scalarsToColors || !model.renderable.getVisibility()) {
        return;
      }
      model.barMapper.setLookupTable(scalarsToColors);
      model.camera = camera;
      model.renderWindow = renderWindow;
      if (model.forceUpdate || Math.max(scalarsToColors.getMTime(), publicAPI.getMTime(), model.renderable.getMTime()) > model.lastRebuildTime.getMTime()) {
        const range = scalarsToColors.getMappingRange();
        model.lastTickBounds = [...range];
        model.renderable.getGenerateTicks()(publicAPI);
        if (model.renderable.getAutomated()) {
          model.renderable.getAutoLayout()(publicAPI);
        } else {
          model.axisTextStyle = {
            ...model.renderable.getAxisTextStyle()
          };
          model.tickTextStyle = {
            ...model.renderable.getTickTextStyle()
          };
          model.barPosition = [...model.renderable.getBarPosition()];
          model.barSize = [...model.renderable.getBarSize()];
          model.boxPosition = [...model.renderable.getBoxPosition()];
          model.boxSize = [...model.renderable.getBoxSize()];
          model.axisTitlePixelOffset = model.renderable.getAxisTitlePixelOffset();
          model.tickLabelPixelOffset = model.renderable.getTickLabelPixelOffset();
          const textSizes = publicAPI.updateTextureAtlas();
          publicAPI.recomputeBarSegments(textSizes);
        }
        publicAPI.updatePolyDataForLabels();
        publicAPI.updatePolyDataForBarSegments();
        model.lastRebuildTime.modified();
        model.forceUpdate = false;
      }
    };
    publicAPI.updateTextureAtlas = () => {
      model.tmContext.textBaseline = "bottom";
      model.tmContext.textAlign = "left";
      const results = {};
      const newTmAtlas = /* @__PURE__ */ new Map();
      let maxWidth = 0;
      let totalHeight = 1;
      applyTextStyle2(model.tmContext, model.axisTextStyle);
      let metrics = model.tmContext.measureText(model.renderable.getAxisLabel());
      let entry = {
        height: metrics.actualBoundingBoxAscent + 2,
        startingHeight: totalHeight,
        width: metrics.width + 2,
        textStyle: model.axisTextStyle
      };
      newTmAtlas.set(model.renderable.getAxisLabel(), entry);
      totalHeight += entry.height;
      maxWidth = entry.width;
      results.titleWidth = entry.width;
      results.titleHeight = entry.height;
      results.tickWidth = 0;
      results.tickHeight = 0;
      applyTextStyle2(model.tmContext, model.tickTextStyle);
      const strings = [...publicAPI.getTickStrings(), "NaN", "Below", "Above"];
      for (let t = 0; t < strings.length; t++) {
        if (!newTmAtlas.has(strings[t])) {
          metrics = model.tmContext.measureText(strings[t]);
          entry = {
            height: metrics.actualBoundingBoxAscent + 2,
            startingHeight: totalHeight,
            width: metrics.width + 2,
            textStyle: model.tickTextStyle
          };
          newTmAtlas.set(strings[t], entry);
          totalHeight += entry.height;
          if (maxWidth < entry.width) {
            maxWidth = entry.width;
          }
          if (results.tickWidth < entry.width) {
            results.tickWidth = entry.width;
          }
          if (results.tickHeight < entry.height) {
            results.tickHeight = entry.height;
          }
        }
      }
      maxWidth = nearestPowerOfTwo(maxWidth);
      totalHeight = nearestPowerOfTwo(totalHeight);
      newTmAtlas.forEach((value) => {
        value.tcoords = [0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0, (totalHeight - value.startingHeight) / totalHeight];
      });
      model.tmCanvas.width = maxWidth;
      model.tmCanvas.height = totalHeight;
      model.tmContext.textBaseline = "bottom";
      model.tmContext.textAlign = "left";
      model.tmContext.clearRect(0, 0, maxWidth, totalHeight);
      newTmAtlas.forEach((value, key) => {
        applyTextStyle2(model.tmContext, value.textStyle);
        model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
      });
      model.tmTexture.setCanvas(model.tmCanvas);
      model.tmTexture.modified();
      model._tmAtlas = newTmAtlas;
      return results;
    };
    publicAPI.computeBarSize = (textSizes) => {
      model.vertical = model.boxSize[1] > model.boxSize[0];
      const tickHeight = 2 * textSizes.tickHeight / model.lastSize[1];
      const segSize = [1, 1];
      if (model.vertical) {
        const tickWidth = 2 * (textSizes.tickWidth + model.tickLabelPixelOffset) / model.lastSize[0];
        if (model.topTitle) {
          const titleHeight = 2 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
          model.barSize[0] = model.boxSize[0] - tickWidth;
          model.barSize[1] = model.boxSize[1] - titleHeight;
        } else {
          const titleWidth = 2 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[0];
          model.barSize[0] = model.boxSize[0] - titleWidth - tickWidth;
          model.barSize[1] = model.boxSize[1];
        }
        model.barPosition[0] = model.boxPosition[0] + tickWidth;
        model.barPosition[1] = model.boxPosition[1];
        segSize[1] = tickHeight;
      } else {
        const tickWidth = (2 * textSizes.tickWidth - 8) / model.lastSize[0];
        const titleHeight = 2 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
        model.barSize[0] = model.boxSize[0];
        model.barPosition[0] = model.boxPosition[0];
        model.barSize[1] = model.boxSize[1] - titleHeight;
        model.barPosition[1] = model.boxPosition[1];
        segSize[0] = tickWidth;
      }
      return segSize;
    };
    publicAPI.recomputeBarSegments = (textSizes) => {
      const segSize = publicAPI.computeBarSize(textSizes);
      model.barSegments = [];
      const startPos = [0, 0];
      const barAxis = model.vertical ? 1 : 0;
      const segSpace = model.vertical ? 0.01 : 0.02;
      function pushSeg(title, scalars) {
        model.barSegments.push({
          corners: [[...startPos], [startPos[0] + segSize[0], startPos[1]], [startPos[0] + segSize[0], startPos[1] + segSize[1]], [startPos[0], startPos[1] + segSize[1]]],
          scalars,
          title
        });
        startPos[barAxis] += segSize[barAxis] + segSpace;
      }
      if (model.renderable.getDrawNanAnnotation() && model.renderable.getScalarsToColors().getNanColor()) {
        pushSeg("NaN", [NaN, NaN, NaN, NaN]);
      }
      if (model.renderable.getDrawBelowRangeSwatch() && model.renderable.getScalarsToColors().getUseBelowRangeColor?.()) {
        pushSeg("Below", [-0.1, -0.1, -0.1, -0.1]);
      }
      const haveAbove = model.renderable.getScalarsToColors().getUseAboveRangeColor?.();
      startPos[barAxis] += segSpace;
      const oldSegSize = segSize[barAxis];
      segSize[barAxis] = haveAbove ? 1 - 2 * segSpace - segSize[barAxis] - startPos[barAxis] : 1 - segSpace - startPos[barAxis];
      pushSeg("ticks", model.vertical ? [0, 0, 0.995, 0.995] : [0, 0.995, 0.995, 0]);
      if (model.renderable.getDrawAboveRangeSwatch() && haveAbove) {
        segSize[barAxis] = oldSegSize;
        startPos[barAxis] += segSpace;
        pushSeg("Above", [1.1, 1.1, 1.1, 1.1]);
      }
    };
    const tmp2v32 = new Float64Array(3);
    publicAPI.createPolyDataForOneLabel = (text, pos, alignment, orientation, offset, results) => {
      const value = model._tmAtlas.get(text);
      if (!value) {
        return;
      }
      let ptIdx = results.ptIdx;
      let cellIdx = results.cellIdx;
      tmp2v32[0] = (0.5 * pos[0] + 0.5) * model.lastSize[0];
      tmp2v32[1] = (0.5 * pos[1] + 0.5) * model.lastSize[1];
      tmp2v32[2] = pos[2];
      tmp2v32[0] += offset[0];
      tmp2v32[1] += offset[1];
      const textSize = [];
      const textAxes = orientation === "vertical" ? [1, 0] : [0, 1];
      if (orientation === "vertical") {
        textSize[0] = value.width;
        textSize[1] = -value.height;
        if (alignment[0] === "middle") {
          tmp2v32[1] -= value.width / 2;
        } else if (alignment[0] === "right") {
          tmp2v32[1] -= value.width;
        }
        if (alignment[1] === "middle") {
          tmp2v32[0] += value.height / 2;
        } else if (alignment[1] === "top") {
          tmp2v32[0] += value.height;
        }
      } else {
        textSize[0] = value.width;
        textSize[1] = value.height;
        if (alignment[0] === "middle") {
          tmp2v32[0] -= value.width / 2;
        } else if (alignment[0] === "right") {
          tmp2v32[0] -= value.width;
        }
        if (alignment[1] === "middle") {
          tmp2v32[1] -= value.height / 2;
        } else if (alignment[1] === "top") {
          tmp2v32[1] -= value.height;
        }
      }
      results.points[ptIdx * 3] = tmp2v32[0];
      results.points[ptIdx * 3 + 1] = tmp2v32[1];
      results.points[ptIdx * 3 + 2] = tmp2v32[2];
      results.tcoords[ptIdx * 2] = value.tcoords[0];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
      ptIdx++;
      tmp2v32[textAxes[0]] += textSize[0];
      results.points[ptIdx * 3] = tmp2v32[0];
      results.points[ptIdx * 3 + 1] = tmp2v32[1];
      results.points[ptIdx * 3 + 2] = tmp2v32[2];
      results.tcoords[ptIdx * 2] = value.tcoords[2];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
      ptIdx++;
      tmp2v32[textAxes[1]] += textSize[1];
      results.points[ptIdx * 3] = tmp2v32[0];
      results.points[ptIdx * 3 + 1] = tmp2v32[1];
      results.points[ptIdx * 3 + 2] = tmp2v32[2];
      results.tcoords[ptIdx * 2] = value.tcoords[4];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
      ptIdx++;
      tmp2v32[textAxes[0]] -= textSize[0];
      results.points[ptIdx * 3] = tmp2v32[0];
      results.points[ptIdx * 3 + 1] = tmp2v32[1];
      results.points[ptIdx * 3 + 2] = tmp2v32[2];
      results.tcoords[ptIdx * 2] = value.tcoords[6];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
      ptIdx++;
      results.polys[cellIdx * 4] = 3;
      results.polys[cellIdx * 4 + 1] = ptIdx - 4;
      results.polys[cellIdx * 4 + 2] = ptIdx - 3;
      results.polys[cellIdx * 4 + 3] = ptIdx - 2;
      cellIdx++;
      results.polys[cellIdx * 4] = 3;
      results.polys[cellIdx * 4 + 1] = ptIdx - 4;
      results.polys[cellIdx * 4 + 2] = ptIdx - 2;
      results.polys[cellIdx * 4 + 3] = ptIdx - 1;
      results.ptIdx += 4;
      results.cellIdx += 2;
    };
    const tmpv32 = new Float64Array(3);
    publicAPI.updatePolyDataForLabels = () => {
      const numLabels = publicAPI.getTickStrings().length + model.barSegments.length;
      const numPts = numLabels * 4;
      const numTris = numLabels * 2;
      const points = new Float64Array(numPts * 3);
      const polys = new Uint16Array(numTris * 4);
      const tcoords = new Float32Array(numPts * 2);
      const results = {
        ptIdx: 0,
        cellIdx: 0,
        polys,
        points,
        tcoords
      };
      const offsetAxis = model.vertical ? 0 : 1;
      const spacedAxis = model.vertical ? 1 : 0;
      tmpv32[2] = -0.99;
      const alignment = model.vertical ? ["right", "middle"] : ["middle", "bottom"];
      let dir = [0, 1];
      const tickOffsets = [0, 0];
      if (model.vertical) {
        tickOffsets[0] = -model.tickLabelPixelOffset;
        if (model.topTitle) {
          tmpv32[0] = model.boxPosition[0] + 0.5 * model.boxSize[0];
          tmpv32[1] = model.barPosition[1] + model.barSize[1];
          publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv32, ["middle", "bottom"], "horizontal", [0, model.axisTitlePixelOffset], results);
        } else {
          tmpv32[0] = model.barPosition[0] + model.barSize[0];
          tmpv32[1] = model.barPosition[1] + 0.5 * model.barSize[1];
          publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv32, ["middle", "top"], "vertical", [model.axisTitlePixelOffset, 0], results);
        }
        dir = [-1, 0];
      } else {
        tickOffsets[1] = model.tickLabelPixelOffset;
        tmpv32[0] = model.barPosition[0] + 0.5 * model.barSize[0];
        tmpv32[1] = model.barPosition[1] + model.barSize[1];
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv32, ["middle", "bottom"], "horizontal", [0, model.axisTitlePixelOffset], results);
      }
      tmpv32[offsetAxis] = model.barPosition[offsetAxis] + (0.5 * dir[offsetAxis] + 0.5) * model.barSize[offsetAxis];
      tmpv32[spacedAxis] = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * 0.5;
      let tickSeg = null;
      for (let i = 0; i < model.barSegments.length; i++) {
        const seg = model.barSegments[i];
        if (seg.title === "ticks") {
          tickSeg = seg;
        } else {
          tmpv32[spacedAxis] = model.barPosition[spacedAxis] + 0.5 * model.barSize[spacedAxis] * (seg.corners[2][spacedAxis] + seg.corners[0][spacedAxis]);
          publicAPI.createPolyDataForOneLabel(seg.title, tmpv32, alignment, "horizontal", tickOffsets, results);
        }
      }
      const tickSegmentStart = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * tickSeg.corners[0][spacedAxis];
      const tickSegmentSize = model.barSize[spacedAxis] * (tickSeg.corners[2][spacedAxis] - tickSeg.corners[0][spacedAxis]);
      const ticks2 = publicAPI.getTicks();
      const tickStrings = publicAPI.getTickStrings();
      const tickPositions = publicAPI.getTickPositions();
      for (let t = 0; t < ticks2.length; t++) {
        const tickPos = tickPositions ? tickPositions[t] : (ticks2[t] - model.lastTickBounds[0]) / (model.lastTickBounds[1] - model.lastTickBounds[0]);
        tmpv32[spacedAxis] = tickSegmentStart + tickSegmentSize * tickPos;
        publicAPI.createPolyDataForOneLabel(tickStrings[t], tmpv32, alignment, "horizontal", tickOffsets, results);
      }
      const tcoordDA = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoords,
        name: "TextureCoordinates"
      });
      model.tmPolyData.getPointData().setTCoords(tcoordDA);
      model.tmPolyData.getPoints().setData(points, 3);
      model.tmPolyData.getPoints().modified();
      model.tmPolyData.getPolys().setData(polys, 1);
      model.tmPolyData.getPolys().modified();
      model.tmPolyData.modified();
    };
    publicAPI.updatePolyDataForBarSegments = () => {
      const scalarsToColors = model.renderable.getScalarsToColors();
      let numberOfExtraColors = 0;
      if (model.renderable.getDrawNanAnnotation() && scalarsToColors.getNanColor()) {
        numberOfExtraColors += 1;
      }
      if (model.renderable.getDrawBelowRangeSwatch() && scalarsToColors.getUseBelowRangeColor?.()) {
        numberOfExtraColors += 1;
      }
      if (model.renderable.getDrawAboveRangeSwatch() && scalarsToColors.getUseAboveRangeColor?.()) {
        numberOfExtraColors += 1;
      }
      const numPts = 4 * (1 + numberOfExtraColors);
      const numQuads = numPts;
      let numComps = 1;
      if (scalarsToColors.getVectorMode() === VectorMode4.COMPONENT) {
        numComps = scalarsToColors.getVectorComponent() + 1;
      }
      const points = new Float64Array(numPts * 3);
      const cells = new Uint16Array(numQuads * 5);
      const scalars = new Float32Array(numPts * numComps);
      let ptIdx = 0;
      let cellIdx = 0;
      for (let i = 0; i < model.barSegments.length; i++) {
        const seg = model.barSegments[i];
        for (let e = 0; e < 4; e++) {
          tmpv32[0] = model.barPosition[0] + seg.corners[e][0] * model.barSize[0];
          tmpv32[1] = model.barPosition[1] + seg.corners[e][1] * model.barSize[1];
          points[ptIdx * 3] = (0.5 * tmpv32[0] + 0.5) * model.lastSize[0];
          points[ptIdx * 3 + 1] = (0.5 * tmpv32[1] + 0.5) * model.lastSize[1];
          points[ptIdx * 3 + 2] = tmpv32[2];
          for (let nc = 0; nc < numComps; nc++) {
            scalars[ptIdx * numComps + nc] = model.lastTickBounds[0] + seg.scalars[e] * (model.lastTickBounds[1] - model.lastTickBounds[0]);
          }
          ptIdx++;
        }
        cells[cellIdx * 5] = 4;
        cells[cellIdx * 5 + 1] = ptIdx - 4;
        cells[cellIdx * 5 + 2] = ptIdx - 3;
        cells[cellIdx * 5 + 3] = ptIdx - 2;
        cells[cellIdx * 5 + 4] = ptIdx - 1;
        cellIdx++;
      }
      const scalarsDA = vtkDataArray$1.newInstance({
        numberOfComponents: numComps,
        values: scalars,
        name: "Scalars"
      });
      model.polyData.getPointData().setScalars(scalarsDA);
      model.polyData.getPoints().setData(points, 3);
      model.polyData.getPoints().modified();
      model.polyData.getPolys().setData(cells, 1);
      model.polyData.getPolys().modified();
      model.polyData.modified();
    };
  }
  var newScalarBarActorHelper = macro.newInstance(function(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      renderable: null
    };
    Object.assign(model, {}, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["axisTitlePixelOffset", "tickLabelPixelOffset", "renderable", "topTitle", "ticks", "tickStrings", "tickPositions"]);
    macro.get(publicAPI, model, ["lastSize", "lastAspectRatio", "lastTickBounds", "axisTextStyle", "tickTextStyle", "barActor", "tmActor"]);
    macro.getArray(publicAPI, model, ["boxPosition", "boxSize"]);
    macro.setArray(publicAPI, model, ["boxPosition", "boxSize"], 2);
    model.forceUpdate = false;
    model.lastRebuildTime = {};
    macro.obj(model.lastRebuildTime, {
      mtime: 0
    });
    model.lastSize = [-1, -1];
    model.tmCanvas = document.createElement("canvas");
    model.tmContext = model.tmCanvas.getContext("2d");
    model._tmAtlas = /* @__PURE__ */ new Map();
    model.barMapper = vtkMapper$1.newInstance();
    model.barMapper.setInterpolateScalarsBeforeMapping(true);
    model.barMapper.setUseLookupTableScalarRange(true);
    model.polyData = vtkPolyData$1.newInstance();
    model.barMapper.setInputData(model.polyData);
    model.barActor = vtkActor$1.newInstance();
    model.barActor.setMapper(model.barMapper);
    model.tmPolyData = vtkPolyData$1.newInstance();
    model.tmMapper = vtkMapper$1.newInstance();
    model.tmMapper.setInputData(model.tmPolyData);
    model.tmTexture = vtkTexture$1.newInstance({
      resizable: true
    });
    model.tmTexture.setInterpolate(false);
    model.tmActor = vtkActor$1.newInstance({
      parentProp: publicAPI
    });
    model.tmActor.setMapper(model.tmMapper);
    model.tmActor.addTexture(model.tmTexture);
    model.barPosition = [0, 0];
    model.barSize = [0, 0];
    model.boxPosition = [0.88, -0.92];
    model.boxSize = [0.1, 1.1];
    model.lastTickBounds = [];
    vtkScalarBarActorHelper(publicAPI, model);
  }, "vtkScalarBarActorHelper");
  function vtkScalarBarActor(publicAPI, model) {
    model.classHierarchy.push("vtkScalarBarActor");
    publicAPI.setTickTextStyle = (tickStyle) => {
      model.tickTextStyle = {
        ...model.tickTextStyle,
        ...tickStyle
      };
      publicAPI.modified();
    };
    publicAPI.setAxisTextStyle = (axisStyle) => {
      model.axisTextStyle = {
        ...model.axisTextStyle,
        ...axisStyle
      };
      publicAPI.modified();
    };
    publicAPI.resetAutoLayoutToDefault = () => {
      publicAPI.setAutoLayout(defaultAutoLayout(publicAPI, model));
    };
    publicAPI.resetGenerateTicksToDefault = () => {
      publicAPI.setGenerateTicks(defaultGenerateTicks2());
    };
  }
  function defaultValues4(initialValues) {
    return {
      automated: true,
      autoLayout: null,
      axisLabel: "Scalar Value",
      barPosition: [0, 0],
      barSize: [0, 0],
      boxPosition: [0.88, -0.92],
      boxSize: [0.1, 1.1],
      scalarToColors: null,
      axisTitlePixelOffset: 36,
      axisTextStyle: {
        fontColor: "white",
        fontStyle: "normal",
        fontSize: 18,
        fontFamily: "serif"
      },
      tickLabelPixelOffset: 14,
      tickTextStyle: {
        fontColor: "white",
        fontStyle: "normal",
        fontSize: 14,
        fontFamily: "serif"
      },
      generateTicks: null,
      drawNanAnnotation: true,
      drawBelowRangeSwatch: true,
      drawAboveRangeSwatch: true,
      ...initialValues
    };
  }
  function extend100(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, defaultValues4(initialValues));
    if (!model.autoLayout) model.autoLayout = defaultAutoLayout(publicAPI, model);
    if (!model.generateTicks) model.generateTicks = defaultGenerateTicks2();
    vtkActor$1.extend(publicAPI, model, initialValues);
    publicAPI.getProperty().setDiffuse(0);
    publicAPI.getProperty().setAmbient(1);
    macro.setGet(publicAPI, model, ["automated", "autoLayout", "axisTitlePixelOffset", "axisLabel", "scalarsToColors", "tickLabelPixelOffset", "generateTicks", "drawNanAnnotation", "drawBelowRangeSwatch", "drawAboveRangeSwatch"]);
    macro.get(publicAPI, model, ["axisTextStyle", "tickTextStyle"]);
    macro.getArray(publicAPI, model, ["barPosition", "barSize", "boxPosition", "boxSize"]);
    macro.setArray(publicAPI, model, ["barPosition", "barSize", "boxPosition", "boxSize"], 2);
    vtkScalarBarActor(publicAPI, model);
  }
  var newInstance99 = macro.newInstance(extend100, "vtkScalarBarActor");
  var vtkScalarBarActor$1 = {
    newInstance: newInstance99,
    extend: extend100,
    newScalarBarActorHelper
  };

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/ScalarBarActor.js
  function vtkOpenGLScalarBarActor(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLScalarBarActor");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        if (!model.scalarBarActorHelper.getRenderable()) {
          model.scalarBarActorHelper.setRenderable(model.renderable);
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
        publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
        const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
        model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
      }
    };
  }
  var DEFAULT_VALUES96 = {};
  function extend101(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES96, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();
    vtkOpenGLScalarBarActor(publicAPI, model);
  }
  var newInstance100 = newInstance(extend101, "vtkOpenGLScalarBarActor");
  registerOverride("vtkScalarBarActor", newInstance100);

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js
  var {
    vtkErrorMacro: vtkErrorMacro31
  } = macro$1;
  function vtkOpenGLSkybox(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLSkybox");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        model.context = model._openGLRenderWindow.getContext();
        model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
        const ren = model._openGLRenderer.getRenderable();
        model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      }
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        renderPass.incrementOpaqueActorCount();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass && !model._openGLRenderer.getSelector()) {
        publicAPI.updateBufferObjects();
        model.context.depthMask(true);
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());
        model.openGLTexture.render(model._openGLRenderWindow);
        const texUnit = model.openGLTexture.getTextureUnit();
        model.tris.getProgram().setUniformi("sbtexture", texUnit);
        const ren = model._openGLRenderer.getRenderable();
        const keyMats = model.openGLCamera.getKeyMatrices(ren);
        const imat = new Float64Array(16);
        mat4_exports.invert(imat, keyMats.wcpc);
        model.tris.getProgram().setUniformMatrix("IMCPCMatrix", imat);
        if (model.lastFormat === "box") {
          const camPos = ren.getActiveCamera().getPosition();
          model.tris.getProgram().setUniform3f("camPos", camPos[0], camPos[1], camPos[2]);
        }
        model.tris.getVAO().bind();
        model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
        model.tris.getVAO().release();
        model.openGLTexture.deactivate();
      }
    };
    publicAPI.updateBufferObjects = () => {
      if (!model.tris.getCABO().getElementCount()) {
        const ptsArray = new Float32Array(12);
        for (let i = 0; i < 4; i++) {
          ptsArray[i * 3] = i % 2 * 2 - 1;
          ptsArray[i * 3 + 1] = i > 1 ? 1 : -1;
          ptsArray[i * 3 + 2] = 1;
        }
        const points = vtkDataArray$1.newInstance({
          numberOfComponents: 3,
          values: ptsArray
        });
        points.setName("points");
        const cellArray = new Uint16Array(8);
        cellArray[0] = 3;
        cellArray[1] = 0;
        cellArray[2] = 1;
        cellArray[3] = 3;
        cellArray[4] = 3;
        cellArray[5] = 0;
        cellArray[6] = 3;
        cellArray[7] = 2;
        const cells = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: cellArray
        });
        model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
          points,
          cellOffset: 0
        });
      }
      if (model.renderable.getFormat() !== model.lastFormat) {
        model.lastFormat = model.renderable.getFormat();
        if (model.lastFormat === "box") {
          model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`, ""));
        }
        if (model.lastFormat === "background") {
          model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`, ""));
        }
        model.tris.getShaderSourceTime().modified();
        model.tris.getVAO().bind();
        if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), "vertexMC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro31("Error setting vertexMC in shader VAO.");
        }
      }
      const tmaps = model.renderable.getTextures();
      if (!tmaps.length) {
        vtkErrorMacro31("vtkSkybox requires a texture map");
      }
      if (model.openGLTexture.getRenderable() !== tmaps[0]) {
        model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);
        model.openGLTexture.setRenderable(tmaps[0]);
      }
    };
  }
  var DEFAULT_VALUES97 = {
    context: null
  };
  function extend102(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES97, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.openGLTexture = vtkOpenGLTexture$1.newInstance();
    model.tris = vtkHelper.newInstance();
    model.keyMatrixTime = {};
    obj(model.keyMatrixTime, {
      mtime: 0
    });
    model.keyMatrices = {
      normalMatrix: mat3_exports.identity(new Float64Array(9)),
      mcwc: mat4_exports.identity(new Float64Array(16))
    };
    setGet(publicAPI, model, ["context"]);
    get(publicAPI, model, ["activeTextures"]);
    vtkOpenGLSkybox(publicAPI, model);
  }
  var newInstance101 = newInstance(extend102);
  registerOverride("vtkSkybox", newInstance101);

  // node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
  var {
    vtkDebugMacro: vtkDebugMacro7
  } = macro$1;
  function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
    model.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper");
    publicAPI.opaquePass = (prepass, renderPass) => {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      const aspectRatio = model._openGLRenderer.getAspectRatio();
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      let texels = null;
      if (model.renderable.getUseZValues()) {
        const zbt = renderPass.getZBufferTexture();
        const width = Math.floor(zbt.getWidth());
        const height = Math.floor(zbt.getHeight());
        const gl = model._openGLRenderWindow.getContext();
        zbt.bind();
        const fb = renderPass.getFramebuffer();
        if (!fb) {
          vtkDebugMacro7("No framebuffer to save/restore");
        } else {
          fb.saveCurrentBindingsAndBuffers();
        }
        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
          texels = new Uint8Array(width * height * 4);
          gl.viewport(0, 0, width, height);
          gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
        }
        if (fb) {
          fb.restorePreviousBindingsAndBuffers();
        }
        gl.deleteFramebuffer(framebuffer);
      }
      model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (model.renderable.getUseZValues()) {
          renderPass.requestDepth();
        }
      }
    };
  }
  var DEFAULT_VALUES98 = {};
  function extend103(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES98, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
  }
  var newInstance102 = newInstance(extend103, "vtkOpenGLPixelSpaceCallbackMapper");
  registerOverride("vtkPixelSpaceCallbackMapper", newInstance102);

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
  function vtkWebGPUCamera(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUCamera");
    publicAPI.getProjectionMatrix = (outMat, aspect, cRange, windowCenter) => {
      mat4_exports.identity(outMat);
      if (model.renderable.getParallelProjection()) {
        const parallelScale = model.renderable.getParallelScale();
        const width = parallelScale * aspect;
        const height = parallelScale;
        const xmin = (windowCenter[0] - 1) * width;
        const xmax = (windowCenter[0] + 1) * width;
        const ymin = (windowCenter[1] - 1) * height;
        const ymax = (windowCenter[1] + 1) * height;
        const xr = 1 / (xmax - xmin);
        const yr = 1 / (ymax - ymin);
        outMat[0] = 2 * xr;
        outMat[5] = 2 * yr;
        outMat[10] = 1 / (cRange[1] - cRange[0]);
        outMat[12] = (xmax + xmin) * xr;
        outMat[13] = (ymax + ymin) * yr;
        outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
      } else {
        const tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360);
        let width;
        let height;
        if (model.renderable.getUseHorizontalViewAngle() === true) {
          width = cRange[0] * tmp;
          height = cRange[0] * tmp / aspect;
        } else {
          width = cRange[0] * tmp * aspect;
          height = cRange[0] * tmp;
        }
        const xmin = (windowCenter[0] - 1) * width;
        const xmax = (windowCenter[0] + 1) * width;
        const ymin = (windowCenter[1] - 1) * height;
        const ymax = (windowCenter[1] + 1) * height;
        outMat[0] = 2 * cRange[0] / (xmax - xmin);
        outMat[5] = 2 * cRange[0] / (ymax - ymin);
        outMat[12] = (xmin + xmax) / (xmax - xmin);
        outMat[13] = (ymin + ymax) / (ymax - ymin);
        outMat[10] = 0;
        outMat[14] = cRange[0];
        outMat[11] = -1;
        outMat[15] = 0;
      }
    };
    publicAPI.convertToOpenGLDepth = (val) => {
      if (model.renderable.getParallelProjection()) {
        return 1 - val;
      }
      const cRange = model.renderable.getClippingRangeByReference();
      let zval = -cRange[0] / val;
      zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
      return 0.5 * zval + 0.5;
    };
    publicAPI.getKeyMatrices = (webGPURenderer) => {
      const ren = webGPURenderer.getRenderable();
      const webGPURenderWindow = webGPURenderer.getParent();
      if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
        const wcvc = model.renderable.getViewMatrix();
        mat4_exports.copy(model.keyMatrices.normalMatrix, wcvc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat4_exports.transpose(model.keyMatrices.wcvc, wcvc);
        const center = webGPURenderer.getStabilizedCenterByReference();
        mat4_exports.translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
        const aspectRatio = webGPURenderer.getAspectRatio();
        const cRange = model.renderable.getClippingRangeByReference();
        publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
        mat4_exports.multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
        mat4_exports.invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
        model.keyMatrixTime.modified();
      }
      return model.keyMatrices;
    };
  }
  var DEFAULT_VALUES99 = {
    keyMatrixTime: null,
    keyMatrices: null
  };
  function extend104(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES99, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatrixTime = {};
    macro.obj(model.keyMatrixTime);
    model.keyMatrices = {
      normalMatrix: new Float64Array(16),
      vcpc: new Float64Array(16),
      pcsc: new Float64Array(16),
      wcvc: new Float64Array(16),
      scpc: new Float64Array(16),
      scvc: new Float64Array(16)
    };
    macro.setGet(publicAPI, model, ["keyMatrixTime"]);
    vtkWebGPUCamera(publicAPI, model);
  }
  var newInstance103 = macro.newInstance(extend104);
  registerOverride2("vtkCamera", newInstance103);

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js
  var {
    vtkDebugMacro: vtkDebugMacro8
  } = macro$1;
  var clearFragColorTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  var clearFragTextureTemplate = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  var _fsqClearMat4 = new Float64Array(16);
  var _tNormalMat4 = new Float64Array(16);
  function getLightTypeIndex(light) {
    if (light.getPositional()) {
      if (light.getConeAngle() >= 90) {
        return 0;
      }
      return 2;
    }
    return 1;
  }
  function vtkWebGPURenderer(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPURenderer");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        model.camera = model.renderable.getActiveCamera();
        publicAPI.updateLights();
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.camera);
        publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
        publicAPI.removeUnusedNodes();
        model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);
        publicAPI.updateStabilizedMatrix();
      }
    };
    publicAPI.updateStabilizedMatrix = () => {
      const clipRange = model.camera.getClippingRange();
      const pos = model.camera.getPositionByReference();
      const dop = model.camera.getDirectionOfProjectionByReference();
      const center = [];
      const offset = [];
      vec3_exports.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));
      vec3_exports.add(center, pos, offset);
      vec3_exports.sub(offset, center, model.stabilizedCenter);
      const length4 = vec3_exports.len(offset);
      if (length4 / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
        model.stabilizedCenter = center;
        model.stabilizedTime.modified();
      }
    };
    publicAPI.updateLights = () => {
      let count = 0;
      const lights = model.renderable.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        if (lights[index].getSwitch() > 0) {
          count++;
        }
      }
      if (!count) {
        vtkDebugMacro8("No lights are on, creating one.");
        model.renderable.createLight();
      }
      return count;
    };
    publicAPI.updateUBO = () => {
      const utime = model.UBO.getSendTime();
      if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
        const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
        model.UBO.setArray("WCVCMatrix", keyMats.wcvc);
        model.UBO.setArray("SCPCMatrix", keyMats.scpc);
        model.UBO.setArray("PCSCMatrix", keyMats.pcsc);
        model.UBO.setArray("SCVCMatrix", keyMats.scvc);
        model.UBO.setArray("VCPCMatrix", keyMats.vcpc);
        model.UBO.setArray("WCVCNormals", keyMats.normalMatrix);
        model.UBO.setValue("LightCount", model.renderable.getLights().length);
        model.UBO.setValue("MaxEnvironmentMipLevel", model.renderable.getEnvironmentTexture()?.getMipLevel());
        model.UBO.setValue("BackgroundDiffuseStrength", model.renderable.getEnvironmentTextureDiffuseStrength());
        model.UBO.setValue("BackgroundSpecularStrength", model.renderable.getEnvironmentTextureSpecularStrength());
        const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
        model.UBO.setArray("viewportSize", [tsize.usize, tsize.vsize]);
        model.UBO.setValue("cameraParallel", model.camera.getParallelProjection());
        const device = model._parent.getDevice();
        model.UBO.sendIfNeeded(device);
      }
    };
    publicAPI.updateSSBO = () => {
      const lights = model.renderable.getLights();
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      let lightTimeString = `${model.renderable.getMTime()}`;
      for (let i = 0; i < lights.length; i++) {
        lightTimeString += lights[i].getMTime();
      }
      if (lightTimeString !== model.lightTimeString) {
        const lightPosArray = new Float32Array(lights.length * 4);
        const lightDirArray = new Float32Array(lights.length * 4);
        const lightColorArray = new Float32Array(lights.length * 4);
        const lightTypeArray = new Float32Array(lights.length * 4);
        for (let i = 0; i < lights.length; i++) {
          const offset = i * 4;
          const viewCoordinatePosition = lights[i].getPosition();
          vec3_exports.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);
          lightPosArray[offset] = viewCoordinatePosition[0];
          lightPosArray[offset + 1] = viewCoordinatePosition[1];
          lightPosArray[offset + 2] = viewCoordinatePosition[2];
          lightPosArray[offset + 3] = 0;
          lightDirArray[offset] = -lights[i].getDirection()[0];
          lightDirArray[offset + 1] = -lights[i].getDirection()[1];
          lightDirArray[offset + 2] = -lights[i].getDirection()[2];
          lightDirArray[offset + 3] = 0;
          lightColorArray[offset] = lights[i].getColor()[0];
          lightColorArray[offset + 1] = lights[i].getColor()[1];
          lightColorArray[offset + 2] = lights[i].getColor()[2];
          lightColorArray[offset + 3] = lights[i].getIntensity() * 5;
          lightTypeArray[offset] = getLightTypeIndex(lights[i]);
          lightTypeArray[offset + 1] = Math.cos(radiansFromDegrees(lights[i].getConeAngle()));
          lightTypeArray[offset + 2] = Math.cos(radiansFromDegrees(lights[i].getConeAngle() + lights[i].getConeFalloff()));
          lightTypeArray[offset + 3] = 0;
        }
        model.SSBO.clearData();
        model.SSBO.setNumberOfInstances(lights.length);
        model.SSBO.addEntry("LightPos", "vec4<f32>");
        model.SSBO.addEntry("LightDir", "vec4<f32>");
        model.SSBO.addEntry("LightColor", "vec4<f32>");
        model.SSBO.addEntry("LightData", "vec4<f32>");
        model.SSBO.setAllInstancesFromArray("LightPos", lightPosArray);
        model.SSBO.setAllInstancesFromArray("LightDir", lightDirArray);
        model.SSBO.setAllInstancesFromArray("LightColor", lightColorArray);
        model.SSBO.setAllInstancesFromArray("LightData", lightTypeArray);
        const device = model._parent.getDevice();
        model.SSBO.send(device);
      }
      model.lightTimeString = lightTimeString;
    };
    publicAPI.scissorAndViewport = (encoder) => {
      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0, 1);
      encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    };
    publicAPI.bindUBO = (renderEncoder) => {
      renderEncoder.activateBindGroup(model.bindGroup);
    };
    publicAPI.opaquePass = (prepass) => {
      if (prepass) {
        model.renderEncoder.begin(model._parent.getCommandEncoder());
        publicAPI.updateUBO();
        publicAPI.updateSSBO();
      } else {
        publicAPI.scissorAndViewport(model.renderEncoder);
        publicAPI.clear();
        model.renderEncoder.end();
      }
    };
    publicAPI.clear = () => {
      if (model.renderable.getTransparent() || model.suppressClear) {
        return;
      }
      const device = model._parent.getDevice();
      if (!model.clearFSQ) {
        model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
        model.clearFSQ.setDevice(device);
        model.clearFSQ.setPipelineHash("clearfsq");
        model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
        const ubo = vtkWebGPUUniformBuffer$1.newInstance({
          label: "mapperUBO"
        });
        ubo.addEntry("FSQMatrix", "mat4x4<f32>");
        ubo.addEntry("BackgroundColor", "vec4<f32>");
        model.clearFSQ.setUBO(ubo);
        model.backgroundTex = model.renderable.getEnvironmentTexture();
      }
      if (model.clearFSQ.getPipelineHash() !== "clearfsqwithtexture" && model.renderable.getUseEnvironmentTextureAsBackground() && model.backgroundTex?.getImageLoaded()) {
        model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);
        const ubo = vtkWebGPUUniformBuffer$1.newInstance({
          label: "mapperUBO"
        });
        ubo.addEntry("FSQMatrix", "mat4x4<f32>");
        ubo.addEntry("BackgroundColor", "vec4<f32>");
        model.clearFSQ.setUBO(ubo);
        const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex, "EnvironmentTexture");
        if (environmentTextureHash.getReady()) {
          const tview = environmentTextureHash.createView(`EnvironmentTexture`);
          model.clearFSQ.setTextureViews([tview]);
          model.backgroundTexLoaded = true;
          const interpolate = model.backgroundTex.getInterpolate() ? "linear" : "nearest";
          tview.addSampler(device, {
            addressModeU: "repeat",
            addressModeV: "clamp-to-edge",
            addressModeW: "repeat",
            minFilter: interpolate,
            magFilter: interpolate,
            mipmapFilter: "linear"
          });
        }
        model.clearFSQ.setPipelineHash("clearfsqwithtexture");
      } else if (model.clearFSQ.getPipelineHash() === "clearfsqwithtexture" && !model.renderable.getUseEnvironmentTextureAsBackground()) {
        model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
        model.clearFSQ.setDevice(device);
        model.clearFSQ.setPipelineHash("clearfsq");
        model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
        const ubo = vtkWebGPUUniformBuffer$1.newInstance({
          label: "mapperUBO"
        });
        ubo.addEntry("FSQMatrix", "mat4x4<f32>");
        ubo.addEntry("BackgroundColor", "vec4<f32>");
        model.clearFSQ.setUBO(ubo);
      }
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      const background = model.renderable.getBackgroundByReference();
      model.clearFSQ.getUBO().setArray("BackgroundColor", background);
      mat4_exports.transpose(_tNormalMat4, keyMats.normalMatrix);
      mat4_exports.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);
      mat4_exports.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);
      model.clearFSQ.getUBO().setArray("FSQMatrix", _fsqClearMat4);
      model.clearFSQ.getUBO().sendIfNeeded(device);
      model.clearFSQ.prepareAndDraw(model.renderEncoder);
    };
    publicAPI.translucentPass = (prepass) => {
      if (prepass) {
        model.renderEncoder.begin(model._parent.getCommandEncoder());
      } else {
        publicAPI.scissorAndViewport(model.renderEncoder);
        model.renderEncoder.end();
      }
    };
    publicAPI.volumeDepthRangePass = (prepass) => {
      if (prepass) {
        model.renderEncoder.begin(model._parent.getCommandEncoder());
      } else {
        publicAPI.scissorAndViewport(model.renderEncoder);
        model.renderEncoder.end();
      }
    };
    publicAPI.getAspectRatio = () => {
      const size = model._parent.getSizeByReference();
      const viewport = model.renderable.getViewportByReference();
      return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
    };
    publicAPI.convertToOpenGLDepth = (val) => model.webgpuCamera.convertToOpenGLDepth(val);
    publicAPI.getYInvertedTiledSizeAndOrigin = () => {
      const res = publicAPI.getTiledSizeAndOrigin();
      const size = model._parent.getSizeByReference();
      res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;
      return res;
    };
    publicAPI.getTiledSizeAndOrigin = () => {
      const vport = model.renderable.getViewportByReference();
      const tileViewPort = [0, 0, 1, 1];
      const vpu = vport[0] - tileViewPort[0];
      const vpv = vport[1] - tileViewPort[1];
      const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
      const lowerLeftU = Math.round(ndvp[0]);
      const lowerLeftV = Math.round(ndvp[1]);
      const vpu2 = vport[2] - tileViewPort[0];
      const vpv2 = vport[3] - tileViewPort[1];
      const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
      let usize = Math.round(ndvp2[0]) - lowerLeftU;
      let vsize = Math.round(ndvp2[1]) - lowerLeftV;
      if (usize < 0) {
        usize = 0;
      }
      if (vsize < 0) {
        vsize = 0;
      }
      return {
        usize,
        vsize,
        lowerLeftU,
        lowerLeftV
      };
    };
    publicAPI.getPropFromID = (id) => {
      for (let i = 0; i < model.children.length; i++) {
        const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;
        if (res === id) {
          return model.children[i];
        }
      }
      return null;
    };
    publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();
    publicAPI.releaseGraphicsResources = () => {
      if (model.selector !== null) {
        model.selector.releaseGraphicsResources();
      }
    };
  }
  var DEFAULT_VALUES100 = {
    bindGroup: null,
    selector: null,
    renderEncoder: null,
    recenterThreshold: 20,
    suppressClear: false,
    stabilizedCenter: [0, 0, 0]
  };
  function extend105(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES100, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
      label: "rendererUBO"
    });
    model.UBO.addEntry("WCVCMatrix", "mat4x4<f32>");
    model.UBO.addEntry("SCPCMatrix", "mat4x4<f32>");
    model.UBO.addEntry("PCSCMatrix", "mat4x4<f32>");
    model.UBO.addEntry("SCVCMatrix", "mat4x4<f32>");
    model.UBO.addEntry("VCPCMatrix", "mat4x4<f32>");
    model.UBO.addEntry("WCVCNormals", "mat4x4<f32>");
    model.UBO.addEntry("viewportSize", "vec2<f32>");
    model.UBO.addEntry("LightCount", "i32");
    model.UBO.addEntry("MaxEnvironmentMipLevel", "f32");
    model.UBO.addEntry("BackgroundDiffuseStrength", "f32");
    model.UBO.addEntry("BackgroundSpecularStrength", "f32");
    model.UBO.addEntry("cameraParallel", "u32");
    model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
      label: "rendererLightSSBO"
    });
    model.lightTimeString = "";
    model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
      label: "rendererBG"
    });
    model.bindGroup.setBindables([model.UBO, model.SSBO]);
    model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
    model.stabilizedTime = {};
    obj(model.stabilizedTime, {
      mtime: 0
    });
    get(publicAPI, model, ["bindGroup", "stabilizedTime"]);
    getArray(publicAPI, model, ["stabilizedCenter"]);
    setGet(publicAPI, model, ["renderEncoder", "selector", "suppressClear", "UBO"]);
    vtkWebGPURenderer(publicAPI, model);
  }
  var newInstance104 = newInstance(extend105, "vtkWebGPURenderer");
  registerOverride2("vtkRenderer", newInstance104);

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor.js
  var {
    CoordinateSystem: CoordinateSystem4
  } = vtkProp$1;
  function vtkWebGPUActor(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUActor");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
        model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
        if (model.propID === void 0) {
          model.propID = model.WebGPURenderWindow.getUniquePropID();
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.renderable.getMapper());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.traverseOpaquePass = (renderPass) => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      if (model.children[0]) {
        model.children[0].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };
    publicAPI.traverseTranslucentPass = (renderPass) => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      if (model.children[0]) {
        model.children[0].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        if (model.renderable.getIsOpaque()) {
          renderPass.incrementOpaqueActorCount();
        } else {
          renderPass.incrementTranslucentActorCount();
        }
      }
    };
    publicAPI.getBufferShift = (wgpuRen) => {
      publicAPI.getKeyMatrices(wgpuRen);
      return model.bufferShift;
    };
    publicAPI.getKeyMatrices = (wgpuRen) => {
      if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
        model.renderable.computeMatrix();
        const mcwc = model.renderable.getMatrix();
        model.bufferShift[0] = mcwc[3];
        model.bufferShift[1] = mcwc[7];
        model.bufferShift[2] = mcwc[11];
        const center = wgpuRen.getStabilizedCenterByReference();
        if (model.renderable.getCoordinateSystem() === CoordinateSystem4.WORLD) {
          model.bufferShift[0] -= center[0];
          model.bufferShift[1] -= center[1];
          model.bufferShift[2] -= center[2];
        }
        mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
        if (model.renderable.getIsIdentity()) {
          mat4_exports.identity(model.keyMatrices.normalMatrix);
        } else {
          mat4_exports.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
          model.keyMatrices.normalMatrix[3] = 0;
          model.keyMatrices.normalMatrix[7] = 0;
          model.keyMatrices.normalMatrix[11] = 0;
          mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
          mat4_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        }
        mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
        if (model.renderable.getCoordinateSystem() === CoordinateSystem4.WORLD) {
          mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
        } else {
          mat4_exports.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
        }
        model.keyMatricesTime.modified();
      }
      return model.keyMatrices;
    };
  }
  var DEFAULT_VALUES101 = {
    keyMatricesTime: null,
    keyMatrices: null,
    propID: void 0,
    bufferShift: void 0
  };
  function extend106(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES101, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatricesTime = {};
    macro.obj(model.keyMatricesTime, {
      mtime: 0
    });
    model.keyMatrices = {
      normalMatrix: new Float64Array(16),
      bcwc: new Float64Array(16),
      bcsc: new Float64Array(16)
    };
    macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
    model.bufferShift = [0, 0, 0, 0];
    vtkWebGPUActor(publicAPI, model);
  }
  var newInstance105 = macro.newInstance(extend106);
  registerOverride2("vtkActor", newInstance105);

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor2D.js
  var {
    CoordinateSystem: CoordinateSystem5
  } = vtkProp$1;
  function vtkWebGPUActor2D(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUActor2D");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
        model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
        if (model.propID === void 0) {
          model.propID = model.WebGPURenderWindow.getUniquePropID();
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.renderable.getMapper());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.traverseOpaquePass = (renderPass) => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      if (model.children[0]) {
        model.children[0].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };
    publicAPI.traverseTranslucentPass = (renderPass) => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      if (model.children[0]) {
        model.children[0].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        if (model.renderable.getIsOpaque()) {
          renderPass.incrementOpaqueActorCount();
        } else {
          renderPass.incrementTranslucentActorCount();
        }
      }
    };
    publicAPI.getBufferShift = (wgpuRen) => {
      publicAPI.getKeyMatrices(wgpuRen);
      return model.bufferShift;
    };
    publicAPI.getKeyMatrices = (wgpuRen) => {
      if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
        model.bufferShift[0] = 0;
        model.bufferShift[1] = 0;
        model.bufferShift[2] = 0;
        const center = wgpuRen.getStabilizedCenterByReference();
        if (model.renderable.getCoordinateSystem() === CoordinateSystem5.WORLD) {
          model.bufferShift[0] -= center[0];
          model.bufferShift[1] -= center[1];
          model.bufferShift[2] -= center[2];
        }
        mat4_exports.identity(model.keyMatrices.bcwc);
        mat4_exports.identity(model.keyMatrices.normalMatrix);
        mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
        if (model.renderable.getCoordinateSystem() === CoordinateSystem5.WORLD) {
          mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
        } else {
          mat4_exports.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
        }
        model.keyMatricesTime.modified();
      }
      return model.keyMatrices;
    };
  }
  var DEFAULT_VALUES102 = {
    keyMatricesTime: null,
    keyMatrices: null,
    propID: void 0,
    bufferShift: void 0
  };
  function extend107(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES102, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatricesTime = {};
    macro.obj(model.keyMatricesTime, {
      mtime: 0
    });
    model.keyMatrices = {
      normalMatrix: new Float64Array(16),
      bcwc: new Float64Array(16),
      bcsc: new Float64Array(16)
    };
    macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
    model.bufferShift = [0, 0, 0, 0];
    vtkWebGPUActor2D(publicAPI, model);
  }
  var newInstance106 = macro.newInstance(extend107);
  registerOverride2("vtkActor2D", newInstance106);

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/CubeAxesActor.js
  function vtkWebGPUCubeAxesActor(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUCubeAxesActor");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
        model.WebGPURenderWindow = model.WebGPURenderer.getParent();
        if (!model.CubeAxesActorHelper.getRenderable()) {
          model.CubeAxesActorHelper.setRenderable(model.renderable);
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
        publicAPI.addMissingNode(model.renderable.getGridActor());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
        const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
        model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
      }
    };
  }
  var DEFAULT_VALUES103 = {};
  function extend108(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES103, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();
    vtkWebGPUCubeAxesActor(publicAPI, model);
  }
  var newInstance107 = newInstance(extend108, "vtkWebGPUCubeAxesActor");
  registerOverride2("vtkCubeAxesActor", newInstance107);

  // node_modules/@kitware/vtk.js/Rendering/Core/Property2D.js
  var {
    DisplayLocation: DisplayLocation2
  } = Constants14;
  function vtkProperty2D(publicAPI, model) {
    model.classHierarchy.push("vtkProperty2D");
    publicAPI.setDisplayLocationToBackground = () => publicAPI.setDisplayLocation(DisplayLocation2.BACKGROUND);
    publicAPI.setDisplayLocationToForeground = () => publicAPI.setDisplayLocation(DisplayLocation2.FOREGROUND);
    publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation.WIREFRAME);
    publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation.SURFACE);
    publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation.POINTS);
    publicAPI.getRepresentationAsString = () => macro.enumToString(Representation, model.representation);
  }
  var DEFAULT_VALUES104 = {
    color: [1, 1, 1],
    opacity: 1,
    pointSize: 1,
    lineWidth: 1,
    representation: Representation.SURFACE,
    displayLocation: DisplayLocation2.FOREGROUND
  };
  function extend109(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES104, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["opacity", "lineWidth", "pointSize", "displayLocation", "representation"]);
    macro.setGetArray(publicAPI, model, ["color"], 3);
    vtkProperty2D(publicAPI, model);
  }
  var newInstance108 = macro.newInstance(extend109, "vtkProperty2D");
  var vtkProperty2D$1 = {
    newInstance: newInstance108,
    extend: extend109,
    ...Constants14
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/CellArrayMapper.js
  var {
    BufferUsage: BufferUsage6,
    PrimitiveTypes: PrimitiveTypes4
  } = vtkWebGPUBufferManager$1;
  var {
    Representation: Representation7
  } = vtkProperty$1;
  var {
    ScalarMode: ScalarMode4
  } = vtkMapper$1;
  var {
    CoordinateSystem: CoordinateSystem6
  } = vtkProp$1;
  var {
    DisplayLocation: DisplayLocation3
  } = vtkProperty2D$1;
  var vtkWebGPUPolyDataVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
  var vtkWebGPUPolyDataFS = `
struct PBRData {
  diffuse: vec3<f32>,
  specular: vec3<f32>,
}

struct Material {
  ior: f32,
  roughness: f32,
  metallic: f32,
  base: vec3<f32>,
};

struct DirectionalLight {
  direction: vec3<f32>,
  color: vec3<f32>,
};

struct PointLight {
  position: vec3<f32>,
  color: vec3<f32>,
};

struct SpotLight {
  position: vec3<f32>,
  direction: vec3<f32>,
  cones: vec2<f32>,
  color: vec3<f32>,
};

const pi: f32 = 3.14159265359;

// Dot product with the max already in it
fn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  return max(0.0, dot(a, b));
}
// Dot product with a max in it that does not allow for negative values
// Physically based rendering is accurate as long as normals are accurate,
// however this is pretty often not the case. In order to prevent negative
// values from ruining light calculations and creating zones of zero light,
// this remapping is used, which smoothly clamps the dot product between
// zero and one while still maintaining a good amount of accuracy.
fn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  var d: f32 = max(0.0, dot(a, b));
  d = pow((d + 1.0) / 2.0, 2.6);
  return d;
}

// Lambertian diffuse model
fn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5);
  return (base/pi)*NdotL;
}

// Yasuhiro Fujii improvement on the Oren-Nayar model
// https://mimosa-pudica.net/improved-oren-nayar.html
// p is surface color, o is roughness
fn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {
  var invpi: f32 = 0.31830988618; // 1/pi

  var o2 = o*o;
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the "seams" between lights better

  var NdotV: f32 = mdot(N, V);
  var LdotV: f32 = mdot(L, V);

  var s: f32 = LdotV - NdotL*NdotV;
  var t: f32 = mix(1.0, max(NdotL, NdotV), step(0.0, s)); // Mix with step is the equivalent of an if statement
  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));
  A = invpi*(1 - A);
  var B: f32 = 0.45*(o2 / (o2 + 0.09));
  B = invpi*B;

  return p*NdotL*(A + B*(s/t));
}

// Fresnel portion of BRDF (IOR only, simplified)
fn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {
  var NdotV: f32 = mdot(V, N);
  var F0: f32 = (pow((ior - 1.0), 2.0) + k*k) / (pow((ior + 1.0), 2.0) + k*k); // This takes into account the roughness, which the other one does not
  return F0 + (1.0 - F0) * pow((1.0-NdotV), 5.0);
}

// Fresnel portion of BRDF (Color ior, better)
fn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {
  var NdotV: f32 = mdot(V, N);
  return F0 + (1.0 - F0) * pow((1-NdotV), 5.0);
}

// Normal portion of BRDF
// https://learnopengl.com/PBR/Theory
// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2
fn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {
  var a2: f32 = a*a;
  var NdotH = mdot(N, H);
  var NdotH2 = NdotH*NdotH;

  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;

  return a2 / max((pi*denom*denom), 0.000001);
}

// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent
fn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {
  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;

  var ggx1: f32 = trGGX(N + Op*s, H, a);
  var ggx2: f32 = trGGX(N - Op*s, H, a);
  return (0.5 * ggx1 + 0.5 * ggx2);
}

// Geometry portion of BRDF
fn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {
  var NdotX = cdot(N, X);
  return NdotX / max(0.000001, (NdotX*(1.0-k) + k));
}

fn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {
  var ggx1: f32 = min(1.0, schlickGGX(N, V, k));
  var ggx2: f32 = min(1.0, schlickGGX(N, L, k));
  return ggx1*ggx2;
}

// BRDF Combination
fn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {
  var num: f32 = D*F*G;
  var denom: f32 = 4*cdot(V, N)*cdot(L, N);

  return num / max(denom, 0.000001);
}

// Different lighting calculations for different light sources
fn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, mat: Material, light: DirectionalLight) -> PBRData {
  var L: vec3<f32> = normalize(light.direction); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector

  var alpha = mat.roughness * mat.roughness;
  var k: f32 = alpha * alpha / 2.0;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L); // Fresnel term is replaced with 1 because it is added later
  var incoming: vec3<f32> = light.color;
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5);

  var specular: vec3<f32> = brdf * incoming * angle;
  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate
  // control property for the diffuse vs specular roughness
  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);
  // Stores the specular and diffuse separately to allow for finer post processing
  var out = PBRData(diffuse, specular);

  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

fn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, mat: Material, light: PointLight) -> PBRData {
  var L: vec3<f32> = normalize(light.position - fragPos);
  var H: vec3<f32> = normalize(L + V);
  var dist = distance(light.position, fragPos);

  var alpha = mat.roughness * mat.roughness;
  var k: f32 = alpha * alpha / 2.0;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  var F: f32 = schlickFresnelIOR(V, N, mat.ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  var incoming: vec3<f32> = light.color * (1.0 / (dist * dist));
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" between light sources

  var specular: vec3<f32> = brdf * incoming * angle;
  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);
  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);

  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights
fn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, mat: Material, light: SpotLight) -> PBRData {
  var L: vec3<f32> = normalize(light.position - fragPos);
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(light.position, fragPos);

  var alpha = mat.roughness * mat.roughness;
  var k: f32 = alpha * alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);

  var theta: f32 = mdot(normalize(light.direction), L);
  var epsilon: f32 = light.cones.x - light.cones.y;
  var intensity: f32 = (theta - light.cones.y) / epsilon;
  intensity = clamp(intensity, 0.0, 1.0);
  intensity /= dist * dist;

  var incoming: vec3<f32> = light.color * intensity;

  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" between light sources

  var specular: vec3<f32> = brdf * incoming * angle;
  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);

  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// Environment mapping stuff
// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::TCoord::Dec

// optional surface normal declaration
//VTK::Normal::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  // Temporary ambient, diffuse, and opacity
  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;
  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;
  var opacity: f32 = mapperUBO.Opacity;
  var ior: f32 = mapperUBO.BaseIOR;

  // This should be declared somewhere else
  var _diffuseMap: vec4<f32> = vec4<f32>(1.0);
  var _roughnessMap: vec4<f32> = vec4<f32>(1.0);
  var _metallicMap: vec4<f32> = vec4<f32>(1.0);
  var _normalMap: vec4<f32> = vec4<f32>(0.0, 0.0, 1.0, 0.0); // normal map was setting off the normal vector detection in fragment
  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1.);
  var _emissionMap: vec4<f32> = vec4<f32>(0.);

  //VTK::Color::Impl

  //VTK::TCoord::Impl

  //VTK::Normal::Impl

  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);

  //VTK::Light::Impl

  //VTK::Select::Impl

  // Use texture alpha for transparency
  computedColor.a = mapperUBO.Opacity * _diffuseMap.a;
  if (computedColor.a == 0.0) { discard; };

  //VTK::Position::Impl

  //VTK::RenderEncoder::Impl

  return output;
}
`;
  function isEdges(hash) {
    return hash.indexOf("edge") >= 0;
  }
  function vtkWebGPUCellArrayMapper(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUCellArrayMapper");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        if (model.is2D) {
          model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor2D");
          model.forceZValue = true;
        } else {
          model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor");
          model.forceZValue = false;
        }
        model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();
        model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem6.DISPLAY;
        model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType("vtkWebGPURenderer");
        model.WebGPURenderWindow = model.WebGPURenderer.getParent();
        model.device = model.WebGPURenderWindow.getDevice();
      }
    };
    publicAPI.translucentPass = (prepass) => {
      if (prepass) {
        publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
        model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
      }
    };
    publicAPI.opaquePass = (prepass) => {
      if (prepass) {
        publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
        model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
      }
    };
    publicAPI.updateUBO = () => {
      const actor = model.WebGPUActor.getRenderable();
      const ppty = actor.getProperty();
      const utime = model.UBO.getSendTime();
      if (publicAPI.getMTime() <= utime && ppty.getMTime() <= utime && model.renderable.getMTime() <= utime) {
        return;
      }
      const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);
      model.UBO.setArray("BCWCMatrix", keyMats.bcwc);
      model.UBO.setArray("BCSCMatrix", keyMats.bcsc);
      model.UBO.setArray("MCWCNormals", keyMats.normalMatrix);
      if (model.is2D) {
        const displayLoc = ppty.getDisplayLocation?.() ?? DisplayLocation3.BACKGROUND;
        model.UBO.setValue("ZValue", displayLoc === DisplayLocation3.FOREGROUND ? 1 : 0);
        const aColor = ppty.getColorByReference();
        model.UBO.setValue("AmbientIntensity", 1);
        model.UBO.setArray("DiffuseColor", [...aColor, 1]);
        model.UBO.setValue("DiffuseIntensity", 0);
        model.UBO.setValue("SpecularIntensity", 0);
      } else {
        model.UBO.setValue("AmbientIntensity", ppty.getAmbient());
        model.UBO.setArray("AmbientColor", [...ppty.getAmbientColorByReference(), 1]);
        model.UBO.setValue("DiffuseIntensity", ppty.getDiffuse());
        model.UBO.setArray("DiffuseColor", [...ppty.getDiffuseColorByReference(), 1]);
        model.UBO.setValue("Roughness", ppty.getRoughness());
        model.UBO.setValue("BaseIOR", ppty.getBaseIOR());
        model.UBO.setValue("Metallic", ppty.getMetallic());
        model.UBO.setValue("NormalStrength", ppty.getNormalStrength());
        model.UBO.setValue("Emission", ppty.getEmission());
        model.UBO.setValue("SpecularIntensity", ppty.getSpecular());
        if (ppty.getSpecularColorByReference()) {
          model.UBO.setArray("SpecularColor", [...ppty.getSpecularColorByReference(), 1]);
        }
      }
      const edgeColor = ppty.getEdgeColorByReference?.();
      if (edgeColor) model.UBO.setArray("EdgeColor", [...edgeColor, 1]);
      model.UBO.setValue("LineWidth", ppty.getLineWidth());
      model.UBO.setValue("Opacity", ppty.getOpacity());
      model.UBO.setValue("PropID", model.WebGPUActor.getPropID());
      model.UBO.sendIfNeeded(model.WebGPURenderWindow.getDevice());
    };
    publicAPI.haveWideLines = () => {
      const actor = model.WebGPUActor.getRenderable();
      const representation = actor.getProperty().getRepresentation();
      if (actor.getProperty().getLineWidth() <= 1) {
        return false;
      }
      if (model.primitiveType === PrimitiveTypes4.Verts) {
        return false;
      }
      if (model.primitiveType === PrimitiveTypes4.Triangles || model.primitiveType === PrimitiveTypes4.TriangleStrips) {
        return representation === Representation7.WIREFRAME;
      }
      return true;
    };
    publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription("vertex");
      vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
      if (!vDesc.hasOutput("vertexVC")) vDesc.addOutput("vec4<f32>", "vertexVC");
      let code = vDesc.getCode();
      if (model.useRendererMatrix) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;", "    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);", "//VTK::Position::Impl"]).result;
        if (model.forceZValue) {
          code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);", "pCoord.z = mapperUBO.ZValue;", "//VTK::Position::Impl"]).result;
        }
      } else {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;", "    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;", "    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;", "    pCoord.z = 0.5 - 0.5 * pCoord.z;", "//VTK::Position::Impl"]).result;
        if (model.forceZValue) {
          code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    pCoord.z = mapperUBO.ZValue;", "//VTK::Position::Impl"]).result;
        }
      }
      if (publicAPI.haveWideLines()) {
        vDesc.addBuiltinInput("u32", "@builtin(instance_index) instanceIndex");
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", [
          "    var tmpPos: vec4<f32> = pCoord;",
          "    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);",
          "    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;",
          "    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;",
          "    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;",
          "    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;",
          "    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);",
          // could become a setting
          "    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);",
          "//VTK::Position::Impl"
        ]).result;
      }
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = pCoord;"]).result;
      vDesc.setCode(code);
    };
    model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
    publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
      const normalBuffer = vertexInput.getBuffer("normalMC");
      const actor = model.WebGPUActor.getRenderable();
      if (normalBuffer) {
        const vDesc = pipeline.getShaderDescription("vertex");
        if (!vDesc.hasOutput("normalVC")) {
          vDesc.addOutput("vec3<f32>", "normalVC", normalBuffer.getArrayInformation()[0].interpolation);
        }
        if (!vDesc.hasOutput("tangentVC")) {
          vDesc.addOutput("vec3<f32>", "tangentVC", normalBuffer.getArrayInformation()[0].interpolation);
        }
        if (!vDesc.hasOutput("bitangentVC")) {
          vDesc.addOutput("vec3<f32>", "bitangentVC", normalBuffer.getArrayInformation()[0].interpolation);
        }
        let code = vDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", [
          "  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);",
          // This is just an approximation, but it happens to work extremely well
          // It only works well for normals that are head on and not super angled though
          // Definitely needs to be replaced
          "  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));",
          "  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));",
          "  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));",
          "  output.tangentVC = normalize(tangent);",
          "  output.bitangentVC = normalize(cross(output.normalVC, tangent));"
        ]).result;
        vDesc.setCode(code);
        const fDesc = pipeline.getShaderDescription("fragment");
        code = fDesc.getCode();
        if (actor.getProperty().getNormalTexture()) {
          code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", ["  var normal: vec3<f32> = input.normalVC;", "  if (!input.frontFacing) { normal = -normal; }", "  var tangent: vec3<f32> = input.tangentVC;", "  var bitangent: vec3<f32> = input.bitangentVC;", "  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(", "    tangent.x, bitangent.x, normal.x,", "    tangent.y, bitangent.y, normal.y,", "    tangent.z, bitangent.z, normal.z,", "  );", "  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);", "  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);", "  normal = normalize(normal);"]).result;
        } else {
          code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", ["  var normal: vec3<f32> = input.normalVC;", "  if (!input.frontFacing) { normal = -normal; }", "  normal = normalize(normal);"]).result;
        }
        fDesc.setCode(code);
      }
    };
    model.shaderReplacements.set("replaceShaderNormal", publicAPI.replaceShaderNormal);
    publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {
      if (hash.includes("sel")) return;
      const vDesc = pipeline.getShaderDescription("vertex");
      if (!vDesc.hasOutput("vertexVC")) vDesc.addOutput("vec4<f32>", "vertexVC");
      const renderer = model.WebGPURenderer.getRenderable();
      const fDesc = pipeline.getShaderDescription("fragment");
      let code = fDesc.getCode();
      if (code.includes("var normal:") && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes("sel")) {
        const lightingCode = [
          // Vectors needed for light calculations
          "  let fragPos = vec3<f32>(input.vertexVC.xyz);",
          "  let V = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector",
          // Values needed for light calculations
          "  let baseColor = _diffuseMap.rgb * diffuseColor.rgb;",
          "  let roughness = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);",
          // Need to have a different way of sampling greyscale values aside from .r
          "  let metallic = mapperUBO.Metallic * _metallicMap.r;",
          "  let alpha = roughness * roughness;",
          "  let k = alpha * alpha / 2.0;",
          // Split diffuse and specular components
          "  var diffuse = vec3<f32>(0.);",
          "  var specular = vec3<f32>(0.);",
          "  let emission = _emissionMap.rgb * mapperUBO.Emission;",
          "",
          "  // Material struct",
          "  let mat = Material(ior, roughness, metallic, baseColor);",
          "",
          // Summing diffuse and specular components of directional lights
          "  {",
          "    var i = 0;",
          "    loop {",
          "      if (!(i < rendererUBO.LightCount)) { break; }",
          "      switch (i32(rendererLightSSBO.values[i].LightData.x)) {",
          "         // Point Light",
          "         case 0 {",
          "           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
          "           let pos = (rendererLightSSBO.values[i].LightPos).xyz;",
          "           let pointLight = PointLight(pos, color);",
          "           let result = calcPointLight(normal, V, fragPos, mat, pointLight);",
          "           diffuse += max(vec3<f32>(0), result.diffuse);",
          "           specular += max(vec3<f32>(0), result.specular);",
          "          }",
          "         // Directional light",
          "         case 1 {",
          "           let dir = normalize((rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz);",
          "           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
          "           let dirLight = DirectionalLight(dir, color);",
          "           let result = calcDirectionalLight(normal, V, mat, dirLight); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color",
          "           diffuse += max(vec3<f32>(0), result.diffuse);",
          "           specular += max(vec3<f32>(0), result.specular);",
          "         }",
          "         // Spot Light",
          "         case 2 {",
          "           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
          "           let pos = (rendererLightSSBO.values[i].LightPos).xyz;",
          "           let dir = normalize((rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz);",
          "           let cones = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);",
          "           let spotLight = SpotLight(pos, dir, cones, color);",
          "           let result = calcSpotLight(normal, V, fragPos, mat, spotLight);",
          "           diffuse += max(vec3<f32>(0), result.diffuse);",
          "           specular += max(vec3<f32>(0), result.specular);",
          "         }",
          "         default { continue; }",
          "       }",
          "      continuing { i++; }",
          "    }",
          "  }",
          // Final variables for combining specular and diffuse
          "  let fresnel = min(1.0, schlickFresnelIOR(V, normal, ior, k)); // Fresnel",
          "  // This could be controlled with its own variable (that isnt base color) for better artistic control",
          "  let fresnelMetallic = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account",
          "  let kS = min(vec3<f32>(1.0), mix(vec3<f32>(fresnel), fresnelMetallic, metallic));",
          "  let kD = (1.0 - kS) * (1.0 - metallic);",
          "  let PBR = mapperUBO.DiffuseIntensity * kD * diffuse + kS * specular;",
          "  computedColor = vec4<f32>(PBR + emission, mapperUBO.Opacity);"
        ];
        if (renderer.getEnvironmentTexture()?.getImageLoaded()) {
          lightingCode.push(
            "  // To get diffuse IBL, the texture is sampled with normals in worldspace",
            "  let diffuseIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;",
            "  let diffuseCoords = vecToRectCoord(diffuseIBLCoords);",
            "  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors",
            "  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment",
            "  let VreflN = normalize(reflect(-V, normal));",
            "  let reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;",
            "  let specularCoords = vecToRectCoord(reflectionIBLCoords);",
            "  let diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);",
            // Level multiplier should be set by UBO
            "  let level = roughness * rendererUBO.MaxEnvironmentMipLevel;",
            "  let specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);",
            // Manual mip smoothing since not all formats support smooth level sampling
            "  let specularIBLContribution = specularIBL.rgb * rendererUBO.BackgroundSpecularStrength;",
            "  computedColor += vec4<f32>(specularIBLContribution * kS, 0);",
            "  let diffuseIBLContribution = diffuseIBL.rgb * rendererUBO.BackgroundDiffuseStrength;",
            "  computedColor += vec4<f32>(diffuseIBLContribution * baseColor * _ambientOcclusionMap.rgb * kD, 0);"
          );
        }
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Light::Impl", lightingCode).result;
        fDesc.setCode(code);
      } else {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Light::Impl", ["  let diffuse = diffuseColor.rgb;", "  let specular = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;", "  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);"]).result;
        fDesc.setCode(code);
      }
    };
    model.shaderReplacements.set("replaceShaderLight", publicAPI.replaceShaderLight);
    publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {
      if (isEdges(hash)) {
        const fDesc2 = pipeline.getShaderDescription("fragment");
        let code2 = fDesc2.getCode();
        code2 = vtkWebGPUShaderCache$1.substitute(code2, "//VTK::Color::Impl", ["ambientColor = mapperUBO.EdgeColor;", "diffuseColor = mapperUBO.EdgeColor;"]).result;
        fDesc2.setCode(code2);
        return;
      }
      const colorBuffer = vertexInput.getBuffer("colorVI");
      if (!colorBuffer) return;
      const vDesc = pipeline.getShaderDescription("vertex");
      vDesc.addOutput("vec4<f32>", "color", colorBuffer.getArrayInformation()[0].interpolation);
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["  output.color = colorVI;"]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription("fragment");
      code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["ambientColor = input.color;", "diffuseColor = input.color;", "opacity = mapperUBO.Opacity * input.color.a;"]).result;
      fDesc.setCode(code);
    };
    model.shaderReplacements.set("replaceShaderColor", publicAPI.replaceShaderColor);
    publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
      if (!vertexInput.hasAttribute("tcoord")) return;
      const vDesc = pipeline.getShaderDescription("vertex");
      const tcoords = vertexInput.getBuffer("tcoord");
      const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
      let code = vDesc.getCode();
      vDesc.addOutput(`vec${numComp}<f32>`, "tcoordVS");
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::TCoord::Impl", ["  output.tcoordVS = tcoord;"]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription("fragment");
      code = fDesc.getCode();
      const actor = model.WebGPUActor.getRenderable();
      const property = actor.getProperty();
      const checkDims = (texture) => {
        if (!texture) return false;
        const dims = texture.getDimensionality();
        return dims === numComp;
      };
      const usedTextures = [];
      const diffuseTexture = property.getDiffuseTexture?.();
      if (diffuseTexture?.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {
        if (
          // Chained or statements here are questionable
          checkDims(diffuseTexture) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)
        ) {
          usedTextures.push("_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);");
        }
      }
      const ormTexture = property.getORMTexture?.();
      const rmTexture = property.getRMTexture?.();
      const roughnessTexture = property.getRoughnessTexture?.();
      const metallicTexture = property.getMetallicTexture?.();
      const ambientOcclusionTexture = property.getAmbientOcclusionTexture?.();
      const emissionTexture = property.getEmissionTexture?.();
      const normalTexture = property.getNormalTexture?.();
      if (ormTexture?.getImageLoaded()) {
        if (checkDims(ormTexture)) {
          usedTextures.push("_ambientOcclusionMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).rrra;", "_roughnessMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).ggga;", "_metallicMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).bbba;");
        }
      } else if (rmTexture?.getImageLoaded()) {
        if (checkDims(rmTexture)) {
          usedTextures.push("_roughnessMap = textureSample(RMTexture, RMTextureSampler, input.tcoordVS).ggga;", "_metallicMap = textureSample(RMTexture, RMTextureSampler, input.tcoordVS).bbba;");
        }
      } else {
        if (roughnessTexture?.getImageLoaded()) {
          if (checkDims(roughnessTexture)) {
            usedTextures.push("_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS).ggga;");
          }
        }
        if (metallicTexture?.getImageLoaded()) {
          if (checkDims(metallicTexture)) {
            usedTextures.push("_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS).bbba;");
          }
        }
        if (ambientOcclusionTexture?.getImageLoaded()) {
          if (checkDims(ambientOcclusionTexture)) {
            usedTextures.push("_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS).rrra;");
          }
        }
      }
      if (emissionTexture?.getImageLoaded()) {
        if (checkDims(emissionTexture)) {
          usedTextures.push("_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);");
        }
      }
      if (normalTexture?.getImageLoaded()) {
        if (checkDims(normalTexture)) {
          usedTextures.push("_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);");
        }
      }
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::TCoord::Impl", usedTextures).result;
      fDesc.setCode(code);
    };
    model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
    publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {
      if (hash.includes("sel")) {
        const fDesc = pipeline.getShaderDescription("fragment");
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Select::Impl", ["  var compositeID: u32 = 0u;"]).result;
        fDesc.setCode(code);
      }
    };
    model.shaderReplacements.set("replaceShaderSelect", publicAPI.replaceShaderSelect);
    publicAPI.getUsage = (rep, i) => {
      if (rep === Representation7.POINTS || i === PrimitiveTypes4.Points) {
        return BufferUsage6.Verts;
      }
      if (i === PrimitiveTypes4.Lines) {
        return BufferUsage6.Lines;
      }
      if (rep === Representation7.WIREFRAME) {
        if (i === PrimitiveTypes4.Triangles) {
          return BufferUsage6.LinesFromTriangles;
        }
        return BufferUsage6.LinesFromStrips;
      }
      if (i === PrimitiveTypes4.Triangles) {
        return BufferUsage6.Triangles;
      }
      if (i === PrimitiveTypes4.TriangleStrips) {
        return BufferUsage6.Strips;
      }
      if (i === PrimitiveTypes4.TriangleEdges) {
        return BufferUsage6.LinesFromTriangles;
      }
      return BufferUsage6.LinesFromStrips;
    };
    publicAPI.getHashFromUsage = (usage) => `pt${usage}`;
    publicAPI.getTopologyFromUsage = (usage) => {
      switch (usage) {
        case BufferUsage6.Triangles:
          return "triangle-list";
        case BufferUsage6.Verts:
          return "point-list";
        case BufferUsage6.Lines:
        default:
          return "line-list";
      }
    };
    publicAPI.buildVertexInput = () => {
      const pd = model.currentInput;
      const cells = model.cellArray;
      const primType = model.primitiveType;
      const actor = model.WebGPUActor.getRenderable();
      let representation = actor.getProperty().getRepresentation();
      const device = model.WebGPURenderWindow.getDevice();
      let edges = false;
      if (primType === PrimitiveTypes4.TriangleEdges) {
        edges = true;
        representation = Representation7.WIREFRAME;
      }
      const vertexInput = model.vertexInput;
      const points = pd.getPoints();
      let indexBuffer = null;
      if (cells) {
        indexBuffer = device.getBufferManager().getBuffer({
          hash: `R${representation}P${primType}${cells.getMTime()}`,
          usage: BufferUsage6.Index,
          cells,
          numberOfPoints: points.getNumberOfPoints(),
          primitiveType: primType,
          representation
        });
        vertexInput.setIndexBuffer(indexBuffer);
      } else {
        vertexInput.setIndexBuffer(null);
      }
      if (points) {
        const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);
        vertexInput.addBuffer(device.getBufferManager().getBuffer({
          hash: `${points.getMTime()}I${indexBuffer?.getMTime?.() ?? 0}${shift.join()}float32x4`,
          usage: BufferUsage6.PointArray,
          format: "float32x4",
          dataArray: points,
          indexBuffer,
          shift,
          packExtra: true
        }), ["vertexBC"]);
      } else {
        vertexInput.removeBufferIfPresent("vertexBC");
      }
      const usage = publicAPI.getUsage(representation, primType);
      model._usesCellNormals = false;
      if (!model.is2D && // no lighting on Property2D
      (usage === BufferUsage6.Triangles || usage === BufferUsage6.Strips)) {
        const normals = pd.getPointData().getNormals();
        const buffRequest = {
          format: "snorm8x4",
          indexBuffer,
          packExtra: true,
          shift: 0,
          scale: 127
        };
        if (normals) {
          buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
          buffRequest.dataArray = normals;
          buffRequest.usage = BufferUsage6.PointArray;
          vertexInput.addBuffer(device.getBufferManager().getBuffer(buffRequest), ["normalMC"]);
        } else if (primType === PrimitiveTypes4.Triangles) {
          model._usesCellNormals = true;
          buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
          buffRequest.dataArray = points;
          buffRequest.cells = cells;
          buffRequest.usage = BufferUsage6.NormalsFromPoints;
          vertexInput.addBuffer(device.getBufferManager().getBuffer(buffRequest), ["normalMC"]);
        } else {
          vertexInput.removeBufferIfPresent("normalMC");
        }
      } else {
        vertexInput.removeBufferIfPresent("normalMC");
      }
      let haveColors = false;
      if (model.renderable.getScalarVisibility()) {
        const c = model.renderable.getColorMapColors();
        if (c && !edges) {
          const scalarMode = model.renderable.getScalarMode();
          const haveCellScalars = (scalarMode === ScalarMode4.USE_CELL_DATA || scalarMode === ScalarMode4.USE_CELL_FIELD_DATA || scalarMode === ScalarMode4.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode4.USE_POINT_FIELD_DATA && c;
          vertexInput.addBuffer(device.getBufferManager().getBuffer({
            usage: BufferUsage6.PointArray,
            format: "unorm8x4",
            hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,
            dataArray: c,
            indexBuffer,
            cellData: haveCellScalars,
            cellOffset: 0
          }), ["colorVI"]);
          haveColors = true;
        }
      }
      if (!haveColors) vertexInput.removeBufferIfPresent("colorVI");
      let tcoords = null;
      if (model.renderable.getInterpolateScalarsBeforeMapping?.() && model.renderable.getColorCoordinates()) {
        tcoords = model.renderable.getColorCoordinates();
      } else {
        tcoords = pd.getPointData().getTCoords();
      }
      if (tcoords && !edges) {
        vertexInput.addBuffer(device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer()), ["tcoord"]);
      } else {
        vertexInput.removeBufferIfPresent("tcoord");
      }
    };
    publicAPI.updateTextures = () => {
      const usedTextures = [];
      const newTextures = [];
      const idata = model.renderable.getColorTextureMap?.();
      if (idata && !model.colorTexture) {
        model.colorTexture = vtkTexture$1.newInstance({
          label: "polyDataColor"
        });
      }
      if (idata) {
        model.colorTexture.setInputData(idata);
        newTextures.push(["DiffuseTexture", model.colorTexture]);
      }
      const actor = model.WebGPUActor.getRenderable();
      const renderer = model.WebGPURenderer.getRenderable();
      const textures = [["DiffuseTexture", actor.getProperty().getDiffuseTexture?.()], ["DiffuseTexture", actor.getTextures()[0]], ["DiffuseTexture", model.colorTexture], ["ORMTexture", actor.getProperty().getORMTexture?.()], ["RMTexture", actor.getProperty().getRMTexture?.()], ["RoughnessTexture", actor.getProperty().getRoughnessTexture?.()], ["MetallicTexture", actor.getProperty().getMetallicTexture?.()], ["NormalTexture", actor.getProperty().getNormalTexture?.()], ["AmbientOcclusionTexture", actor.getProperty().getAmbientOcclusionTexture?.()], ["EmissionTexture", actor.getProperty().getEmissionTexture?.()], ["EnvironmentTexture", renderer.getEnvironmentTexture?.()]];
      textures.forEach((_ref) => {
        let [name, tex] = _ref;
        if (!tex) return;
        if (tex.getInputData() || tex.getJsImageData() || tex.getCanvas() || tex.getImageBitmap()) {
          newTextures.push([name, tex]);
        }
        if (tex.getImage() && tex.getImageLoaded()) {
          newTextures.push([name, tex]);
        }
      });
      newTextures.forEach((_ref2) => {
        let [textureName, srcTexture] = _ref2;
        const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture, textureName);
        if (!newTex.getReady()) return;
        let found = false;
        for (let t = 0; t < model.textures.length; ++t) {
          if (model.textures[t] === newTex) {
            found = true;
            usedTextures[t] = true;
            break;
          }
        }
        if (!found) {
          usedTextures[model.textures.length] = true;
          const tview = newTex.createView(textureName);
          model.textures.push(newTex);
          model.textureViews.push(tview);
          const interpolate = srcTexture.getInterpolate() ? "linear" : "nearest";
          let addressMode = null;
          if (srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = "mirror-repeat";
          else if (srcTexture.getEdgeClamp()) addressMode = "clamp-to-edge";
          else if (srcTexture.getRepeat()) addressMode = "repeat";
          let options = {
            addressModeU: addressMode,
            addressModeV: addressMode,
            addressModeW: addressMode,
            minFilter: interpolate,
            magFilter: interpolate
          };
          if (textureName === "EnvironmentTexture") {
            options = {
              addressModeU: "repeat",
              addressModeV: "clamp-to-edge",
              addressModeW: "repeat",
              minFilter: interpolate,
              magFilter: interpolate,
              mipmapFilter: "linear"
            };
          }
          tview.addSampler(model.device, options);
        }
      });
      for (let i = model.textures.length - 1; i >= 0; i--) {
        if (!usedTextures[i]) {
          model.textures.splice(i, 1);
          model.textureViews.splice(i, 1);
        }
      }
    };
    publicAPI.computePipelineHash = () => {
      let pipelineHash = `pd${model.useRendererMatrix ? "r" : ""}${model.forceZValue ? "z" : ""}`;
      if (model.primitiveType === PrimitiveTypes4.TriangleEdges || model.primitiveType === PrimitiveTypes4.TriangleStripEdges) {
        pipelineHash += "edge";
      } else {
        if (model.vertexInput.hasAttribute(`normalMC`)) {
          pipelineHash += `n`;
        }
        if (model.vertexInput.hasAttribute(`colorVI`)) {
          pipelineHash += `c`;
        }
        if (model.vertexInput.hasAttribute(`tcoord`)) {
          const tcoords = model.vertexInput.getBuffer("tcoord");
          const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
          pipelineHash += `t${numComp}`;
        }
        if (model.textures.length) {
          pipelineHash += `tx${model.textures.length}`;
        }
      }
      if (model._usesCellNormals) {
        pipelineHash += `cn`;
      }
      if (model.SSBO) {
        pipelineHash += `ssbo`;
      }
      const uhash = publicAPI.getHashFromUsage(model.usage);
      pipelineHash += uhash;
      pipelineHash += model.renderEncoder.getPipelineHash();
      model.pipelineHash = pipelineHash;
    };
    publicAPI.updateBuffers = () => {
      if (model.primitiveType !== PrimitiveTypes4.TriangleEdges && model.primitiveType !== PrimitiveTypes4.TriangleStripEdges) {
        publicAPI.updateTextures();
      }
      const actor = model.WebGPUActor.getRenderable();
      const rep = actor.getProperty().getRepresentation();
      model.usage = publicAPI.getUsage(rep, model.primitiveType);
      publicAPI.buildVertexInput();
      const vbo = model.vertexInput.getBuffer("vertexBC");
      publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());
      publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));
      publicAPI.updateUBO();
      if (publicAPI.haveWideLines()) {
        const ppty = actor.getProperty();
        publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2));
      } else {
        publicAPI.setNumberOfInstances(1);
      }
    };
  }
  var DEFAULT_VALUES105 = {
    is2D: false,
    cellArray: null,
    currentInput: null,
    cellOffset: 0,
    primitiveType: 0,
    colorTexture: null,
    renderEncoder: null,
    textures: null
  };
  function extend110(publicAPI, model) {
    let initiaLalues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES105, initiaLalues);
    vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initiaLalues);
    model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;
    model.vertexShaderTemplate = vtkWebGPUPolyDataVS;
    model._tmpMat3 = mat3_exports.identity(new Float64Array(9));
    model._tmpMat4 = mat4_exports.identity(new Float64Array(16));
    model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
      label: "mapperUBO"
    });
    model.UBO.addEntry("BCWCMatrix", "mat4x4<f32>");
    model.UBO.addEntry("BCSCMatrix", "mat4x4<f32>");
    model.UBO.addEntry("MCWCNormals", "mat4x4<f32>");
    model.UBO.addEntry("AmbientColor", "vec4<f32>");
    model.UBO.addEntry("DiffuseColor", "vec4<f32>");
    model.UBO.addEntry("EdgeColor", "vec4<f32>");
    model.UBO.addEntry("SpecularColor", "vec4<f32>");
    model.UBO.addEntry("AmbientIntensity", "f32");
    model.UBO.addEntry("DiffuseIntensity", "f32");
    model.UBO.addEntry("Roughness", "f32");
    model.UBO.addEntry("Metallic", "f32");
    model.UBO.addEntry("Ambient", "f32");
    model.UBO.addEntry("Normal", "f32");
    model.UBO.addEntry("Emission", "f32");
    model.UBO.addEntry("NormalStrength", "f32");
    model.UBO.addEntry("BaseIOR", "f32");
    model.UBO.addEntry("SpecularIntensity", "f32");
    model.UBO.addEntry("LineWidth", "f32");
    model.UBO.addEntry("Opacity", "f32");
    model.UBO.addEntry("ZValue", "f32");
    model.UBO.addEntry("PropID", "u32");
    model.UBO.addEntry("ClipNear", "f32");
    model.UBO.addEntry("ClipFar", "f32");
    model.UBO.addEntry("Time", "u32");
    setGet(publicAPI, model, ["cellArray", "currentInput", "cellOffset", "is2D", "primitiveType", "renderEncoder"]);
    model.textures = [];
    vtkWebGPUCellArrayMapper(publicAPI, model);
  }
  var newInstance109 = newInstance(extend110, "vtkWebGPUCellArrayMapper");
  var vtkWebGPUCellArrayMapper$1 = {
    newInstance: newInstance109,
    extend: extend110
  };

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper.js
  var {
    PrimitiveTypes: PrimitiveTypes5
  } = vtkWebGPUBufferManager$1;
  function vtkWebGPUPolyDataMapper(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUPolyDataMapper");
    publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor");
        if (!model.renderable.getStatic()) {
          model.renderable.update();
        }
        const poly = model.renderable.getInputData();
        model.renderable.mapScalars(poly, 1);
        publicAPI.updateCellArrayMappers(poly);
      }
    };
    publicAPI.updateCellArrayMappers = (poly) => {
      if (!poly) {
        vtkErrorMacro2("No input!");
        return;
      }
      const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];
      const cellMappers = [];
      let cellOffset = 0;
      for (let i = PrimitiveTypes5.Points; i <= PrimitiveTypes5.TriangleStrips; i++) {
        if (prims[i].getNumberOfValues() > 0) {
          if (!model.primitives[i]) {
            model.primitives[i] = publicAPI.createCellArrayMapper();
          }
          const cellMapper = model.primitives[i];
          cellMapper.setCellArray(prims[i]);
          cellMapper.setCurrentInput(poly);
          cellMapper.setCellOffset(cellOffset);
          cellMapper.setPrimitiveType(i);
          cellMapper.setRenderable(model.renderable);
          cellOffset += prims[i].getNumberOfCells();
          cellMappers.push(cellMapper);
        } else {
          model.primitives[i] = null;
        }
      }
      if (model.WebGPUActor.getRenderable().getProperty().getEdgeVisibility()) {
        if (prims[PrimitiveTypes5.Triangles].getNumberOfValues() > 0) {
          const i = PrimitiveTypes5.TriangleEdges;
          if (!model.primitives[i]) {
            model.primitives[i] = publicAPI.createCellArrayMapper();
          }
          const cellMapper = model.primitives[i];
          cellMapper.setCellArray(prims[PrimitiveTypes5.Triangles]);
          cellMapper.setCurrentInput(poly);
          cellMapper.setCellOffset(model.primitives[PrimitiveTypes5.Triangles].getCellOffset());
          cellMapper.setPrimitiveType(i);
          cellMapper.setRenderable(model.renderable);
          cellMappers.push(cellMapper);
        } else {
          model.primitives[PrimitiveTypes5.TriangleEdges] = null;
        }
        if (prims[PrimitiveTypes5.TriangleStrips].getNumberOfValues() > 0) {
          const i = PrimitiveTypes5.TriangleStripEdges;
          if (!model.primitives[i]) {
            model.primitives[i] = publicAPI.createCellArrayMapper();
          }
          const cellMapper = model.primitives[i];
          cellMapper.setCellArray(prims[PrimitiveTypes5.TriangleStrips]);
          cellMapper.setCurrentInput(poly);
          cellMapper.setCellOffset(model.primitives[PrimitiveTypes5.TriangleStrips].getCellOffset());
          cellMapper.setPrimitiveType(i);
          cellMapper.setRenderable(model.renderable);
          cellMappers.push(cellMapper);
        } else {
          model.primitives[PrimitiveTypes5.TriangleStripEdges] = null;
        }
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingChildren(cellMappers);
      publicAPI.removeUnusedNodes();
    };
  }
  var DEFAULT_VALUES106 = {
    primitives: null
  };
  function extend111(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES106, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.primitives = [];
    vtkWebGPUPolyDataMapper(publicAPI, model);
  }
  var newInstance110 = newInstance(extend111, "vtkWebGPUPolyDataMapper");
  registerOverride2("vtkMapper", newInstance110);

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper2D.js
  var {
    PrimitiveTypes: PrimitiveTypes6
  } = vtkWebGPUBufferManager$1;
  function vtkWebGPUPolyDataMapper2D(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUPolyDataMapper2D");
    publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor2D");
        if (!model.renderable.getStatic()) {
          model.renderable.update();
        }
        const poly = model.renderable.getInputData();
        model.renderable.mapScalars(poly, 1);
        publicAPI.updateCellArrayMappers(poly);
      }
    };
    publicAPI.updateCellArrayMappers = (poly) => {
      const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];
      const cellMappers = [];
      let cellOffset = 0;
      for (let i = PrimitiveTypes6.Points; i <= PrimitiveTypes6.Triangles; i++) {
        if (prims[i].getNumberOfValues() > 0) {
          if (!model.primitives[i]) {
            model.primitives[i] = publicAPI.createCellArrayMapper();
          }
          const cellMapper = model.primitives[i];
          cellMapper.setCellArray(prims[i]);
          cellMapper.setCurrentInput(poly);
          cellMapper.setCellOffset(cellOffset);
          cellMapper.setPrimitiveType(i);
          cellMapper.setRenderable(model.renderable);
          cellMapper.setIs2D(true);
          cellOffset += prims[i].getNumberOfCells();
          cellMappers.push(cellMapper);
        } else {
          model.primitives[i] = null;
        }
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingChildren(cellMappers);
      publicAPI.removeUnusedNodes();
    };
  }
  function defaultValues5(initialValues) {
    return {
      primitives: [],
      ...initialValues
    };
  }
  function extend112(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, defaultValues5(initialValues));
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.primitives = [];
    vtkWebGPUPolyDataMapper2D(publicAPI, model);
  }
  var newInstance111 = newInstance(extend112, "vtkWebGPUPolyDataMapper2D");
  registerOverride2("vtkMapper2D", newInstance111);

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/ScalarBarActor.js
  function vtkWebGPUScalarBarActor(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUScalarBarActor");
    publicAPI.buildPass = (prepass) => {
      if (prepass) {
        model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
        model.WebGPURenderWindow = model.WebGPURenderer.getParent();
        if (!model.scalarBarActorHelper.getRenderable()) {
          model.scalarBarActorHelper.setRenderable(model.renderable);
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
        publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
        const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
        model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
      }
    };
  }
  var DEFAULT_VALUES107 = {};
  function extend113(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES107, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();
    vtkWebGPUScalarBarActor(publicAPI, model);
  }
  var newInstance112 = newInstance(extend113, "vtkWebGPUScalarBarActor");
  registerOverride2("vtkScalarBarActor", newInstance112);

  // node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
  function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
    model.classHierarchy.push("vtkWebGPUPixelSpaceCallbackMapper");
    publicAPI.opaquePass = (prepass, renderPass) => {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      const aspectRatio = model.WebGPURenderer.getAspectRatio();
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      const texels = null;
      if (model.renderable.getUseZValues()) ;
      model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
    };
  }
  var DEFAULT_VALUES108 = {};
  function extend114(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES108, initialValues);
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
  }
  var newInstance113 = macro.newInstance(extend114, "vtkWebGPUPixelSpaceCallbackMapper");
  registerOverride2("vtkPixelSpaceCallbackMapper", newInstance113);

  // src/state.js
  var geometryOffsets = {
    inflated: {
      lh: { offsetX: -90, offsetZ: 0, rotateZ: 20 },
      rh: { offsetX: 90, offsetZ: 0, rotateZ: -20 }
    },
    original: {
      lh: { offsetX: -45, offsetZ: 0, rotateZ: 20 },
      rh: { offsetX: 45, offsetZ: 0, rotateZ: -20 }
    },
    pial: {
      lh: { offsetX: -45, offsetZ: 0, rotateZ: 20 },
      rh: { offsetX: 45, offsetZ: 0, rotateZ: -20 }
    },
    white: {
      lh: { offsetX: -45, offsetZ: 0, rotateZ: 20 },
      rh: { offsetX: 45, offsetZ: 0, rotateZ: -20 }
    }
  };
  var state = {
    hemisphereData: {
      lh: {
        meshData: null,
        actor: null,
        mapper: null,
        polyData: null,
        offsetX: -45,
        offsetZ: 0,
        rotateZ: 20
      },
      rh: {
        meshData: null,
        actor: null,
        mapper: null,
        polyData: null,
        offsetX: 45,
        offsetZ: 0,
        rotateZ: -20
      }
    },
    labelsData: null,
    labelNamesData: null,
    currentSelectedLabel: null,
    renderWindow: null,
    renderer: null,
    usePlainEnglishNames: false,
    currentGeometry: "pial",
    // Current geometry type (default)
    geometryOffsets
  };
  function getHemisphereConfig(hemi) {
    return state.hemisphereData[hemi];
  }
  function updateHemisphereData(hemi, data) {
    Object.assign(state.hemisphereData[hemi], data);
  }
  function setRenderer(renderer, renderWindow) {
    state.renderer = renderer;
    state.renderWindow = renderWindow;
  }
  function getRenderer() {
    return state.renderer;
  }
  function getRenderWindow() {
    return state.renderWindow;
  }
  function setLabelsData(data) {
    state.labelsData = data;
  }
  function getLabelsData() {
    return state.labelsData;
  }
  function setLabelNamesData(data) {
    state.labelNamesData = data;
  }
  function getLabelNamesData() {
    return state.labelNamesData;
  }
  function setCurrentSelectedLabel(labelName) {
    state.currentSelectedLabel = labelName;
  }
  function getCurrentSelectedLabel() {
    return state.currentSelectedLabel;
  }
  function togglePlainEnglishNames() {
    state.usePlainEnglishNames = !state.usePlainEnglishNames;
    return state.usePlainEnglishNames;
  }
  function isPlainEnglishNamesEnabled() {
    return state.usePlainEnglishNames;
  }
  function getGeometryOffsets(geometry, hemi) {
    return state.geometryOffsets[geometry]?.[hemi] || state.geometryOffsets.pial[hemi];
  }
  function setCurrentGeometry(geometry) {
    state.currentGeometry = geometry;
    ["lh", "rh"].forEach((hemi) => {
      const offsets = getGeometryOffsets(geometry, hemi);
      Object.assign(state.hemisphereData[hemi], offsets);
    });
  }
  function getCurrentGeometry() {
    return state.currentGeometry;
  }

  // src/geometry.js
  function createPolyDataFromMesh(meshData, offsetX = 0, offsetZ = 0, rotateZ4 = 0) {
    const { vertices, triangles, curvature } = meshData;
    const points = vtkPoints$1.newInstance();
    const verticesFlat = vertices.flat();
    const offsetVertices = new Float32Array(verticesFlat.length);
    const angleRad = rotateZ4 * Math.PI / 180;
    const cosAngle = Math.cos(angleRad);
    const sinAngle = Math.sin(angleRad);
    for (let i = 0; i < verticesFlat.length; i += 3) {
      const x = verticesFlat[i];
      const y = verticesFlat[i + 1];
      const z = verticesFlat[i + 2];
      const rotatedX = x * cosAngle - y * sinAngle;
      const rotatedY = x * sinAngle + y * cosAngle;
      offsetVertices[i] = rotatedX + offsetX;
      offsetVertices[i + 1] = rotatedY;
      offsetVertices[i + 2] = z + offsetZ;
    }
    points.setData(offsetVertices);
    const cellData = [];
    for (let i = 0; i < triangles.length; i++) {
      cellData.push(3);
      cellData.push(...triangles[i]);
    }
    const polys = vtkCellArray$1.newInstance({ values: new Uint32Array(cellData) });
    const polyData = vtkPolyData$1.newInstance();
    polyData.setPoints(points);
    polyData.setPolys(polys);
    if (curvature) {
      const scalars = vtkDataArray$1.newInstance({
        name: "Curvature",
        values: Float32Array.from(curvature),
        numberOfComponents: 1
      });
      polyData.getPointData().setScalars(scalars);
    }
    return polyData;
  }
  function computeLabelCenterAndNormal(meshData, vertices, offsetX, offsetZ, rotateZ4) {
    if (!vertices || vertices.length === 0) {
      return { center: [0, 0, 0], normal: [0, 0, 1] };
    }
    const angleRad = rotateZ4 * Math.PI / 180;
    const cosAngle = Math.cos(angleRad);
    const sinAngle = Math.sin(angleRad);
    let centerX = 0, centerY = 0, centerZ = 0;
    let normalX = 0, normalY = 0, normalZ = 0;
    const labelVertexSet = new Set(vertices);
    vertices.forEach((idx) => {
      const x = meshData.vertices[idx][0];
      const y = meshData.vertices[idx][1];
      const z = meshData.vertices[idx][2];
      const rotatedX = x * cosAngle - y * sinAngle;
      const rotatedY = x * sinAngle + y * cosAngle;
      const finalX = rotatedX + offsetX;
      const finalY = rotatedY;
      const finalZ = z + offsetZ;
      centerX += finalX;
      centerY += finalY;
      centerZ += finalZ;
    });
    const count = vertices.length;
    centerX /= count;
    centerY /= count;
    centerZ /= count;
    let triangleCount = 0;
    meshData.triangles.forEach((triangle) => {
      const v0_in = labelVertexSet.has(triangle[0]);
      const v1_in = labelVertexSet.has(triangle[1]);
      const v2_in = labelVertexSet.has(triangle[2]);
      if (v0_in && v1_in || v1_in && v2_in || v0_in && v2_in) {
        const v0 = meshData.vertices[triangle[0]];
        const v1 = meshData.vertices[triangle[1]];
        const v2 = meshData.vertices[triangle[2]];
        const edge1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];
        const edge2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];
        const nx = edge1[1] * edge2[2] - edge1[2] * edge2[1];
        const ny = edge1[2] * edge2[0] - edge1[0] * edge2[2];
        const nz = edge1[0] * edge2[1] - edge1[1] * edge2[0];
        const rotatedNx = nx * cosAngle - ny * sinAngle;
        const rotatedNy = nx * sinAngle + ny * cosAngle;
        normalX += rotatedNx;
        normalY += rotatedNy;
        normalZ += nz;
        triangleCount++;
      }
    });
    if (triangleCount > 0) {
      const normalLength = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
      if (normalLength > 0) {
        normalX /= normalLength;
        normalY /= normalLength;
        normalZ /= normalLength;
      }
    } else {
      normalX = centerX - offsetX;
      normalY = centerY;
      normalZ = centerZ - offsetZ;
      const normalLength = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
      if (normalLength > 0) {
        normalX /= normalLength;
        normalY /= normalLength;
        normalZ /= normalLength;
      }
    }
    return {
      center: [centerX, centerY, centerZ],
      normal: [normalX, normalY, normalZ]
    };
  }

  // node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/Constants.js
  var ColorSpace = {
    RGB: 0,
    HSV: 1,
    LAB: 2,
    DIVERGING: 3
  };
  var Scale3 = {
    LINEAR: 0,
    LOG10: 1
  };
  var Constants15 = {
    ColorSpace,
    Scale: Scale3
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js
  var {
    ColorSpace: ColorSpace2,
    Scale: Scale4
  } = Constants15;
  var {
    ScalarMappingTarget: ScalarMappingTarget3
  } = vtkScalarsToColors$1;
  var {
    vtkDebugMacro: vtkDebugMacro9,
    vtkErrorMacro: vtkErrorMacro32,
    vtkWarningMacro: vtkWarningMacro9
  } = macro;
  function vtkColorTransferFunctionLabToMsh(lab, msh) {
    const L = lab[0];
    const a = lab[1];
    const b = lab[2];
    const M = Math.sqrt(L * L + a * a + b * b);
    const s = M > 1e-3 ? Math.acos(L / M) : 0;
    const h = s > 1e-3 ? Math.atan2(b, a) : 0;
    msh[0] = M;
    msh[1] = s;
    msh[2] = h;
  }
  function vtkColorTransferFunctionMshToLab(msh, lab) {
    const M = msh[0];
    const s = msh[1];
    const h = msh[2];
    lab[0] = M * Math.cos(s);
    lab[1] = M * Math.sin(s) * Math.cos(h);
    lab[2] = M * Math.sin(s) * Math.sin(h);
  }
  function vtkColorTransferFunctionAdjustHue(msh, unsatM) {
    if (msh[0] >= unsatM - 0.1) {
      return msh[2];
    }
    const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));
    if (msh[2] > -0.3 * Math.PI) {
      return msh[2] + hueSpin;
    }
    return msh[2] - hueSpin;
  }
  function vtkColorTransferFunctionAngleDiff(a1, a2) {
    let adiff = a1 - a2;
    if (adiff < 0) {
      adiff = -adiff;
    }
    while (adiff >= 2 * Math.PI) {
      adiff -= 2 * Math.PI;
    }
    if (adiff > Math.PI) {
      adiff = 2 * Math.PI - adiff;
    }
    return adiff;
  }
  function vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {
    const lab1 = [];
    const lab2 = [];
    rgb2lab(rgb1, lab1);
    rgb2lab(rgb2, lab2);
    const msh1 = [];
    const msh2 = [];
    vtkColorTransferFunctionLabToMsh(lab1, msh1);
    vtkColorTransferFunctionLabToMsh(lab2, msh2);
    let localS = s;
    if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {
      let Mmid = Math.max(msh1[0], msh2[0]);
      Mmid = Math.max(88, Mmid);
      if (s < 0.5) {
        msh2[0] = Mmid;
        msh2[1] = 0;
        msh2[2] = 0;
        localS *= 2;
      } else {
        msh1[0] = Mmid;
        msh1[1] = 0;
        msh1[2] = 0;
        localS = 2 * localS - 1;
      }
    }
    if (msh1[1] < 0.05 && msh2[1] > 0.05) {
      msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);
    } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {
      msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);
    }
    const mshTmp = [];
    mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];
    mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];
    mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];
    const labTmp = [];
    vtkColorTransferFunctionMshToLab(mshTmp, labTmp);
    lab2rgb(labTmp, result);
  }
  function vtkColorTransferFunction(publicAPI, model) {
    model.classHierarchy.push("vtkColorTransferFunction");
    publicAPI.getSize = () => model.nodes.length;
    publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0);
    publicAPI.addRGBPointLong = function(x, r, g, b) {
      let midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
      let sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
      if (midpoint < 0 || midpoint > 1) {
        vtkErrorMacro32("Midpoint outside range [0.0, 1.0]");
        return -1;
      }
      if (sharpness < 0 || sharpness > 1) {
        vtkErrorMacro32("Sharpness outside range [0.0, 1.0]");
        return -1;
      }
      if (!model.allowDuplicateScalars) {
        publicAPI.removePoint(x);
      }
      const node = {
        x,
        r,
        g,
        b,
        midpoint,
        sharpness
      };
      model.nodes.push(node);
      publicAPI.sortAndUpdateRange();
      let i = 0;
      for (; i < model.nodes.length; i++) {
        if (model.nodes[i].x === x) {
          break;
        }
      }
      if (i < model.nodes.length) {
        return i;
      }
      return -1;
    };
    publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0);
    publicAPI.addHSVPointLong = function(x, h, s, v) {
      let midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
      let sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
      const rgb2 = [];
      const hsv = [h, s, v];
      hsv2rgb(hsv, rgb2);
      return publicAPI.addRGBPoint(x, rgb2[0], rgb2[1], rgb2[2], midpoint, sharpness);
    };
    publicAPI.setNodes = (nodes) => {
      if (model.nodes !== nodes) {
        const before = JSON.stringify(model.nodes);
        model.nodes = nodes;
        const after = JSON.stringify(model.nodes);
        if (publicAPI.sortAndUpdateRange() || before !== after) {
          publicAPI.modified();
          return true;
        }
      }
      return false;
    };
    publicAPI.sortAndUpdateRange = () => {
      const before = JSON.stringify(model.nodes);
      model.nodes.sort((a, b) => a.x - b.x);
      const after = JSON.stringify(model.nodes);
      const modifiedInvoked = publicAPI.updateRange();
      if (!modifiedInvoked && before !== after) {
        publicAPI.modified();
        return true;
      }
      return modifiedInvoked;
    };
    publicAPI.updateRange = () => {
      const oldRange = [2];
      oldRange[0] = model.mappingRange[0];
      oldRange[1] = model.mappingRange[1];
      const size = model.nodes.length;
      if (size) {
        model.mappingRange[0] = model.nodes[0].x;
        model.mappingRange[1] = model.nodes[size - 1].x;
      } else {
        model.mappingRange[0] = 0;
        model.mappingRange[1] = 0;
      }
      if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {
        return false;
      }
      publicAPI.modified();
      return true;
    };
    publicAPI.removePoint = (x) => {
      let i = 0;
      for (; i < model.nodes.length; i++) {
        if (model.nodes[i].x === x) {
          break;
        }
      }
      const retVal = i;
      if (i >= model.nodes.length) {
        return -1;
      }
      let modifiedInvoked = false;
      model.nodes.splice(i, 1);
      if (i === 0 || i === model.nodes.length) {
        modifiedInvoked = publicAPI.updateRange();
      }
      if (!modifiedInvoked) {
        publicAPI.modified();
      }
      return retVal;
    };
    publicAPI.movePoint = (oldX, newX) => {
      if (oldX === newX) {
        return;
      }
      publicAPI.removePoint(newX);
      for (let i = 0; i < model.nodes.length; i++) {
        if (model.nodes[i].x === oldX) {
          model.nodes[i].x = newX;
          publicAPI.sortAndUpdateRange();
          break;
        }
      }
    };
    publicAPI.removeAllPoints = () => {
      model.nodes = [];
      publicAPI.sortAndUpdateRange();
    };
    publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {
      publicAPI.sortAndUpdateRange();
      for (let i = 0; i < model.nodes.length; ) {
        if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
          model.nodes.splice(i, 1);
        } else {
          i++;
        }
      }
      publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0);
      publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0);
      publicAPI.modified();
    };
    publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {
      const hsv1 = [h1, s1, v1];
      const hsv2 = [h2, s2, v2];
      const rgb1 = [];
      const rgb2 = [];
      hsv2rgb(hsv1, rgb1);
      hsv2rgb(hsv2, rgb2);
      publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);
    };
    publicAPI.mapValue = (x) => {
      const rgb2 = [];
      publicAPI.getColor(x, rgb2);
      return [Math.floor(255 * rgb2[0] + 0.5), Math.floor(255 * rgb2[1] + 0.5), Math.floor(255 * rgb2[2] + 0.5), 255];
    };
    publicAPI.getColor = (x, rgb2) => {
      if (model.indexedLookup) {
        const numNodes = publicAPI.getSize();
        const idx = publicAPI.getAnnotatedValueIndexInternal(x);
        if (idx < 0 || numNodes === 0) {
          const nanColor = publicAPI.getNanColorByReference();
          rgb2[0] = nanColor[0];
          rgb2[1] = nanColor[1];
          rgb2[2] = nanColor[2];
        } else {
          const nodeVal = [];
          publicAPI.getNodeValue(idx % numNodes, nodeVal);
          rgb2[0] = nodeVal[1];
          rgb2[1] = nodeVal[2];
          rgb2[2] = nodeVal[3];
        }
        return;
      }
      publicAPI.getTable(x, x, 1, rgb2);
    };
    publicAPI.getRedValue = (x) => {
      const rgb2 = [];
      publicAPI.getColor(x, rgb2);
      return rgb2[0];
    };
    publicAPI.getGreenValue = (x) => {
      const rgb2 = [];
      publicAPI.getColor(x, rgb2);
      return rgb2[1];
    };
    publicAPI.getBlueValue = (x) => {
      const rgb2 = [];
      publicAPI.getColor(x, rgb2);
      return rgb2[2];
    };
    publicAPI.logScaleEnabled = () => model.scale === Scale4.LOG10;
    publicAPI.usingLogScale = () => publicAPI.logScaleEnabled() && model.mappingRange[0] > 0;
    publicAPI.getTable = (xStart_, xEnd_, size, table) => {
      const usingLogScale = publicAPI.usingLogScale();
      const xStart = usingLogScale ? Math.log10(Number(xStart_)) : Number(xStart_);
      const xEnd = usingLogScale ? Math.log10(Number(xEnd_)) : Number(xEnd_);
      if (isNan(xStart) || isNan(xEnd)) {
        for (let i = 0; i < size; i++) {
          table[i * 3 + 0] = model.nanColor[0];
          table[i * 3 + 1] = model.nanColor[1];
          table[i * 3 + 2] = model.nanColor[2];
        }
        return;
      }
      let idx = 0;
      const numNodes = model.nodes.length;
      let lastR = 0;
      let lastG = 0;
      let lastB = 0;
      if (numNodes !== 0) {
        lastR = model.nodes[numNodes - 1].r;
        lastG = model.nodes[numNodes - 1].g;
        lastB = model.nodes[numNodes - 1].b;
      }
      let x = 0;
      let x1 = 0;
      let x2 = 0;
      const rgb1 = [0, 0, 0];
      const rgb2 = [0, 0, 0];
      let midpoint = 0;
      let sharpness = 0;
      const tmpVec = [];
      let scaledMappingRange = model.mappingRange;
      if (usingLogScale) {
        scaledMappingRange = [Math.log10(model.mappingRange[0]), Math.log10(model.mappingRange[1])];
      }
      for (let i = 0; i < size; i++) {
        const tidx = 3 * i;
        if (size > 1) {
          x = xStart + i / (size - 1) * (xEnd - xStart);
        } else {
          x = 0.5 * (xStart + xEnd);
        }
        if (model.discretize) {
          const range = scaledMappingRange;
          if (x >= range[0] && x <= range[1]) {
            const numberOfValues = model.numberOfValues;
            const deltaRange = range[1] - range[0];
            if (numberOfValues <= 1) {
              x = range[0] + deltaRange / 2;
            } else {
              const xn = (x - range[0]) / deltaRange;
              const discretizeIndex = floor3(numberOfValues * xn);
              x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;
            }
          }
        }
        while (idx < numNodes && x > model.nodes[idx].x) {
          idx++;
          if (idx < numNodes) {
            x1 = model.nodes[idx - 1].x;
            x2 = model.nodes[idx].x;
            rgb1[0] = model.nodes[idx - 1].r;
            rgb2[0] = model.nodes[idx].r;
            rgb1[1] = model.nodes[idx - 1].g;
            rgb2[1] = model.nodes[idx].g;
            rgb1[2] = model.nodes[idx - 1].b;
            rgb2[2] = model.nodes[idx].b;
            midpoint = model.nodes[idx - 1].midpoint;
            sharpness = model.nodes[idx - 1].sharpness;
            if (midpoint < 1e-5) {
              midpoint = 1e-5;
            }
            if (midpoint > 0.99999) {
              midpoint = 0.99999;
            }
          }
        }
        if (x > scaledMappingRange[1]) {
          table[tidx] = 0;
          table[tidx + 1] = 0;
          table[tidx + 2] = 0;
          if (model.clamping) {
            if (publicAPI.getUseAboveRangeColor()) {
              table[tidx] = model.aboveRangeColor[0];
              table[tidx + 1] = model.aboveRangeColor[1];
              table[tidx + 2] = model.aboveRangeColor[2];
            } else {
              table[tidx] = lastR;
              table[tidx + 1] = lastG;
              table[tidx + 2] = lastB;
            }
          }
        } else if (x < scaledMappingRange[0] || isInf(x) && x < 0) {
          table[tidx] = 0;
          table[tidx + 1] = 0;
          table[tidx + 2] = 0;
          if (model.clamping) {
            if (publicAPI.getUseBelowRangeColor()) {
              table[tidx] = model.belowRangeColor[0];
              table[tidx + 1] = model.belowRangeColor[1];
              table[tidx + 2] = model.belowRangeColor[2];
            } else if (numNodes > 0) {
              table[tidx] = model.nodes[0].r;
              table[tidx + 1] = model.nodes[0].g;
              table[tidx + 2] = model.nodes[0].b;
            }
          }
        } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {
          if (numNodes > 0) {
            table[tidx] = model.nodes[0].r;
            table[tidx + 1] = model.nodes[0].g;
            table[tidx + 2] = model.nodes[0].b;
          } else {
            table[tidx] = 0;
            table[tidx + 1] = 0;
            table[tidx + 2] = 0;
          }
        } else {
          let s = 0;
          s = (x - x1) / (x2 - x1);
          if (s < midpoint) {
            s = 0.5 * s / midpoint;
          } else {
            s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
          }
          if (sharpness > 0.99) {
            if (s < 0.5) {
              table[tidx] = rgb1[0];
              table[tidx + 1] = rgb1[1];
              table[tidx + 2] = rgb1[2];
              continue;
            } else {
              table[tidx] = rgb2[0];
              table[tidx + 1] = rgb2[1];
              table[tidx + 2] = rgb2[2];
              continue;
            }
          }
          if (sharpness < 0.01) {
            if (model.colorSpace === ColorSpace2.RGB) {
              table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];
              table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];
              table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];
            } else if (model.colorSpace === ColorSpace2.HSV) {
              const hsv1 = [];
              const hsv2 = [];
              rgb2hsv(rgb1, hsv1);
              rgb2hsv(rgb2, hsv2);
              if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
                if (hsv1[0] > hsv2[0]) {
                  hsv1[0] -= 1;
                } else {
                  hsv2[0] -= 1;
                }
              }
              const hsvTmp = [];
              hsvTmp[0] = (1 - s) * hsv1[0] + s * hsv2[0];
              if (hsvTmp[0] < 0) {
                hsvTmp[0] += 1;
              }
              hsvTmp[1] = (1 - s) * hsv1[1] + s * hsv2[1];
              hsvTmp[2] = (1 - s) * hsv1[2] + s * hsv2[2];
              hsv2rgb(hsvTmp, tmpVec);
              table[tidx] = tmpVec[0];
              table[tidx + 1] = tmpVec[1];
              table[tidx + 2] = tmpVec[2];
            } else if (model.colorSpace === ColorSpace2.LAB) {
              const lab1 = [];
              const lab2 = [];
              rgb2lab(rgb1, lab1);
              rgb2lab(rgb2, lab2);
              const labTmp = [];
              labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];
              labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];
              labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];
              lab2rgb(labTmp, tmpVec);
              table[tidx] = tmpVec[0];
              table[tidx + 1] = tmpVec[1];
              table[tidx + 2] = tmpVec[2];
            } else if (model.colorSpace === ColorSpace2.DIVERGING) {
              vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
              table[tidx] = tmpVec[0];
              table[tidx + 1] = tmpVec[1];
              table[tidx + 2] = tmpVec[2];
            } else {
              vtkErrorMacro32("ColorSpace set to invalid value.", model.colorSpace);
            }
            continue;
          }
          if (s < 0.5) {
            s = 0.5 * (s * 2) ** (1 + 10 * sharpness);
          } else if (s > 0.5) {
            s = 1 - 0.5 * ((1 - s) * 2) ** (1 + 10 * sharpness);
          }
          const ss = s * s;
          const sss = ss * s;
          const h1 = 2 * sss - 3 * ss + 1;
          const h2 = -2 * sss + 3 * ss;
          const h3 = sss - 2 * ss + s;
          const h4 = sss - ss;
          let slope;
          let t;
          if (model.colorSpace === ColorSpace2.RGB) {
            for (let j = 0; j < 3; j++) {
              slope = rgb2[j] - rgb1[j];
              t = (1 - sharpness) * slope;
              table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;
            }
          } else if (model.colorSpace === ColorSpace2.HSV) {
            const hsv1 = [];
            const hsv2 = [];
            rgb2hsv(rgb1, hsv1);
            rgb2hsv(rgb2, hsv2);
            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
              if (hsv1[0] > hsv2[0]) {
                hsv1[0] -= 1;
              } else {
                hsv2[0] -= 1;
              }
            }
            const hsvTmp = [];
            for (let j = 0; j < 3; j++) {
              slope = hsv2[j] - hsv1[j];
              t = (1 - sharpness) * slope;
              hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;
              if (j === 0 && hsvTmp[j] < 0) {
                hsvTmp[j] += 1;
              }
            }
            hsv2rgb(hsvTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.LAB) {
            const lab1 = [];
            const lab2 = [];
            rgb2lab(rgb1, lab1);
            rgb2lab(rgb2, lab2);
            const labTmp = [];
            for (let j = 0; j < 3; j++) {
              slope = lab2[j] - lab1[j];
              t = (1 - sharpness) * slope;
              labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;
            }
            lab2rgb(labTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.DIVERGING) {
            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else {
            vtkErrorMacro32("ColorSpace set to invalid value.");
          }
          for (let j = 0; j < 3; j++) {
            table[tidx + j] = table[tidx + j] < 0 ? 0 : table[tidx + j];
            table[tidx + j] = table[tidx + j] > 1 ? 1 : table[tidx + j];
          }
        }
      }
    };
    publicAPI.getUint8Table = function(xStart, xEnd, size) {
      let withAlpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {
        return model.table;
      }
      if (model.nodes.length === 0) {
        vtkErrorMacro32("Attempting to lookup a value with no points in the function");
        return model.table;
      }
      const nbChannels = withAlpha ? 4 : 3;
      if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {
        model.table = new Uint8Array(size * nbChannels);
        model.tableSize = size;
        model.tableWithAlpha = withAlpha;
      }
      const tmpTable = [];
      publicAPI.getTable(xStart, xEnd, size, tmpTable);
      for (let i = 0; i < size; i++) {
        model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255 + 0.5);
        model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255 + 0.5);
        model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255 + 0.5);
        if (withAlpha) {
          model.table[i * nbChannels + 3] = 255;
        }
      }
      model.buildTime.modified();
      return model.table;
    };
    publicAPI.buildFunctionFromArray = (array) => {
      publicAPI.removeAllPoints();
      const numComponents = array.getNumberOfComponents();
      for (let i = 0; i < array.getNumberOfTuples(); i++) {
        switch (numComponents) {
          case 3: {
            model.nodes.push({
              x: i,
              r: array.getComponent(i, 0),
              g: array.getComponent(i, 1),
              b: array.getComponent(i, 2),
              midpoint: 0.5,
              sharpness: 0
            });
            break;
          }
          case 4: {
            model.nodes.push({
              x: array.getComponent(i, 0),
              r: array.getComponent(i, 1),
              g: array.getComponent(i, 2),
              b: array.getComponent(i, 3),
              midpoint: 0.5,
              sharpness: 0
            });
            break;
          }
          case 5: {
            model.nodes.push({
              x: i,
              r: array.getComponent(i, 0),
              g: array.getComponent(i, 1),
              b: array.getComponent(i, 2),
              midpoint: array.getComponent(i, 4),
              sharpness: array.getComponent(i, 5)
            });
            break;
          }
          case 6: {
            model.nodes.push({
              x: array.getComponent(i, 0),
              r: array.getComponent(i, 1),
              g: array.getComponent(i, 2),
              b: array.getComponent(i, 3),
              midpoint: array.getComponent(i, 4),
              sharpness: array.getComponent(i, 5)
            });
            break;
          }
        }
      }
      publicAPI.sortAndUpdateRange();
    };
    publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {
      let inc = 0;
      publicAPI.removeAllPoints();
      if (size > 1) {
        inc = (xEnd - xStart) / (size - 1);
      }
      for (let i = 0; i < size; i++) {
        const node = {
          x: xStart + inc * i,
          r: table[i * 3],
          g: table[i * 3 + 1],
          b: table[i * 3 + 2],
          sharpness: 0,
          midpoint: 0.5
        };
        model.nodes.push(node);
      }
      publicAPI.sortAndUpdateRange();
    };
    publicAPI.getNodeValue = (index, val) => {
      if (index < 0 || index >= model.nodes.length) {
        vtkErrorMacro32("Index out of range!");
        return -1;
      }
      val[0] = model.nodes[index].x;
      val[1] = model.nodes[index].r;
      val[2] = model.nodes[index].g;
      val[3] = model.nodes[index].b;
      val[4] = model.nodes[index].midpoint;
      val[5] = model.nodes[index].sharpness;
      return 1;
    };
    publicAPI.setNodeValue = (index, val) => {
      if (index < 0 || index >= model.nodes.length) {
        vtkErrorMacro32("Index out of range!");
        return -1;
      }
      const oldX = model.nodes[index].x;
      model.nodes[index].x = val[0];
      model.nodes[index].r = val[1];
      model.nodes[index].g = val[2];
      model.nodes[index].b = val[3];
      model.nodes[index].midpoint = val[4];
      model.nodes[index].sharpness = val[5];
      if (oldX !== val[0]) {
        publicAPI.sortAndUpdateRange();
      } else {
        publicAPI.modified();
      }
      return 1;
    };
    publicAPI.getNumberOfAvailableColors = () => {
      if (model.indexedLookup && publicAPI.getSize()) {
        return publicAPI.getSize();
      }
      if (model.tableSize) {
        return model.tableSize;
      }
      const nNodes = model.nodes?.length ?? 0;
      return Math.max(4094, nNodes);
    };
    publicAPI.getIndexedColor = (idx, rgba2) => {
      const n = publicAPI.getSize();
      if (n > 0 && idx >= 0) {
        const nodeValue = [];
        publicAPI.getNodeValue(idx % n, nodeValue);
        for (let j = 0; j < 3; ++j) {
          rgba2[j] = nodeValue[j + 1];
        }
        rgba2[3] = 1;
        return;
      }
      const nanColor = publicAPI.getNanColorByReference();
      rgba2[0] = nanColor[0];
      rgba2[1] = nanColor[1];
      rgba2[2] = nanColor[2];
      rgba2[3] = 1;
    };
    publicAPI.fillFromDataPointer = (nb, ptr) => {
      if (nb <= 0 || !ptr) {
        return;
      }
      publicAPI.removeAllPoints();
      for (let i = 0; i < nb; i++) {
        publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);
      }
    };
    publicAPI.setMappingRange = (min4, max4) => {
      const range = [min4, max4];
      const scaledRange = [min4, max4];
      const originalRange = publicAPI.getRange();
      const logScaleEnabled = publicAPI.logScaleEnabled();
      if (originalRange[1] === range[1] && originalRange[0] === range[0]) {
        return;
      }
      if (range[1] === range[0]) {
        vtkErrorMacro32("attempt to set zero width color range");
        return;
      }
      if (logScaleEnabled) {
        if (range[0] <= 0) {
          console.warn("attempt to set log scale color range with non-positive minimum");
        } else {
          scaledRange[0] = Math.log10(range[0]);
          scaledRange[1] = Math.log10(range[1]);
        }
      }
      const scale7 = (scaledRange[1] - scaledRange[0]) / (originalRange[1] - originalRange[0]);
      const shift = scaledRange[0] - originalRange[0] * scale7;
      for (let i = 0; i < model.nodes.length; ++i) {
        model.nodes[i].x = model.nodes[i].x * scale7 + shift;
      }
      model.mappingRange[0] = range[0];
      model.mappingRange[1] = range[1];
      publicAPI.modified();
    };
    publicAPI.adjustRange = (range) => {
      const functionRange = publicAPI.getRange();
      const rgb2 = [];
      if (functionRange[0] < range[0]) {
        publicAPI.getColor(range[0], rgb2);
        publicAPI.addRGBPoint(range[0], rgb2[0], rgb2[1], rgb2[2]);
      } else {
        publicAPI.getColor(functionRange[0], rgb2);
        publicAPI.addRGBPoint(range[0], rgb2[0], rgb2[1], rgb2[2]);
      }
      if (functionRange[1] > range[1]) {
        publicAPI.getColor(range[1], rgb2);
        publicAPI.addRGBPoint(range[1], rgb2[0], rgb2[1], rgb2[2]);
      } else {
        publicAPI.getColor(functionRange[1], rgb2);
        publicAPI.addRGBPoint(range[1], rgb2[0], rgb2[1], rgb2[2]);
      }
      publicAPI.sortAndUpdateRange();
      for (let i = 0; i < model.nodes.length; ) {
        if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
          model.nodes.splice(i, 1);
        } else {
          ++i;
        }
      }
      return 1;
    };
    publicAPI.estimateMinNumberOfSamples = (x1, x2) => {
      const d = publicAPI.findMinimumXDistance();
      return Math.ceil((x2 - x1) / d);
    };
    publicAPI.findMinimumXDistance = () => {
      if (model.nodes.length < 2) {
        return -1;
      }
      let distance3 = Number.MAX_VALUE;
      for (let i = 0; i < model.nodes.length - 1; i++) {
        const currentDist = model.nodes[i + 1].x - model.nodes[i].x;
        if (currentDist < distance3) {
          distance3 = currentDist;
        }
      }
      return distance3;
    };
    publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
      if (publicAPI.getSize() === 0) {
        vtkDebugMacro9("Transfer Function Has No Points!");
        return;
      }
      if (model.indexedLookup) {
        publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);
      } else {
        publicAPI.mapData(input, output, outFormat, inputOffset);
      }
    };
    publicAPI.mapData = (input, output, outFormat, inputOffset) => {
      if (publicAPI.getSize() === 0) {
        vtkWarningMacro9("Transfer Function Has No Points!");
        return;
      }
      const alpha = Math.floor(publicAPI.getAlpha() * 255 + 0.5);
      const length4 = input.getNumberOfTuples();
      const inIncr = input.getNumberOfComponents();
      const outputV = output.getData();
      const inputV = input.getData();
      const rgb2 = [];
      if (outFormat === ScalarMappingTarget3.RGBA) {
        for (let i = 0; i < length4; i++) {
          const x = inputV[i * inIncr + inputOffset];
          publicAPI.getColor(x, rgb2);
          outputV[i * 4] = Math.floor(rgb2[0] * 255 + 0.5);
          outputV[i * 4 + 1] = Math.floor(rgb2[1] * 255 + 0.5);
          outputV[i * 4 + 2] = Math.floor(rgb2[2] * 255 + 0.5);
          outputV[i * 4 + 3] = alpha;
        }
      }
      if (outFormat === ScalarMappingTarget3.RGB) {
        for (let i = 0; i < length4; i++) {
          const x = inputV[i * inIncr + inputOffset];
          publicAPI.getColor(x, rgb2);
          outputV[i * 3] = Math.floor(rgb2[0] * 255 + 0.5);
          outputV[i * 3 + 1] = Math.floor(rgb2[1] * 255 + 0.5);
          outputV[i * 3 + 2] = Math.floor(rgb2[2] * 255 + 0.5);
        }
      }
      if (outFormat === ScalarMappingTarget3.LUMINANCE) {
        for (let i = 0; i < length4; i++) {
          const x = inputV[i * inIncr + inputOffset];
          publicAPI.getColor(x, rgb2);
          outputV[i] = Math.floor(rgb2[0] * 76.5 + rgb2[1] * 150.45 + rgb2[2] * 28.05 + 0.5);
        }
      }
      if (outFormat === ScalarMappingTarget3.LUMINANCE_ALPHA) {
        for (let i = 0; i < length4; i++) {
          const x = inputV[i * inIncr + inputOffset];
          publicAPI.getColor(x, rgb2);
          outputV[i * 2] = Math.floor(rgb2[0] * 76.5 + rgb2[1] * 150.45 + rgb2[2] * 28.05 + 0.5);
          outputV[i * 2 + 1] = alpha;
        }
      }
    };
    publicAPI.applyColorMap = (colorMap) => {
      const oldColorSpace = JSON.stringify(model.colorSpace);
      if (colorMap.ColorSpace) {
        model.colorSpace = ColorSpace2[colorMap.ColorSpace.toUpperCase()];
        if (model.colorSpace === void 0) {
          vtkErrorMacro32(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);
          model.colorSpace = ColorSpace2.RGB;
        }
      }
      let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);
      const oldNanColor = isModified || JSON.stringify(model.nanColor);
      if (colorMap.NanColor) {
        model.nanColor = [].concat(colorMap.NanColor);
        while (model.nanColor.length < 4) {
          model.nanColor.push(1);
        }
      }
      isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);
      const oldNodes = isModified || JSON.stringify(model.nodes);
      if (colorMap.RGBPoints) {
        const size = colorMap.RGBPoints.length;
        model.nodes = [];
        const midpoint = 0.5;
        const sharpness = 0;
        for (let i = 0; i < size; i += 4) {
          model.nodes.push({
            x: colorMap.RGBPoints[i],
            r: colorMap.RGBPoints[i + 1],
            g: colorMap.RGBPoints[i + 2],
            b: colorMap.RGBPoints[i + 3],
            midpoint,
            sharpness
          });
        }
      }
      const modifiedInvoked = publicAPI.sortAndUpdateRange();
      const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));
      if (callModified) publicAPI.modified();
      return modifiedInvoked || callModified;
    };
  }
  var DEFAULT_VALUES109 = {
    clamping: true,
    colorSpace: ColorSpace2.RGB,
    hSVWrap: true,
    scale: Scale4.LINEAR,
    nanColor: null,
    belowRangeColor: null,
    aboveRangeColor: null,
    useAboveRangeColor: false,
    useBelowRangeColor: false,
    allowDuplicateScalars: false,
    table: null,
    tableSize: 0,
    buildTime: null,
    nodes: null,
    discretize: false,
    numberOfValues: 256
  };
  function extend115(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES109, initialValues);
    vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
    model.table = [];
    model.nodes = [];
    model.nanColor = [0.5, 0, 0, 1];
    model.belowRangeColor = [0, 0, 0, 1];
    model.aboveRangeColor = [1, 1, 1, 1];
    model.buildTime = {};
    macro.obj(model.buildTime);
    macro.get(publicAPI, model, ["buildTime", "mappingRange"]);
    macro.setGet(publicAPI, model, ["useAboveRangeColor", "useBelowRangeColor", "discretize", "numberOfValues", {
      type: "enum",
      name: "colorSpace",
      enum: ColorSpace2
    }, {
      type: "enum",
      name: "scale",
      enum: Scale4
    }]);
    macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
    macro.getArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"]);
    vtkColorTransferFunction(publicAPI, model);
  }
  var newInstance114 = macro.newInstance(extend115, "vtkColorTransferFunction");
  var vtkColorTransferFunction$1 = {
    newInstance: newInstance114,
    extend: extend115,
    ...Constants15
  };

  // src/rendering.js
  function createCurvatureLookupTable() {
    const lookupTable = vtkColorTransferFunction$1.newInstance();
    lookupTable.addRGBPoint(-1, 0.3, 0.3, 0.3);
    lookupTable.addRGBPoint(-0.2, 0.5, 0.5, 0.5);
    lookupTable.addRGBPoint(0, 0.7, 0.7, 0.7);
    lookupTable.addRGBPoint(0.2, 0.85, 0.85, 0.85);
    lookupTable.addRGBPoint(1, 0.95, 0.95, 0.95);
    return lookupTable;
  }
  function createLabelHighlightLookupTable() {
    const lookupTable = vtkColorTransferFunction$1.newInstance();
    lookupTable.addRGBPoint(-1, 0.3, 0.3, 0.3);
    lookupTable.addRGBPoint(-0.2, 0.5, 0.5, 0.5);
    lookupTable.addRGBPoint(0, 0.7, 0.7, 0.7);
    lookupTable.addRGBPoint(0.2, 0.85, 0.85, 0.85);
    lookupTable.addRGBPoint(1, 0.95, 0.95, 0.95);
    lookupTable.addRGBPoint(5, 1, 0.5, 0.2);
    lookupTable.addRGBPoint(10, 1, 0.3, 0.1);
    return lookupTable;
  }
  function applyCurvatureColoring(mapper, meshData) {
    if (meshData.curvature) {
      const lookupTable = createCurvatureLookupTable();
      mapper.setLookupTable(lookupTable);
      mapper.setScalarModeToUsePointData();
      mapper.setScalarVisibility(true);
      mapper.setScalarRange(-1, 1);
    }
  }
  function applyLabelHighlightColoring(mapper) {
    const lookupTable = createLabelHighlightLookupTable();
    mapper.setLookupTable(lookupTable);
    mapper.setScalarModeToUsePointData();
    mapper.setScalarVisibility(true);
    mapper.setScalarRange(-1, 10);
  }
  var opacityAnimations = /* @__PURE__ */ new Map();
  function animateOpacity(actor, targetOpacity, duration = 500, onComplete = null, renderCallback = null) {
    if (!actor) return;
    const property = actor.getProperty();
    const startOpacity = property.getOpacity();
    if (Math.abs(startOpacity - targetOpacity) < 1e-3) {
      if (onComplete) onComplete();
      return;
    }
    const existingAnimation = opacityAnimations.get(actor);
    if (existingAnimation) {
      cancelAnimationFrame(existingAnimation.frameId);
    }
    const startTime = Date.now();
    function animate() {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
      const currentOpacity = startOpacity + (targetOpacity - startOpacity) * eased;
      property.setOpacity(currentOpacity);
      if (renderCallback) {
        renderCallback();
      }
      if (progress < 1) {
        const frameId2 = requestAnimationFrame(animate);
        opacityAnimations.set(actor, { frameId: frameId2, startTime });
      } else {
        opacityAnimations.delete(actor);
        if (onComplete) onComplete();
      }
    }
    const frameId = requestAnimationFrame(animate);
    opacityAnimations.set(actor, { frameId, startTime });
  }
  function checkHemisphereOcclusion(cameraPos, targetConfig, oppositeConfig, meshData, labelVertices, offsetX, offsetZ, rotateZ4) {
    if (!oppositeConfig.meshData || !targetConfig.meshData) return false;
    const oppAngleRad = oppositeConfig.rotateZ * Math.PI / 180;
    const oppCosAngle = Math.cos(oppAngleRad);
    const oppSinAngle = Math.sin(oppAngleRad);
    const oppMeshData = oppositeConfig.meshData;
    const oppOffsetX = oppositeConfig.offsetX;
    const oppOffsetZ = oppositeConfig.offsetZ || 0;
    let minOppX = Infinity, maxOppX = -Infinity;
    let minOppY = Infinity, maxOppY = -Infinity;
    let minOppZ = Infinity, maxOppZ = -Infinity;
    const oppSampleSize = Math.min(100, oppMeshData.vertices.length);
    const oppStep = Math.max(1, Math.floor(oppMeshData.vertices.length / oppSampleSize));
    for (let i = 0; i < oppMeshData.vertices.length; i += oppStep) {
      const v = oppMeshData.vertices[i];
      const x = v[0];
      const y = v[1];
      const z = v[2];
      const rotX = x * oppCosAngle - y * oppSinAngle;
      const rotY = x * oppSinAngle + y * oppCosAngle;
      const worldX = rotX + oppOffsetX;
      const worldY = rotY;
      const worldZ = z + oppOffsetZ;
      minOppX = Math.min(minOppX, worldX);
      maxOppX = Math.max(maxOppX, worldX);
      minOppY = Math.min(minOppY, worldY);
      maxOppY = Math.max(maxOppY, worldY);
      minOppZ = Math.min(minOppZ, worldZ);
      maxOppZ = Math.max(maxOppZ, worldZ);
    }
    const oppCenterX = (minOppX + maxOppX) / 2;
    const oppCenterY = (minOppY + maxOppY) / 2;
    const oppCenterZ = (minOppZ + maxOppZ) / 2;
    const distToOpposite = Math.sqrt(
      Math.pow(oppCenterX - cameraPos[0], 2) + Math.pow(oppCenterY - cameraPos[1], 2) + Math.pow(oppCenterZ - cameraPos[2], 2)
    );
    const distToTarget = Math.sqrt(
      Math.pow(offsetX - cameraPos[0], 2) + Math.pow(0 - cameraPos[1], 2) + Math.pow(offsetZ - cameraPos[2], 2)
    );
    if (distToOpposite > distToTarget * 1.3) {
      return false;
    }
    const targetAngleRad = rotateZ4 * Math.PI / 180;
    const targetCosAngle = Math.cos(targetAngleRad);
    const targetSinAngle = Math.sin(targetAngleRad);
    const sampleSize = Math.min(50, Math.max(10, Math.floor(labelVertices.length / 10)));
    const step = Math.max(1, Math.floor(labelVertices.length / sampleSize));
    let occludedCount = 0;
    const threshold = Math.max(2, Math.floor(sampleSize * 0.1));
    const expansion = 15;
    const boxMinX = minOppX - expansion;
    const boxMaxX = maxOppX + expansion;
    const boxMinY = minOppY - expansion;
    const boxMaxY = maxOppY + expansion;
    const boxMinZ = minOppZ - expansion;
    const boxMaxZ = maxOppZ + expansion;
    for (let i = 0; i < labelVertices.length; i += step) {
      const vertexIdx = labelVertices[i];
      const vertex = meshData.vertices[vertexIdx];
      const x = vertex[0];
      const y = vertex[1];
      const z = vertex[2];
      const rotatedX = x * targetCosAngle - y * targetSinAngle;
      const rotatedY = x * targetSinAngle + y * targetCosAngle;
      const vertexWorldX = rotatedX + offsetX;
      const vertexWorldY = rotatedY;
      const vertexWorldZ = z + offsetZ;
      const dirX = vertexWorldX - cameraPos[0];
      const dirY = vertexWorldY - cameraPos[1];
      const dirZ = vertexWorldZ - cameraPos[2];
      const distanceToVertex = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
      if (distanceToVertex < 1) continue;
      const ndirX = dirX / distanceToVertex;
      const ndirY = dirY / distanceToVertex;
      const ndirZ = dirZ / distanceToVertex;
      let tMin = 0;
      let tMax = distanceToVertex * 0.98;
      let intersects2 = true;
      if (Math.abs(ndirX) > 1e-4) {
        const t1 = (boxMinX - cameraPos[0]) / ndirX;
        const t2 = (boxMaxX - cameraPos[0]) / ndirX;
        tMin = Math.max(tMin, Math.min(t1, t2));
        tMax = Math.min(tMax, Math.max(t1, t2));
      } else if (cameraPos[0] < boxMinX || cameraPos[0] > boxMaxX) {
        intersects2 = false;
      }
      if (intersects2 && Math.abs(ndirY) > 1e-4) {
        const t1 = (boxMinY - cameraPos[1]) / ndirY;
        const t2 = (boxMaxY - cameraPos[1]) / ndirY;
        tMin = Math.max(tMin, Math.min(t1, t2));
        tMax = Math.min(tMax, Math.max(t1, t2));
      } else if (intersects2 && (cameraPos[1] < boxMinY || cameraPos[1] > boxMaxY)) {
        intersects2 = false;
      }
      if (intersects2 && Math.abs(ndirZ) > 1e-4) {
        const t1 = (boxMinZ - cameraPos[2]) / ndirZ;
        const t2 = (boxMaxZ - cameraPos[2]) / ndirZ;
        tMin = Math.max(tMin, Math.min(t1, t2));
        tMax = Math.min(tMax, Math.max(t1, t2));
      } else if (intersects2 && (cameraPos[2] < boxMinZ || cameraPos[2] > boxMaxZ)) {
        intersects2 = false;
      }
      if (intersects2 && tMin <= tMax && tMin > 0 && tMin < distanceToVertex * 0.98) {
        occludedCount++;
        if (occludedCount >= threshold) {
          return true;
        }
      }
    }
    return occludedCount >= threshold;
  }
  function adjustHemisphereOpacitySmooth(targetHemi, meshData, labelVertices, offsetX, offsetZ, rotateZ4, getHemisphereConfig2, renderer, renderCallback) {
    if (!renderer) return;
    const camera = renderer.getActiveCamera();
    const cameraPos = camera.getPosition();
    const oppositeHemi = targetHemi === "lh" ? "rh" : "lh";
    const oppositeConfig = getHemisphereConfig2(oppositeHemi);
    const targetConfig = getHemisphereConfig2(targetHemi);
    const isOccluding = checkHemisphereOcclusion(
      cameraPos,
      targetConfig,
      oppositeConfig,
      meshData,
      labelVertices,
      offsetX,
      offsetZ,
      rotateZ4
    );
    ["lh", "rh"].forEach((hemi) => {
      const config = getHemisphereConfig2(hemi);
      if (!config.actor) return;
      const targetOpacity = hemi === targetHemi ? 1 : isOccluding ? 0.2 : 1;
      animateOpacity(config.actor, targetOpacity, 500, null, renderCallback);
    });
  }
  function resetHemisphereOpacitySmooth(hemispheres, getHemisphereConfig2, renderCallback) {
    hemispheres.forEach((hemi) => {
      const config = getHemisphereConfig2(hemi);
      if (!config.actor) return;
      animateOpacity(config.actor, 1, 500, null, renderCallback);
    });
  }
  function setupCameraInteractionListener(getRenderWindow2, getRenderer2, getCurrentSelectedLabel2, getLabelsData2, getHemisphereConfig2) {
    const renderWindow = getRenderWindow2();
    const renderer = getRenderer2();
    if (!renderWindow || !renderer) return;
    const interactor = renderWindow.getInteractor();
    if (!interactor) return;
    if (interactor._occlusionListenerActive) {
      return;
    }
    interactor._occlusionListenerActive = true;
    interactor.onAnimation(() => {
      const currentLabel = getCurrentSelectedLabel2();
      if (!currentLabel) return;
      const labelsData = getLabelsData2();
      if (!labelsData || !labelsData[currentLabel]) return;
      const label = labelsData[currentLabel];
      const targetHemi = label.hemi;
      const vertices = label.vertices;
      const targetConfig = getHemisphereConfig2(targetHemi);
      if (!targetConfig.meshData) return;
      adjustHemisphereOpacitySmooth(
        targetHemi,
        targetConfig.meshData,
        vertices,
        targetConfig.offsetX,
        targetConfig.offsetZ,
        targetConfig.rotateZ,
        getHemisphereConfig2,
        renderer,
        () => renderWindow.render()
      );
    });
  }

  // src/freesurfer.js
  function parseFreeSurferSurface(buffer) {
    const dataView = new DataView(buffer);
    let offset = 0;
    const magic1 = dataView.getUint8(offset++);
    const magic2 = dataView.getUint8(offset++);
    const magic3 = dataView.getUint8(offset++);
    if (magic1 !== 255 || magic2 !== 255 || magic3 !== 254) {
      throw new Error(`Invalid FreeSurfer surface file magic number: ${magic1}, ${magic2}, ${magic3}`);
    }
    let comment = "";
    while (offset < buffer.byteLength) {
      const char = dataView.getUint8(offset++);
      if (char === 10) {
        const nextChar = dataView.getUint8(offset);
        if (nextChar === 10) {
          offset++;
          break;
        }
      }
      comment += String.fromCharCode(char);
    }
    const numVertices = dataView.getInt32(offset, false);
    offset += 4;
    const numFaces = dataView.getInt32(offset, false);
    offset += 4;
    console.log(`FreeSurfer surface: ${numVertices} vertices, ${numFaces} faces`);
    const vertices = [];
    for (let i = 0; i < numVertices; i++) {
      const x = dataView.getFloat32(offset, false);
      offset += 4;
      const y = dataView.getFloat32(offset, false);
      offset += 4;
      const z = dataView.getFloat32(offset, false);
      offset += 4;
      vertices.push([x, y, z]);
    }
    const triangles = [];
    for (let i = 0; i < numFaces; i++) {
      const v0 = dataView.getInt32(offset, false);
      offset += 4;
      const v1 = dataView.getInt32(offset, false);
      offset += 4;
      const v2 = dataView.getInt32(offset, false);
      offset += 4;
      triangles.push([v0, v1, v2]);
    }
    return {
      vertices,
      triangles,
      numVertices,
      numFaces,
      comment
    };
  }
  function parseFreeSurferCurvature(buffer) {
    const dataView = new DataView(buffer);
    let offset = 0;
    const magic1 = dataView.getUint8(offset++);
    const magic2 = dataView.getUint8(offset++);
    const magic3 = dataView.getUint8(offset++);
    if (magic1 !== 255 || magic2 !== 255 || magic3 !== 255) {
      throw new Error(`Invalid FreeSurfer curvature file magic number: ${magic1}, ${magic2}, ${magic3}`);
    }
    const numVertices = dataView.getInt32(offset, false);
    offset += 4;
    const numFaces = dataView.getInt32(offset, false);
    offset += 4;
    const valuesPerVertex = dataView.getInt32(offset, false);
    offset += 4;
    console.log(`FreeSurfer curvature: ${numVertices} vertices, ${valuesPerVertex} values per vertex`);
    const curvature = new Float32Array(numVertices);
    for (let i = 0; i < numVertices; i++) {
      curvature[i] = dataView.getFloat32(offset, false);
      offset += 4;
    }
    return curvature;
  }
  async function loadFreeSurferSurface(url) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to load surface: ${url}`);
    }
    const buffer = await response.arrayBuffer();
    return parseFreeSurferSurface(buffer);
  }
  async function loadFreeSurferCurvature(url) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to load curvature: ${url}`);
    }
    const buffer = await response.arrayBuffer();
    return parseFreeSurferCurvature(buffer);
  }

  // src/loader.js
  async function loadHemisphere(surfaceUrl, curvatureUrl, hemi, offsetX, offsetZ, rotateZ4, renderer) {
    const surface = await loadFreeSurferSurface(surfaceUrl);
    const curvature = await loadFreeSurferCurvature(curvatureUrl);
    const meshData = {
      vertices: surface.vertices,
      triangles: surface.triangles,
      curvature: Array.from(curvature)
    };
    const polyData = createPolyDataFromMesh(meshData, offsetX, offsetZ, rotateZ4);
    const mapper = vtkMapper$1.newInstance();
    mapper.setInputData(polyData);
    applyCurvatureColoring(mapper, meshData);
    const actor = vtkActor$1.newInstance();
    actor.setMapper(mapper);
    renderer.addActor(actor);
    updateHemisphereData(hemi, {
      meshData,
      actor,
      mapper,
      polyData
    });
    return actor;
  }
  async function loadLabels(url) {
    const response = await fetch(url);
    return await response.json();
  }
  async function loadLabelNames(url) {
    try {
      const response = await fetch(url);
      return await response.json();
    } catch (error) {
      console.warn("Could not load label names, using FreeSurfer names only:", error);
      return null;
    }
  }

  // node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js
  var NoOp = (v) => v;
  var EPSILON5 = 1e-6;
  var Transform = class {
    constructor() {
      let useDegree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.matrix = mat4_exports.identity(new Float64Array(16));
      this.tmp = new Float64Array(3);
      this.angleConv = useDegree ? common_exports.toRadian : NoOp;
    }
    rotateFromDirections(originDirection, targetDirection) {
      const src = new Float64Array(3);
      const dst = new Float64Array(3);
      const transf = new Float64Array(16);
      vec3_exports.set(src, originDirection[0], originDirection[1], originDirection[2]);
      vec3_exports.set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
      vec3_exports.normalize(src, src);
      vec3_exports.normalize(dst, dst);
      const cosAlpha = vec3_exports.dot(src, dst);
      if (cosAlpha >= 1) {
        return this;
      }
      vec3_exports.cross(this.tmp, src, dst);
      if (vec3_exports.length(this.tmp) < EPSILON5) {
        vec3_exports.cross(this.tmp, [1, 0, 0], originDirection);
        if (vec3_exports.length(this.tmp) < EPSILON5) {
          vec3_exports.cross(this.tmp, [0, 1, 0], originDirection);
        }
      }
      mat4_exports.fromRotation(transf, Math.acos(cosAlpha), this.tmp);
      mat4_exports.multiply(this.matrix, this.matrix, transf);
      return this;
    }
    rotate(angle2, axis) {
      vec3_exports.set(this.tmp, ...axis);
      vec3_exports.normalize(this.tmp, this.tmp);
      mat4_exports.rotate(this.matrix, this.matrix, this.angleConv(angle2), this.tmp);
      return this;
    }
    rotateX(angle2) {
      mat4_exports.rotateX(this.matrix, this.matrix, this.angleConv(angle2));
      return this;
    }
    rotateY(angle2) {
      mat4_exports.rotateY(this.matrix, this.matrix, this.angleConv(angle2));
      return this;
    }
    rotateZ(angle2) {
      mat4_exports.rotateZ(this.matrix, this.matrix, this.angleConv(angle2));
      return this;
    }
    translate(x, y, z) {
      vec3_exports.set(this.tmp, x, y, z);
      mat4_exports.translate(this.matrix, this.matrix, this.tmp);
      return this;
    }
    scale(sx, sy, sz) {
      vec3_exports.set(this.tmp, sx, sy, sz);
      mat4_exports.scale(this.matrix, this.matrix, this.tmp);
      return this;
    }
    multiply(mat4x4) {
      mat4_exports.multiply(this.matrix, this.matrix, mat4x4);
      return this;
    }
    multiply3x3(mat3x3) {
      mat4_exports.multiply(this.matrix, this.matrix, [mat3x3[0], mat3x3[1], mat3x3[2], 0, mat3x3[3], mat3x3[4], mat3x3[5], 0, mat3x3[6], mat3x3[7], mat3x3[8], 0, 0, 0, 0, 1]);
      return this;
    }
    invert() {
      mat4_exports.invert(this.matrix, this.matrix);
      return this;
    }
    identity() {
      mat4_exports.identity(this.matrix);
      return this;
    }
    //-----------
    apply(typedArray) {
      let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let nbIterations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      if (areMatricesEqual(IDENTITY, this.matrix)) {
        return this;
      }
      const size = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
      for (let i = offset; i < size; i += 3) {
        vec3_exports.set(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
        vec3_exports.transformMat4(this.tmp, this.tmp, this.matrix);
        typedArray[i] = this.tmp[0];
        typedArray[i + 1] = this.tmp[1];
        typedArray[i + 2] = this.tmp[2];
      }
      return this;
    }
    getMatrix() {
      return this.matrix;
    }
    setMatrix(mat4x4) {
      if (!!mat4x4 && mat4x4.length === 16) {
        mat4_exports.copy(this.matrix, mat4x4);
      }
      return this;
    }
  };
  function buildFromDegree() {
    return new Transform(true);
  }
  function buildFromRadian() {
    return new Transform(false);
  }
  var vtkMatrixBuilder = {
    buildFromDegree,
    buildFromRadian
  };

  // node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js
  var {
    vtkErrorMacro: vtkErrorMacro33
  } = macro;
  function offsetCellArray(typedArray, offset) {
    let currentIdx = 0;
    return typedArray.map((value, index) => {
      if (index === currentIdx) {
        currentIdx += value + 1;
        return value;
      }
      return value + offset;
    });
  }
  function appendCellData(dest, src, ptOffset, cellOffset) {
    dest.set(offsetCellArray(src, ptOffset), cellOffset);
  }
  function vtkAppendPolyData(publicAPI, model) {
    model.classHierarchy.push("vtkAppendPolyData");
    publicAPI.requestData = (inData, outData) => {
      const numberOfInputs = publicAPI.getNumberOfInputPorts();
      if (!numberOfInputs) {
        vtkErrorMacro33("No input specified.");
        return;
      }
      if (numberOfInputs === 1) {
        outData[0] = inData[0];
        return;
      }
      const output = outData[0] && inData[0] !== outData[0] ? outData[0].initialize() : vtkPolyData$1.newInstance();
      let numPts = 0;
      let pointType = 0;
      let ttype = 1;
      let firstType = 1;
      let numVerts = 0;
      let numLines = 0;
      let numStrips = 0;
      let numPolys = 0;
      let hasPtNormals = true;
      let hasPtTCoords = true;
      let hasPtScalars = true;
      for (let i = 0; i < numberOfInputs; i++) {
        const ds = inData[i];
        if (!ds) {
          continue;
        }
        const dsNumPts = ds.getPoints().getNumberOfPoints();
        numPts += dsNumPts;
        numVerts += ds.getVerts().getNumberOfValues();
        numLines += ds.getLines().getNumberOfValues();
        numStrips += ds.getStrips().getNumberOfValues();
        numPolys += ds.getPolys().getNumberOfValues();
        if (dsNumPts) {
          if (firstType) {
            firstType = 0;
            pointType = ds.getPoints().getDataType();
          }
          ttype = ds.getPoints().getDataType();
          pointType = pointType > ttype ? pointType : ttype;
        }
        const ptD = ds.getPointData();
        if (ptD) {
          hasPtNormals = hasPtNormals && ptD.getNormals() !== null;
          hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;
          hasPtScalars = hasPtScalars && ptD.getScalars() !== null;
        } else {
          hasPtNormals = false;
          hasPtTCoords = false;
          hasPtScalars = false;
        }
      }
      if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {
        pointType = VtkDataTypes.FLOAT;
      } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {
        pointType = VtkDataTypes.DOUBLE;
      }
      const points = vtkPoints$1.newInstance({
        dataType: pointType
      });
      points.setNumberOfPoints(numPts);
      const pointData = points.getData();
      const vertData = new Uint32Array(numVerts);
      const lineData = new Uint32Array(numLines);
      const stripData = new Uint32Array(numStrips);
      const polyData = new Uint32Array(numPolys);
      let newPtNormals = null;
      let newPtTCoords = null;
      let newPtScalars = null;
      const lds = inData[numberOfInputs - 1];
      if (hasPtNormals) {
        const dsNormals = lds.getPointData().getNormals();
        newPtNormals = vtkDataArray$1.newInstance({
          numberOfComponents: 3,
          numberOfTuples: numPts,
          size: 3 * numPts,
          dataType: dsNormals.getDataType(),
          name: dsNormals.getName()
        });
      }
      if (hasPtTCoords) {
        const dsTCoords = lds.getPointData().getTCoords();
        newPtTCoords = vtkDataArray$1.newInstance({
          numberOfComponents: 2,
          numberOfTuples: numPts,
          size: 2 * numPts,
          dataType: dsTCoords.getDataType(),
          name: dsTCoords.getName()
        });
      }
      if (hasPtScalars) {
        const dsScalars = lds.getPointData().getScalars();
        newPtScalars = vtkDataArray$1.newInstance({
          numberOfComponents: dsScalars.getNumberOfComponents(),
          numberOfTuples: numPts,
          size: numPts * dsScalars.getNumberOfComponents(),
          dataType: dsScalars.getDataType(),
          name: dsScalars.getName()
        });
      }
      numPts = 0;
      numVerts = 0;
      numLines = 0;
      numStrips = 0;
      numPolys = 0;
      for (let i = 0; i < numberOfInputs; i++) {
        const ds = inData[i];
        pointData.set(ds.getPoints().getData(), numPts * 3);
        appendCellData(vertData, ds.getVerts().getData(), numPts, numVerts);
        numVerts += ds.getVerts().getNumberOfValues();
        appendCellData(lineData, ds.getLines().getData(), numPts, numLines);
        numLines += ds.getLines().getNumberOfValues();
        appendCellData(stripData, ds.getStrips().getData(), numPts, numStrips);
        numStrips += ds.getStrips().getNumberOfValues();
        appendCellData(polyData, ds.getPolys().getData(), numPts, numPolys);
        numPolys += ds.getPolys().getNumberOfValues();
        const dsPD = ds.getPointData();
        if (hasPtNormals) {
          const ptNorms = dsPD.getNormals();
          newPtNormals.getData().set(ptNorms.getData(), numPts * 3);
        }
        if (hasPtTCoords) {
          const ptTCoords = dsPD.getTCoords();
          newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);
        }
        if (hasPtScalars) {
          const ptScalars = dsPD.getScalars();
          newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());
        }
        numPts += ds.getPoints().getNumberOfPoints();
      }
      output.setPoints(points);
      output.getVerts().setData(vertData);
      output.getLines().setData(lineData);
      output.getStrips().setData(stripData);
      output.getPolys().setData(polyData);
      if (newPtNormals) {
        output.getPointData().setNormals(newPtNormals);
      }
      if (newPtTCoords) {
        output.getPointData().setTCoords(newPtTCoords);
      }
      if (newPtScalars) {
        output.getPointData().setScalars(newPtScalars);
      }
      outData[0] = output;
    };
  }
  var DEFAULT_VALUES110 = {
    outputPointsPrecision: DesiredOutputPrecision.DEFAULT
  };
  function extend116(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES110, initialValues);
    macro.setGet(publicAPI, model, ["outputPointsPrecision"]);
    macro.obj(publicAPI, model);
    macro.algo(publicAPI, model, 1, 1);
    vtkAppendPolyData(publicAPI, model);
  }
  var newInstance115 = macro.newInstance(extend116, "vtkAppendPolyData");
  var vtkAppendPolyData$1 = {
    newInstance: newInstance115,
    extend: extend116
  };

  // node_modules/@kitware/vtk.js/Filters/Sources/ConeSource.js
  function vtkConeSource(publicAPI, model) {
    model.classHierarchy.push("vtkConeSource");
    publicAPI.requestData = (inData, outData) => {
      const angle2 = 2 * Math.PI / model.resolution;
      const xbot = -model.height / 2;
      const numberOfPoints = model.resolution + 1;
      const cellArraySize = 4 * model.resolution + 1 + model.resolution;
      let pointIdx = 0;
      const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
      let cellLocation = 0;
      const polys = new Uint32Array(cellArraySize);
      points[0] = model.height / 2;
      points[1] = 0;
      points[2] = 0;
      if (model.capping) {
        polys[cellLocation++] = model.resolution;
      }
      for (let i = 0; i < model.resolution; i++) {
        pointIdx++;
        points[pointIdx * 3 + 0] = xbot;
        points[pointIdx * 3 + 1] = model.radius * Math.cos(i * angle2);
        points[pointIdx * 3 + 2] = model.radius * Math.sin(i * angle2);
        if (model.capping) {
          polys[model.resolution - cellLocation++ + 1] = pointIdx;
        }
      }
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 3;
        polys[cellLocation++] = 0;
        polys[cellLocation++] = i + 1;
        polys[cellLocation++] = i + 2 > model.resolution ? 1 : i + 2;
      }
      vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([1, 0, 0], model.direction).apply(points);
      const dataset = outData[0]?.initialize() || vtkPolyData$1.newInstance();
      dataset.getPoints().setData(points, 3);
      dataset.getPolys().setData(polys, 1);
      outData[0] = dataset;
    };
  }
  var DEFAULT_VALUES111 = {
    height: 1,
    radius: 0.5,
    resolution: 6,
    center: [0, 0, 0],
    direction: [1, 0, 0],
    capping: true,
    pointType: "Float64Array"
  };
  function extend117(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES111, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["height", "radius", "resolution", "capping"]);
    macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
    macro.algo(publicAPI, model, 0, 1);
    vtkConeSource(publicAPI, model);
  }
  var newInstance116 = macro.newInstance(extend117, "vtkConeSource");
  var vtkConeSource$1 = {
    newInstance: newInstance116,
    extend: extend117
  };

  // node_modules/@kitware/vtk.js/Filters/Sources/CylinderSource.js
  function vtkCylinderSource(publicAPI, model) {
    model.classHierarchy.push("vtkCylinderSource");
    publicAPI.requestData = (inData, outData) => {
      const angle2 = 2 * Math.PI / model.resolution;
      let numberOfPoints = 2 * model.resolution;
      let numberOfPolys = 5 * model.resolution;
      if (model.capping) {
        numberOfPoints = 4 * model.resolution;
        numberOfPolys = 7 * model.resolution + 2;
      }
      const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
      let cellLocation = 0;
      const polys = new Uint32Array(numberOfPolys);
      const normalsData = new Float32Array(numberOfPoints * 3);
      const normals = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: normalsData,
        name: "Normals"
      });
      const tcData = new Float32Array(numberOfPoints * 2);
      const tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcData,
        name: "TCoords"
      });
      const nbot = [0, 0, 0];
      const ntop = [0, 0, 0];
      const xbot = [0, 0, 0];
      const xtop = [0, 0, 0];
      const tcbot = [0, 0];
      const tctop = [0, 0];
      const otherRadius = model.otherRadius == null ? model.radius : model.otherRadius;
      for (let i = 0; i < model.resolution; i++) {
        nbot[0] = Math.cos(i * angle2 + model.initAngle);
        ntop[0] = nbot[0];
        xbot[0] = model.radius * nbot[0] + model.center[0];
        xtop[0] = xbot[0];
        tcbot[0] = Math.abs(2 * i / model.resolution - 1);
        tctop[0] = tcbot[0];
        xbot[1] = 0.5 * model.height + model.center[1];
        xtop[1] = -0.5 * model.height + model.center[1];
        tcbot[1] = 0;
        tctop[1] = 1;
        nbot[2] = -Math.sin(i * angle2 + model.initAngle);
        ntop[2] = nbot[2];
        xbot[2] = otherRadius * nbot[2] + model.center[2];
        xtop[2] = xbot[2];
        const pointIdx = 2 * i;
        for (let j = 0; j < 3; j++) {
          normalsData[pointIdx * 3 + j] = nbot[j];
          normalsData[(pointIdx + 1) * 3 + j] = ntop[j];
          points[pointIdx * 3 + j] = xbot[j];
          points[(pointIdx + 1) * 3 + j] = xtop[j];
          if (j < 2) {
            tcData[pointIdx * 2 + j] = tcbot[j];
            tcData[(pointIdx + 1) * 2 + j] = tctop[j];
          }
        }
      }
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 4;
        polys[cellLocation++] = 2 * i;
        polys[cellLocation++] = 2 * i + 1;
        const pt = (2 * i + 3) % (2 * model.resolution);
        polys[cellLocation++] = pt;
        polys[cellLocation++] = pt - 1;
      }
      if (model.capping) {
        for (let i = 0; i < model.resolution; i++) {
          xbot[0] = model.radius * Math.cos(i * angle2 + model.initAngle);
          xtop[0] = xbot[0];
          tcbot[0] = xbot[0];
          tctop[0] = xbot[0];
          xbot[0] += model.center[0];
          xtop[0] += model.center[0];
          nbot[1] = 1;
          ntop[1] = -1;
          xbot[1] = 0.5 * model.height + model.center[1];
          xtop[1] = -0.5 * model.height + model.center[1];
          xbot[2] = -otherRadius * Math.sin(i * angle2 + model.initAngle);
          xtop[2] = xbot[2];
          tcbot[1] = xbot[2];
          tctop[1] = xbot[2];
          xbot[2] += model.center[2];
          xtop[2] += model.center[2];
          const botIdx = 2 * model.resolution + i;
          const topIdx = 3 * model.resolution + model.resolution - i - 1;
          for (let j = 0; j < 3; j++) {
            normalsData[3 * botIdx + j] = nbot[j];
            normalsData[3 * topIdx + j] = ntop[j];
            points[3 * botIdx + j] = xbot[j];
            points[3 * topIdx + j] = xtop[j];
            if (j < 2) {
              tcData[2 * botIdx + j] = tcbot[j];
              tcData[2 * topIdx + j] = tctop[j];
            }
          }
        }
        polys[cellLocation++] = model.resolution;
        for (let i = 0; i < model.resolution; i++) {
          polys[cellLocation++] = 2 * model.resolution + i;
        }
        polys[cellLocation++] = model.resolution;
        for (let i = 0; i < model.resolution; i++) {
          polys[cellLocation++] = 3 * model.resolution + i;
        }
      }
      vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([0, 1, 0], model.direction).translate(...model.center.map((c) => c * -1)).apply(points);
      const dataset = outData[0]?.initialize() || vtkPolyData$1.newInstance();
      dataset.getPoints().setData(points, 3);
      dataset.getPolys().setData(polys, 1);
      dataset.getPointData().setNormals(normals);
      dataset.getPointData().setTCoords(tcoords);
      outData[0] = dataset;
    };
  }
  var DEFAULT_VALUES112 = {
    height: 1,
    initAngle: 0,
    radius: 1,
    resolution: 6,
    center: [0, 0, 0],
    direction: [0, 1, 0],
    capping: true,
    pointType: "Float64Array"
  };
  function extend118(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES112, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["height", "initAngle", "otherRadius", "radius", "resolution", "capping"]);
    macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
    macro.algo(publicAPI, model, 0, 1);
    vtkCylinderSource(publicAPI, model);
  }
  var newInstance117 = macro.newInstance(extend118, "vtkCylinderSource");
  var vtkCylinderSource$1 = {
    newInstance: newInstance117,
    extend: extend118
  };

  // node_modules/@kitware/vtk.js/Filters/Sources/ArrowSource.js
  function vtkArrowSource(publicAPI, model) {
    model.classHierarchy.push("vtkArrowSource");
    publicAPI.requestData = (inData, outData) => {
      const cylinder = vtkCylinderSource$1.newInstance({
        capping: true
      });
      cylinder.setResolution(model.shaftResolution);
      cylinder.setRadius(model.shaftRadius);
      cylinder.setHeight(1 - model.tipLength);
      cylinder.setCenter(0, (1 - model.tipLength) * 0.5, 0);
      const cylinderPD = cylinder.getOutputData();
      const cylinderPts = cylinderPD.getPoints().getData();
      const cylinderNormals = cylinderPD.getPointData().getNormals().getData();
      vtkMatrixBuilder.buildFromDegree().rotateZ(-90).apply(cylinderPts).apply(cylinderNormals);
      const cone = vtkConeSource$1.newInstance();
      cone.setResolution(model.tipResolution);
      cone.setHeight(model.tipLength);
      cone.setRadius(model.tipRadius);
      const conePD = cone.getOutputData();
      const conePts = conePD.getPoints().getData();
      vtkMatrixBuilder.buildFromRadian().translate(1 - model.tipLength * 0.5, 0, 0).apply(conePts);
      const append = vtkAppendPolyData$1.newInstance();
      append.setInputData(cylinderPD);
      append.addInputData(conePD);
      const appendPD = append.getOutputData();
      const appendPts = appendPD.getPoints().getData();
      vtkMatrixBuilder.buildFromRadian().translate(-0.5 + model.tipLength * 0.5, 0, 0).apply(appendPts);
      if (model.invert) {
        vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(-1, -1, -1).apply(appendPts);
        outData[0] = appendPD;
      } else {
        vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(1, 1, 1).apply(appendPts);
        outData[0] = append.getOutputData();
      }
    };
  }
  var DEFAULT_VALUES113 = {
    tipResolution: 6,
    tipRadius: 0.1,
    tipLength: 0.35,
    shaftResolution: 6,
    shaftRadius: 0.03,
    invert: false,
    direction: [1, 0, 0],
    pointType: "Float64Array"
  };
  function extend119(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES113, initialValues);
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ["tipResolution", "tipRadius", "tipLength", "shaftResolution", "shaftRadius", "invert"]);
    macro.setGetArray(publicAPI, model, ["direction"], 3);
    macro.algo(publicAPI, model, 0, 1);
    vtkArrowSource(publicAPI, model);
  }
  var newInstance118 = macro.newInstance(extend119, "vtkArrowSource");
  var vtkArrowSource$1 = {
    newInstance: newInstance118,
    extend: extend119
  };

  // node_modules/@kitware/vtk.js/Rendering/Core/AxesActor.js
  function centerDataSet(ds) {
    const bounds = ds.getPoints().getBounds();
    const center = [-(bounds[0] + bounds[1]) * 0.5, -(bounds[2] + bounds[3]) * 0.5, -(bounds[4] + bounds[5]) * 0.5];
    vtkMatrixBuilder.buildFromDegree().translate(...center).apply(ds.getPoints().getData());
  }
  function shiftDataset(ds, axis) {
    let invert4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const bounds = ds.getPoints().getBounds();
    const center = [0, 0, 0];
    if (invert4) {
      center[axis] = -bounds[axis * 2 + 1];
    } else {
      center[axis] = -bounds[axis * 2];
    }
    vtkMatrixBuilder.buildFromDegree().translate(...center).apply(ds.getPoints().getData());
  }
  function addColor(ds, r, g, b) {
    const size = ds.getPoints().getData().length;
    const rgbArray = new Uint8ClampedArray(size);
    let offset = 0;
    while (offset < size) {
      rgbArray[offset++] = r;
      rgbArray[offset++] = g;
      rgbArray[offset++] = b;
    }
    ds.getPointData().setScalars(vtkDataArray$1.newInstance({
      name: "color",
      numberOfComponents: 3,
      values: rgbArray
    }));
  }
  function vtkAxesActor(publicAPI, model) {
    model.classHierarchy.push("vtkAxesActor");
    const _mapper = vtkMapper$1.newInstance();
    publicAPI.setMapper(_mapper);
    publicAPI.update = () => {
      let currentConfig = {
        ...model.config,
        ...model.xConfig
      };
      const xAxis = vtkArrowSource$1.newInstance({
        direction: [1, 0, 0],
        ...currentConfig
      }).getOutputData();
      if (model.config.recenter) {
        centerDataSet(xAxis);
      } else {
        shiftDataset(xAxis, 0, currentConfig.invert);
      }
      addColor(xAxis, ...currentConfig.color);
      currentConfig = {
        ...model.config,
        ...model.yConfig
      };
      const yAxis = vtkArrowSource$1.newInstance({
        direction: [0, 1, 0],
        ...currentConfig
      }).getOutputData();
      if (model.config.recenter) {
        centerDataSet(yAxis);
      } else {
        shiftDataset(yAxis, 1, currentConfig.invert);
      }
      addColor(yAxis, ...currentConfig.color);
      currentConfig = {
        ...model.config,
        ...model.zConfig
      };
      const zAxis = vtkArrowSource$1.newInstance({
        direction: [0, 0, 1],
        ...currentConfig
      }).getOutputData();
      if (model.config.recenter) {
        centerDataSet(zAxis);
      } else {
        shiftDataset(zAxis, 2, currentConfig.invert);
      }
      addColor(zAxis, ...currentConfig.color);
      const source = vtkAppendPolyData$1.newInstance();
      source.setInputData(xAxis);
      source.addInputData(yAxis);
      source.addInputData(zAxis);
      _mapper.setInputConnection(source.getOutputPort());
    };
    publicAPI.update();
    const _debouncedUpdate = macro.debounce(publicAPI.update, 0);
    publicAPI.setXAxisColor = (color2) => publicAPI.setXConfig({
      ...publicAPI.getXConfig(),
      color: color2
    });
    publicAPI.setYAxisColor = (color2) => publicAPI.setYConfig({
      ...publicAPI.getYConfig(),
      color: color2
    });
    publicAPI.setZAxisColor = (color2) => publicAPI.setZConfig({
      ...publicAPI.getZConfig(),
      color: color2
    });
    publicAPI.getXAxisColor = () => model.getXConfig().color;
    publicAPI.getYAxisColor = () => model.getYConfig().color;
    publicAPI.getZAxisColor = () => model.getZConfig().color;
    model._onConfigChanged = _debouncedUpdate;
    model._onXConfigChanged = _debouncedUpdate;
    model._onYConfigChanged = _debouncedUpdate;
    model._onZConfigChanged = _debouncedUpdate;
  }
  function defaultValues6(initialValues) {
    return {
      config: {
        recenter: true,
        tipResolution: 60,
        tipRadius: 0.1,
        tipLength: 0.2,
        shaftResolution: 60,
        shaftRadius: 0.03,
        invert: false,
        ...initialValues?.config
      },
      xConfig: {
        color: [255, 0, 0],
        invert: false,
        ...initialValues?.xConfig
      },
      yConfig: {
        color: [255, 255, 0],
        invert: false,
        ...initialValues?.yConfig
      },
      zConfig: {
        color: [0, 128, 0],
        invert: false,
        ...initialValues?.zConfig
      }
    };
  }
  function extend120(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    vtkActor$1.extend(publicAPI, model, defaultValues6(initialValues));
    macro.setGet(publicAPI, model, ["config", "xConfig", "yConfig", "zConfig"]);
    vtkAxesActor(publicAPI, model);
  }
  var newInstance119 = macro.newInstance(extend120, "vtkAxesActor");
  var vtkAxesActor$1 = {
    newInstance: newInstance119,
    extend: extend120
  };

  // node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget/Constants.js
  var Corners = {
    TOP_LEFT: "TOP_LEFT",
    TOP_RIGHT: "TOP_RIGHT",
    BOTTOM_LEFT: "BOTTOM_LEFT",
    BOTTOM_RIGHT: "BOTTOM_RIGHT"
  };
  var Constants16 = {
    Corners
  };

  // node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget.js
  var {
    vtkErrorMacro: vtkErrorMacro34
  } = macro;
  var {
    Corners: Corners2
  } = Constants16;
  function vtkOrientationMarkerWidget(publicAPI, model) {
    model.classHierarchy.push("vtkOrientationMarkerWidget");
    const superClass = {
      ...publicAPI
    };
    const previousCameraInput = [];
    const selfRenderer = vtkRenderer$1.newInstance();
    const resizeObserver = new ResizeObserver((entries) => {
      publicAPI.updateViewport();
    });
    let onCameraChangedSub = null;
    let onCameraModifiedSub = null;
    let onAnimationSub = null;
    let onEndAnimationSub = null;
    let selfSubscription = null;
    function onCameraModified() {
      if (!model._interactor.isAnimating()) {
        publicAPI.updateMarkerOrientation();
      }
    }
    model._onParentRendererChanged = () => publicAPI.updateViewport();
    publicAPI.computeViewport = () => {
      const parentRen = model.parentRenderer || model._interactor.getCurrentRenderer();
      const [xMin, yMin, xMax, yMax] = parentRen.getViewport();
      const view = model._interactor.getView();
      const canvasSize = view.getSize();
      const [viewXSize, viewYSize] = view.getViewportSize(parentRen);
      const minViewSize = Math.min(viewXSize, viewYSize);
      let pixelSize = model.viewportSize * minViewSize;
      pixelSize = Math.max(Math.min(model.minPixelSize, minViewSize), Math.min(model.maxPixelSize, pixelSize));
      const xFrac = pixelSize / canvasSize[0];
      const yFrac = pixelSize / canvasSize[1];
      switch (model.viewportCorner) {
        case Corners2.TOP_LEFT:
          return [xMin, yMax - yFrac, xMin + xFrac, yMax];
        case Corners2.TOP_RIGHT:
          return [xMax - xFrac, yMax - yFrac, xMax, yMax];
        case Corners2.BOTTOM_LEFT:
          return [xMin, yMin, xMin + xFrac, yMin + yFrac];
        case Corners2.BOTTOM_RIGHT:
          return [xMax - xFrac, yMin, xMax, yMin + yFrac];
        default:
          vtkErrorMacro34("Invalid widget corner");
          return null;
      }
    };
    publicAPI.updateViewport = () => {
      if (model.enabled) {
        selfRenderer.setViewport(...publicAPI.computeViewport());
        model._interactor.render();
      }
    };
    publicAPI.updateMarkerOrientation = () => {
      const ren = model.parentRenderer || model._interactor.getCurrentRenderer();
      const currentCamera = ren.getActiveCamera();
      if (!currentCamera) {
        return;
      }
      const position = currentCamera.getReferenceByName("position");
      const focalPoint = currentCamera.getReferenceByName("focalPoint");
      const viewUp = currentCamera.getReferenceByName("viewUp");
      if (previousCameraInput[0] !== position[0] || previousCameraInput[1] !== position[1] || previousCameraInput[2] !== position[2] || previousCameraInput[3] !== focalPoint[0] || previousCameraInput[4] !== focalPoint[1] || previousCameraInput[5] !== focalPoint[2] || previousCameraInput[6] !== viewUp[0] || previousCameraInput[7] !== viewUp[1] || previousCameraInput[8] !== viewUp[2]) {
        previousCameraInput[0] = position[0];
        previousCameraInput[1] = position[1];
        previousCameraInput[2] = position[2];
        previousCameraInput[3] = focalPoint[0];
        previousCameraInput[4] = focalPoint[1];
        previousCameraInput[5] = focalPoint[2];
        previousCameraInput[6] = viewUp[0];
        previousCameraInput[7] = viewUp[1];
        previousCameraInput[8] = viewUp[2];
        const activeCamera = selfRenderer.getActiveCamera();
        activeCamera.setPosition(position[0], position[1], position[2]);
        activeCamera.setFocalPoint(focalPoint[0], focalPoint[1], focalPoint[2]);
        activeCamera.setViewUp(viewUp[0], viewUp[1], viewUp[2]);
        selfRenderer.resetCamera();
      }
    };
    publicAPI.setEnabled = (enabling) => {
      if (enabling) {
        if (model.enabled) {
          return;
        }
        if (!model.actor) {
          vtkErrorMacro34("Must set actor before enabling orientation marker.");
          return;
        }
        if (!model._interactor) {
          vtkErrorMacro34("Must set interactor before enabling orientation marker.");
          return;
        }
        const ren = model.parentRenderer || model._interactor.getCurrentRenderer();
        const renderWindow = ren.getRenderWindow();
        renderWindow.addRenderer(selfRenderer);
        if (renderWindow.getNumberOfLayers() < 2) {
          renderWindow.setNumberOfLayers(2);
        }
        selfRenderer.setLayer(renderWindow.getNumberOfLayers() - 1);
        selfRenderer.setInteractive(model.interactiveRenderer);
        selfRenderer.addViewProp(model.actor);
        model.actor.setVisibility(true);
        onCameraChangedSub = ren.onEvent((event2) => {
          if (event2.type === "ActiveCameraEvent") {
            if (onCameraModifiedSub) {
              onCameraModifiedSub.unsubscribe();
            }
            onCameraModifiedSub = event2.camera.onModified(onCameraModified);
          }
        });
        onCameraModifiedSub = ren.getActiveCamera().onModified(onCameraModified);
        onAnimationSub = model._interactor.onAnimation(publicAPI.updateMarkerOrientation);
        onEndAnimationSub = model._interactor.onEndAnimation(publicAPI.updateMarkerOrientation);
        resizeObserver.observe(model._interactor.getView().getCanvas());
        publicAPI.updateViewport();
        publicAPI.updateMarkerOrientation();
        model.enabled = true;
      } else {
        if (!model.enabled) {
          return;
        }
        model.enabled = false;
        resizeObserver.disconnect();
        onCameraChangedSub.unsubscribe();
        onCameraChangedSub = null;
        onCameraModifiedSub.unsubscribe();
        onCameraModifiedSub = null;
        onAnimationSub.unsubscribe();
        onAnimationSub = null;
        onEndAnimationSub.unsubscribe();
        onEndAnimationSub = null;
        model.actor.setVisibility(false);
        selfRenderer.removeViewProp(model.actor);
        const renderWindow = model._interactor?.findPokedRenderer()?.getRenderWindow();
        if (renderWindow) {
          renderWindow.removeRenderer(selfRenderer);
        }
      }
      publicAPI.modified();
    };
    publicAPI.setViewportCorner = (corner) => {
      if (corner === model.viewportCorner) {
        return;
      }
      model.viewportCorner = corner;
      publicAPI.updateViewport();
    };
    publicAPI.setViewportSize = (sizeFactor) => {
      const viewportSize = Math.min(1, Math.max(0, sizeFactor));
      if (viewportSize === model.viewportSize) {
        return;
      }
      model.viewportSize = viewportSize;
      publicAPI.updateViewport();
    };
    publicAPI.setActor = (actor) => {
      const previousState = model.enabled;
      publicAPI.setEnabled(false);
      model.actor = actor;
      publicAPI.setEnabled(previousState);
    };
    publicAPI.getRenderer = () => selfRenderer;
    publicAPI.delete = () => {
      superClass.delete();
      if (selfSubscription) {
        selfSubscription.unsubscribe();
        selfSubscription = null;
      }
      if (onCameraChangedSub) {
        onCameraChangedSub.unsubscribe();
        onCameraChangedSub = null;
      }
      if (onCameraModifiedSub) {
        onCameraModifiedSub.unsubscribe();
        onCameraModifiedSub = null;
      }
      if (onAnimationSub) {
        onAnimationSub.unsubscribe();
        onAnimationSub = null;
      }
      if (onEndAnimationSub) {
        onEndAnimationSub.unsubscribe();
        onEndAnimationSub = null;
      }
      resizeObserver.disconnect();
    };
    selfSubscription = publicAPI.onModified(publicAPI.updateViewport);
  }
  var DEFAULT_VALUES114 = {
    // actor: null,
    // _interactor: null,
    viewportCorner: Constants16.Corners.BOTTOM_LEFT,
    viewportSize: 0.2,
    minPixelSize: 50,
    maxPixelSize: 200,
    parentRenderer: null,
    interactiveRenderer: false
  };
  function extend121(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES114, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ["enabled", "viewportCorner", "viewportSize", "interactiveRenderer"]);
    macro.setGet(publicAPI, model, ["_interactor", "minPixelSize", "maxPixelSize", "parentRenderer"]);
    macro.get(publicAPI, model, ["actor"]);
    macro.moveToProtected(publicAPI, model, ["interactor"]);
    vtkOrientationMarkerWidget(publicAPI, model);
  }
  var newInstance120 = macro.newInstance(extend121, "vtkOrientationMarkerWidget");
  var vtkOrientationMarkerWidget$1 = {
    newInstance: newInstance120,
    extend: extend121,
    ...Constants16
  };

  // src/orientation.js
  function createOrientationWidget(renderWindow) {
    const axes = vtkAxesActor$1.newInstance();
    const orientationWidget = vtkOrientationMarkerWidget$1.newInstance({
      actor: axes,
      interactor: renderWindow.getInteractor()
    });
    orientationWidget.setEnabled(true);
    orientationWidget.setViewportCorner(
      vtkOrientationMarkerWidget$1.Corners.BOTTOM_LEFT
    );
    orientationWidget.setViewportSize(0.15);
    orientationWidget.setMinPixelSize(100);
    orientationWidget.setMaxPixelSize(300);
    return orientationWidget;
  }

  // src/camera.js
  function positionCameraForLabel(center, normal, distance3 = 800, onComplete = null) {
    const renderer = getRenderer();
    if (!renderer) return;
    const camera = renderer.getActiveCamera();
    const targetPos = [
      center[0] + normal[0] * distance3,
      center[1] + normal[1] * distance3,
      center[2] + normal[2] * distance3
    ];
    const startPos = camera.getPosition();
    const startFocal = camera.getFocalPoint();
    const duration = 800;
    const startTime = Date.now();
    function animate() {
      const elapsed = Date.now() - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      const currentPos = [
        startPos[0] + (targetPos[0] - startPos[0]) * eased,
        startPos[1] + (targetPos[1] - startPos[1]) * eased,
        startPos[2] + (targetPos[2] - startPos[2]) * eased
      ];
      const currentFocal = [
        startFocal[0] + (center[0] - startFocal[0]) * eased,
        startFocal[1] + (center[1] - startFocal[1]) * eased,
        startFocal[2] + (center[2] - startFocal[2]) * eased
      ];
      camera.setPosition(...currentPos);
      camera.setFocalPoint(...currentFocal);
      camera.setViewUp(0, 0, 1);
      renderer.resetCameraClippingRange();
      const renderWindow = getRenderWindow();
      if (renderWindow) {
        renderWindow.render();
      }
      if (t < 1) {
        requestAnimationFrame(animate);
      } else if (onComplete) {
        onComplete();
      }
    }
    animate();
  }
  function resetCamera() {
    const renderer = getRenderer();
    const renderWindow = getRenderWindow();
    if (renderer) {
      const camera = renderer.getActiveCamera();
      renderer.resetCamera();
      const focalPoint = camera.getFocalPoint();
      const distance3 = camera.getDistance();
      const tiltX = -45 * Math.PI / 180;
      const rotZ = -150 * Math.PI / 180;
      let dirX = 0;
      let dirY = -1;
      let dirZ = 0;
      const tempX = dirX * Math.cos(rotZ) - dirY * Math.sin(rotZ);
      const tempY = dirX * Math.sin(rotZ) + dirY * Math.cos(rotZ);
      dirX = tempX;
      dirY = tempY;
      const tempY2 = dirY * Math.cos(tiltX) - dirZ * Math.sin(tiltX);
      const tempZ2 = dirY * Math.sin(tiltX) + dirZ * Math.cos(tiltX);
      dirY = tempY2;
      dirZ = tempZ2;
      const position = [
        focalPoint[0] - dirX * distance3,
        focalPoint[1] - dirY * distance3,
        focalPoint[2] - dirZ * distance3
      ];
      camera.setPosition(...position);
      camera.setFocalPoint(...focalPoint);
      camera.setViewUp(0, 0, 1);
      renderer.resetCameraClippingRange();
    }
    if (renderWindow) {
      renderWindow.render();
    }
  }

  // src/labels.js
  function highlightLabel(labelName) {
    const labelsData = getLabelsData();
    if (!labelsData || !labelsData[labelName]) {
      console.warn("Label not found:", labelName);
      return;
    }
    const label = labelsData[labelName];
    const targetHemi = label.hemi;
    const vertices = label.vertices;
    const targetConfig = getHemisphereConfig(targetHemi);
    if (!targetConfig.meshData) {
      console.warn("Hemisphere data not loaded:", targetHemi);
      return;
    }
    ["lh", "rh"].forEach((hemi) => {
      const config = getHemisphereConfig(hemi);
      if (!config.meshData) return;
      const meshData = config.meshData;
      const mapper = config.mapper;
      if (hemi === targetHemi) {
        const labelVertexSet = new Set(vertices);
        const numVertices = meshData.vertices.length;
        const blendedScalars = new Float32Array(numVertices);
        for (let i = 0; i < numVertices; i++) {
          if (labelVertexSet.has(i)) {
            blendedScalars[i] = 10;
          } else {
            blendedScalars[i] = meshData.curvature ? meshData.curvature[i] : 0;
          }
        }
        const polyData = createPolyDataFromMesh(
          meshData,
          config.offsetX,
          config.offsetZ,
          config.rotateZ
        );
        const scalars = vtkDataArray$1.newInstance({
          name: "BlendedData",
          values: blendedScalars,
          numberOfComponents: 1
        });
        polyData.getPointData().setScalars(scalars);
        mapper.setInputData(polyData);
        applyLabelHighlightColoring(mapper);
        config.polyData = polyData;
      } else {
        const polyData = createPolyDataFromMesh(
          meshData,
          config.offsetX,
          config.offsetZ,
          config.rotateZ
        );
        mapper.setInputData(polyData);
        applyCurvatureColoring(mapper, meshData);
        config.polyData = polyData;
      }
    });
    const { center, normal } = computeLabelCenterAndNormal(
      targetConfig.meshData,
      vertices,
      targetConfig.offsetX,
      targetConfig.offsetZ,
      targetConfig.rotateZ
    );
    const renderWindow = getRenderWindow();
    if (renderWindow) {
      renderWindow.render();
    }
    positionCameraForLabel(center, normal, 800, () => {
      setupCameraInteractionListener(
        getRenderWindow,
        getRenderer,
        getCurrentSelectedLabel,
        getLabelsData,
        getHemisphereConfig
      );
      const renderer = getRenderer();
      const renderWindow2 = getRenderWindow();
      if (renderer && renderWindow2) {
        adjustHemisphereOpacitySmooth(
          targetHemi,
          targetConfig.meshData,
          vertices,
          targetConfig.offsetX,
          targetConfig.offsetZ,
          targetConfig.rotateZ,
          getHemisphereConfig,
          renderer,
          () => renderWindow2.render()
        );
      }
    });
  }
  function resetToDefaultColoring() {
    const renderWindow = getRenderWindow();
    ["lh", "rh"].forEach((hemi) => {
      const config = getHemisphereConfig(hemi);
      if (!config.meshData) return;
      const meshData = config.meshData;
      const mapper = config.mapper;
      const polyData = createPolyDataFromMesh(
        meshData,
        config.offsetX,
        config.offsetZ,
        config.rotateZ
      );
      mapper.setInputData(polyData);
      applyCurvatureColoring(mapper, meshData);
      config.polyData = polyData;
    });
    resetHemisphereOpacitySmooth(["lh", "rh"], getHemisphereConfig, () => {
      if (renderWindow) {
        renderWindow.render();
      }
    });
    if (renderWindow) {
      renderWindow.render();
    }
  }
  function handleLabelClick(labelName) {
    const currentLabel = getCurrentSelectedLabel();
    document.querySelectorAll(".label-list li").forEach((el) => el.classList.remove("active"));
    if (currentLabel === labelName) {
      setCurrentSelectedLabel(null);
      resetToDefaultColoring();
    } else {
      setCurrentSelectedLabel(labelName);
      const labelElements = document.querySelectorAll(".label-list li");
      labelElements.forEach((el) => {
        if (el.dataset.labelName === labelName) {
          el.classList.add("active");
        }
      });
      highlightLabel(labelName);
    }
  }

  // src/ui.js
  function getDisplayName(labelName) {
    const labelNamesData = getLabelNamesData();
    if (isPlainEnglishNamesEnabled() && labelNamesData) {
      const baseLabel = labelName.replace(/-lh$|-rh$/i, "");
      if (labelNamesData[baseLabel]) {
        return labelNamesData[baseLabel];
      }
    }
    return labelName;
  }
  function populateLabelList(labels) {
    const lhList = document.getElementById("labels-lh");
    const rhList = document.getElementById("labels-rh");
    lhList.innerHTML = "";
    rhList.innerHTML = "";
    const sortedLabels = Object.keys(labels).sort();
    sortedLabels.forEach((labelName) => {
      const label = labels[labelName];
      const li = document.createElement("li");
      li.textContent = getDisplayName(labelName);
      li.dataset.labelName = labelName;
      li.addEventListener("click", () => {
        handleLabelClick(labelName);
      });
      if (label.hemi === "lh") {
        lhList.appendChild(li);
      } else if (label.hemi === "rh") {
        rhList.appendChild(li);
      }
    });
  }
  function initializeHelpModal() {
    const helpBtn = document.getElementById("help-btn");
    const modal = document.getElementById("instructions-modal");
    const closeBtn = modal.querySelector(".close");
    helpBtn.addEventListener("click", () => {
      modal.classList.add("show");
    });
    closeBtn.addEventListener("click", () => {
      modal.classList.remove("show");
    });
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        modal.classList.remove("show");
      }
    });
  }
  function initializeNameToggle() {
    const toggleNamesBtn = document.getElementById("toggle-names-btn");
    toggleNamesBtn.addEventListener("click", () => {
      const isPlainEnglish = togglePlainEnglishNames();
      toggleNamesBtn.classList.toggle("active", isPlainEnglish);
      if (isPlainEnglish) {
        toggleNamesBtn.title = "Switch to FreeSurfer names";
      } else {
        toggleNamesBtn.title = "Switch to plain English names";
      }
      const labelsData = getLabelsData();
      populateLabelList(labelsData);
      const currentLabel = getCurrentSelectedLabel();
      if (currentLabel) {
        const labelElements = document.querySelectorAll(".label-list li");
        labelElements.forEach((el) => {
          if (el.dataset.labelName === currentLabel) {
            el.classList.add("active");
          }
        });
      }
    });
  }
  function showLoading() {
    const loadingEl = document.querySelector(".loading");
    if (loadingEl) {
      loadingEl.style.display = "block";
      loadingEl.textContent = "Loading brain model...";
    }
  }
  function hideLoading() {
    const loadingEl = document.querySelector(".loading");
    if (loadingEl) {
      loadingEl.remove();
    }
  }
  function showError(message) {
    const loadingEl = document.querySelector(".loading");
    if (loadingEl) {
      loadingEl.textContent = message;
      loadingEl.style.color = "#ff6b6b";
    }
  }
  function initializeGeometrySelector(onGeometryChange) {
    const geometrySelect = document.getElementById("geometry-select");
    if (!geometrySelect) {
      console.warn("Geometry selector not found");
      return;
    }
    geometrySelect.addEventListener("change", (e) => {
      const newGeometry = e.target.value;
      console.log("Geometry changed to:", newGeometry);
      if (onGeometryChange) {
        onGeometryChange(newGeometry);
      }
    });
  }

  // src/main.js
  async function loadBrainGeometry(geometry) {
    const renderer = getRenderer();
    if (!renderer) {
      console.error("Renderer not initialized");
      return;
    }
    console.log(`Loading ${geometry} surfaces...`);
    const geometryFileMap = {
      "inflated": "inflated",
      "original": "orig",
      "pial": "pial",
      "white": "white"
    };
    const fsGeometry = geometryFileMap[geometry] || geometry;
    const lhConfig = getHemisphereConfig("lh");
    await loadHemisphere(
      `../data/fsaverage/surf/lh.${fsGeometry}`,
      `../data/fsaverage/surf/lh.curv`,
      "lh",
      lhConfig.offsetX,
      lhConfig.offsetZ,
      lhConfig.rotateZ,
      renderer
    );
    const rhConfig = getHemisphereConfig("rh");
    await loadHemisphere(
      `../data/fsaverage/surf/rh.${fsGeometry}`,
      `../data/fsaverage/surf/rh.curv`,
      "rh",
      rhConfig.offsetX,
      rhConfig.offsetZ,
      rhConfig.rotateZ,
      renderer
    );
    console.log(`${geometry} surfaces loaded successfully`);
  }
  async function handleGeometryChange(newGeometry) {
    try {
      showLoading();
      const loadingEl = document.querySelector(".loading");
      if (loadingEl) {
        loadingEl.textContent = `Loading ${newGeometry} geometry...`;
      }
      const selectedLabel = getCurrentSelectedLabel();
      setCurrentGeometry(newGeometry);
      const renderer = getRenderer();
      const lhConfig = getHemisphereConfig("lh");
      const rhConfig = getHemisphereConfig("rh");
      if (lhConfig.actor) {
        renderer.removeActor(lhConfig.actor);
      }
      if (rhConfig.actor) {
        renderer.removeActor(rhConfig.actor);
      }
      await loadBrainGeometry(newGeometry);
      if (selectedLabel) {
        highlightLabel(selectedLabel);
        document.querySelectorAll(".label-list li").forEach((el) => {
          if (el.dataset.labelName === selectedLabel) {
            el.classList.add("active");
          }
        });
      } else {
        resetToDefaultColoring();
        resetCamera();
      }
      hideLoading();
    } catch (error) {
      console.error("Error loading geometry:", error);
      showError(`Error loading ${newGeometry} geometry. File may not exist.`);
    }
  }
  async function initializeApp() {
    try {
      const fullScreenRenderer = vtkFullScreenRenderWindow$1.newInstance({
        rootContainer: document.getElementById("vtk-container"),
        background: [0.2, 0.3, 0.4]
      });
      const renderer = fullScreenRenderer.getRenderer();
      const renderWindow = fullScreenRenderer.getRenderWindow();
      setRenderer(renderer, renderWindow);
      createOrientationWidget(renderWindow);
      console.log("Loading labels...");
      const labelsData = await loadLabels("../data/json/labels.json");
      setLabelsData(labelsData);
      console.log("Labels loaded:", Object.keys(labelsData).length);
      const labelNamesData = await loadLabelNames("../data/aparc.a2009s.lookup.json");
      setLabelNamesData(labelNamesData);
      if (labelNamesData) {
        console.log("Label names loaded");
      }
      populateLabelList(labelsData);
      initializeHelpModal();
      initializeNameToggle();
      initializeGeometrySelector(handleGeometryChange);
      const initialGeometry = getCurrentGeometry();
      await loadBrainGeometry(initialGeometry);
      console.log("Brain model loaded successfully!");
      hideLoading();
      resetCamera();
    } catch (error) {
      console.error("Error loading brain model:", error);
      showError("Error loading brain model. Check console for details.");
    }
  }
  document.addEventListener("DOMContentLoaded", initializeApp);
})();
